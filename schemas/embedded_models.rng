<?xml version="1.0" encoding="UTF-8"?>
<grammar xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0" xmlns="http://relaxng.org/ns/structure/1.0" datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes">
  <!-- The embedded models -->
  <define name="embedded_models">
    <element name="embedded_models">
      <a:documentation>Fluidity embedded models</a:documentation>
      <ref name="comment"/>
      <optional>
        <ref name="hyperlight"/>
      </optional>
      <optional>
        <ref name="lagrangian_biology"/>
      </optional>
    </element>
  </define>
  <define name="lagrangian_biology">
    <element name="lagrangian_ensemble_biology">
      <a:documentation>Lagrangian particle biology from the VEW project.</a:documentation>
      <optional>
        <element name="functional_group">
          <a:documentation>Placeholder for future Plankton Functional Type (PFT) definitions</a:documentation>
          <zeroOrMore>
            <element name="agent_array">
              <a:documentation>Arrays of lagrangian detectors with an additional Random Walk displacement scheme to simulate turbulent displacement.
In the future, these agents will carry biology information for Lagrangian Ensemble biology algorithms.</a:documentation>
              <ref name="comment"/>
              <attribute name="name">
                <data type="string"/>
              </attribute>
              <element name="number_of_agents">
                <a:documentation>The initial number of detectors held in this array.</a:documentation>
                <ref name="integer"/>
              </element>
              <element name="initial_position">
                <a:documentation>Python function prescribing dimensional vector input. Functions should be of the form:

 def val(t):
    # Function code
    return # Return value

The return value must have length number_of_detectors.

*** IMPORTANT NOTE ***

The t argument is for future use only - currently detector locations are only set at simulation start.</a:documentation>
                <ref name="python_code"/>
              </element>
              <optional>
                <element name="random_walk">
                  <a:documentation>Additional particle advection to simulate turbulent displacement. </a:documentation>
                  <choice>
                    <element name="python">
                      <a:documentation>Python function prescribing additional agent displacement due to turbulence. 
The return value will be added to the lagrangian advection at each sub-timestep. 
Fields should be pulled from 'state' before the val(ele, local_coord) function is evaluated.
Functions should be of the form:

 field = state.scalar_fields['Field_name']

 def val(ele, local_coord):
    # x = field.eval_field(ele, local_coord)
    return # Return some f(x)</a:documentation>
                      <ref name="python_code"/>
                    </element>
                    <element name="diffusive_random_walk">
                      <a:documentation>Hardcoded Random Walk scheme for non-homogeneous diffusivity fields.
Described in Visser, 1997 and Ross and Sharples, 2004.
Requires name of diffusivity field and according gradient field.</a:documentation>
                      <attribute name="diffusivity_field">
                        <data type="string"/>
                      </attribute>
                      <attribute name="diffusivity_gradient">
                        <data type="string"/>
                      </attribute>
                      <optional>
                        <element name="auto_subcycle">
                          <attribute name="diffusivity_2nd_gradient">
                            <data type="string"/>
                          </attribute>
                          <element name="scale_factor">
                            <ref name="real"/>
                          </element>
                        </element>
                      </optional>
                    </element>
                    <element name="naive_random_walk">
                      <a:documentation>Hardcoded Naive Random Walk scheme for verifying the RNG</a:documentation>
                      <attribute name="diffusivity_field">
                        <data type="string"/>
                      </attribute>
                    </element>
                  </choice>
                </element>
              </optional>
              <optional>
                <element name="exclude_from_advection">
                  <a:documentation>Skip velocity advection algorithm (RK-GS)</a:documentation>
                  <empty/>
                </element>
              </optional>
            </element>
          </zeroOrMore>
          <ref name="lagrangian_timestepping"/>
        </element>
      </optional>
      <element name="random_seed">
        <ref name="integer"/>
      </element>
    </element>
  </define>
  <define name="hyperlight">
    <element name="hyperlight">
      <a:documentation>Hyperlight solar irradiance model, which 
computes a fast approximation to the Radiative Transfer Equation.
NOTE: This module requires fluidity to be compiled with the 
--enable-hyperlight flag.</a:documentation>
      <element name="scalar_field">
        <a:documentation>Hydrolight always computes the scalar irradiance 
for 36 regular wavebands of width 10nm in PAR. 
Particular wavebands or total PAR irradiance need 
to be derived from these fixed bands.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>IrradianceTemplate</value>
        </attribute>
        <element name="prescribed">
          <ref name="velocity_mesh_choice"/>
          <ref name="prescribed_scalar_field"/>
        </element>
      </element>
      <optional>
        <element name="scalar_field">
          <attribute name="rank">
            <value>0</value>
          </attribute>
          <attribute name="name">
            <value>IrradiancePAR</value>
          </attribute>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="scalar_python_diagnostic_algorithm"/>
            <ref name="diagnostic_scalar_field_no_adapt"/>
          </element>
        </element>
      </optional>
      <element name="CDOM">
        <a:documentation>F, the ratio for correlated CDOM</a:documentation>
        <ref name="real"/>
      </element>
      <element name="BF_chl">
        <a:documentation>BF_chl, the backscatter fraction for chlorophyll-bearing particles</a:documentation>
        <ref name="real"/>
      </element>
      <optional>
        <element name="CloudCover">
          <a:documentation>Parameter for GC sky irradiance model - 
if provided this overwrites the values from the forcing routines.</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
      <optional>
        <element name="WindSpeed">
          <a:documentation>Parameter for GC sky irradiance model - 
if provided this overwrites the values from the forcing routines.</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
      <optional>
        <element name="EuphoticRatio">
          <a:documentation>Optional performance parameter that determines the percentage of 
surface irradiance at which the model stops computing.
Default is 0.01 = 1% (standard definition of euphotic depth)</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
    </element>
  </define>
</grammar>
