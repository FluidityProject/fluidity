<?xml version="1.0" encoding="UTF-8"?>
<grammar xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0" xmlns="http://relaxng.org/ns/structure/1.0" datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes">
  <include href="spud_base.rng"/>
  <include href="diagnostic_algorithms.rng"/>
  <include href="stabilisation.rng"/>
  <start>
    <element name="fluidity_options">
      <a:documentation>The root node of the options dictionary.</a:documentation>
      <ref name="comment"/>
      <element name="simulation_name">
        <a:documentation>Model output files are named according to the simulation
name, e.g. [simulation_name]_0.vtu. Non-standard
characters in the simulation name should be avoided.</a:documentation>
        <ref name="anystring"/>
      </element>
      <element name="geometry">
        <a:documentation>Options dealing with the specification of geometry</a:documentation>
        <element name="dimension">
          <a:documentation>Dimension of the problem.
&lt;b&gt;This can only be set once&lt;/b&gt;</a:documentation>
          <element name="integer_value">
            <attribute name="rank">
              <value>0</value>
            </attribute>
            <choice>
              <value>3</value>
              <value>2</value>
              <value>1</value>
            </choice>
          </element>
        </element>
        <element name="mesh">
          <a:documentation>The position mesh</a:documentation>
          <attribute name="name">
            <value>CoordinateMesh</value>
          </attribute>
          <ref name="mesh_info"/>
        </element>
        <element name="mesh">
          <a:documentation>The velocity mesh</a:documentation>
          <attribute name="name">
            <value>VelocityMesh</value>
          </attribute>
          <ref name="mesh_info"/>
        </element>
        <zeroOrMore>
          <element name="mesh">
            <attribute name="name">
              <data type="string"/>
            </attribute>
            <ref name="mesh_info"/>
            <optional>
              <element name="exclude_from_mesh_adaptivity">
                <empty/>
              </element>
            </optional>
          </element>
        </zeroOrMore>
        <element name="quadrature">
          <a:documentation>Quadrature</a:documentation>
          <element name="degree">
            <a:documentation>Quadrature degree

note: this specifies the degree of quadrature,
not the number of gauss points</a:documentation>
            <ref name="integer"/>
          </element>
          <optional>
            <element name="surface_degree">
              <a:documentation>Surface quadrature degree

note: this specifies the degree of surface
quadrature not the number of surface gauss points</a:documentation>
              <ref name="integer"/>
            </element>
          </optional>
          <optional>
            <element name="quadrature_family">
              <a:documentation>Select which family of quadrature rules to use.
The default is family_cools.
family_wandzura allows for degree up to 30
on triangular meshes.
family_grundmann_moeller allows for degree up to
29 on simplicial meshes in arbitrary dimension.</a:documentation>
              <choice>
                <value>family_cools</value>
                <value>family_grundmann_moeller</value>
                <value>family_wandzura</value>
              </choice>
            </element>
          </optional>
        </element>
      </element>
      <element name="io">
        <a:documentation>Input/output options</a:documentation>
        <element name="dump_format">
          <a:documentation>Format for dump files. Only vtk for now.</a:documentation>
          <element name="string_value">
            <value>vtk</value>
          </element>
        </element>
        <choice>
          <element name="dump_period">
            <a:documentation>Period between dumps in time units.

Specifies the period between each dump of the solution to disk.
A value of 0.0 indicates that there would be a dump at every timestep.</a:documentation>
            <choice>
              <element name="constant">
                <ref name="real"/>
              </element>
              <element name="python">
                <a:documentation>Python function prescribing real input. Functions should be of the form:

 def val(t):
    # Function code
    return # Return value

</a:documentation>
                <ref name="python_code"/>
              </element>
            </choice>
          </element>
          <element name="dump_period_in_timesteps">
            <a:documentation>Dump period, in timesteps.

Specifies the number of timesteps between each dump of the solution to disk.
A value of 0 indicates a dump at every timestep.</a:documentation>
            <choice>
              <element name="constant">
                <ref name="integer"/>
              </element>
              <element name="python">
                <a:documentation>Python function prescribing real input. Functions should be of the form:

 def val(t):
    # Function code
    return # Return value

</a:documentation>
                <ref name="python_code"/>
              </element>
            </choice>
          </element>
        </choice>
        <optional>
          <!-- every CPUDUM seconds write results to disc. -->
          <element name="cpu_dump_period">
            <a:documentation>This is usually disabled.</a:documentation>
            <ref name="real"/>
          </element>
        </optional>
        <optional>
          <element name="wall_time_dump_period">
            <a:documentation>The period between dumps in walltime seconds. This is usually disabled.</a:documentation>
            <ref name="real"/>
          </element>
        </optional>
        <choice>
          <element name="output_mesh">
            <a:documentation>The mesh on to which all the fields will be
interpolated for VTK output.</a:documentation>
            <attribute name="name">
              <value>VelocityMesh</value>
            </attribute>
          </element>
          <element name="output_mesh">
            <a:documentation>The mesh on to which all the fields will be
interpolated for VTK output.</a:documentation>
            <attribute name="name">
              <value>PressureMesh</value>
            </attribute>
          </element>
          <element name="output_mesh">
            <a:documentation>The mesh on to which all the fields will be
interpolated for VTK output.</a:documentation>
            <attribute name="name">
              <value>CoordinateMesh</value>
            </attribute>
          </element>
          <element name="output_mesh">
            <a:documentation>The mesh on to which all the fields will be
interpolated for VTK output.</a:documentation>
            <attribute name="name">
              <data type="string"/>
            </attribute>
          </element>
        </choice>
      </element>
      <element name="timestepping">
        <a:documentation>Options dealing with time discretisation</a:documentation>
        <element name="current_time">
          <a:documentation>Current simulation time. At the start of the simulation this
is the start time.</a:documentation>
          <ref name="real"/>
          <optional>
            <element name="time_units">
              <a:documentation>The following excerpt from the Udunits
documentation explains the time unit encoding by
example:

The specification:

seconds since 1992-10-8 15:15:42.5 -6:00

indicates seconds since October 8th, 1992 at 3
hours, 15 minutes and 42.5 seconds in the afternoon
in the time zone which is six hours to the west of
Coordinated Universal Time (i.e.  Mountain Daylight
Time). The time zone specification can also be
written without a colon using one or two-digits
(indicating hours) or three or four digits
(indicating hours and minutes).

Time units are particularly required in situations
where the problem (time-varying) boundary conditions
and/ initial conditions are a function of time as
defined by a calendar.  Examples include atmospheric
forcing and climatology. The current time, specified
above, is zero at the reference data/time.</a:documentation>
              <attribute name="date">
                <data type="string"/>
              </attribute>
            </element>
          </optional>
        </element>
        <element name="timestep">
          <a:documentation>The time step size. If adaptive time stepping is used
then this is the initial time step size.</a:documentation>
          <ref name="real"/>
        </element>
        <element name="finish_time">
          <a:documentation>Simulation time at which the simulation should end.</a:documentation>
          <ref name="real"/>
        </element>
        <optional>
          <element name="final_timestep">
            <a:documentation>Timestep after which the simulation should end.</a:documentation>
            <ref name="integer"/>
          </element>
        </optional>
        <optional>
          <element name="cpu_time_limit">
            <a:documentation>Maximum CPU time (secs) taken up before
simulation terminates writing results to disc.

Manual suggests 1.E+20</a:documentation>
            <ref name="real"/>
          </element>
        </optional>
        <optional>
          <element name="wall_time_limit">
            <a:documentation>Maximum wall time (secs) taken up before
simulation terminates writing results to disc.

This is usually disabled.</a:documentation>
            <ref name="real"/>
          </element>
        </optional>
      </element>
      <element name="material_phase">
        <a:documentation>The material or phase options</a:documentation>
        <attribute name="name">
          <value>Fluid</value>
        </attribute>
        <group>
          <optional>
            <element name="vector_field">
              <a:documentation>Velocity vector and momentum options</a:documentation>
              <attribute name="rank">
                <value>1</value>
              </attribute>
              <attribute name="name">
                <value>Velocity</value>
              </attribute>
              <element name="prescribed">
                <a:documentation>Field type</a:documentation>
                <element name="mesh">
                  <attribute name="name">
                    <value>VelocityMesh</value>
                  </attribute>
                </element>
                <ref name="prescribed_vector_field"/>
              </element>
            </element>
          </optional>
          <element name="scalar_field">
            <a:documentation>Passive Tracer</a:documentation>
            <attribute name="rank">
              <value>0</value>
            </attribute>
            <attribute name="name">
              <value>Tracer</value>
            </attribute>
            <element name="prognostic">
              <ref name="velocity_mesh_choice"/>
              <ref name="prognostic_scalar_field"/>
            </element>
          </element>
          <optional>
            <element name="scalar_field">
              <a:documentation>CFLNumber

See http://amcg.ese.ic.ac.uk/index.php?title=Local:Diagnostics#CFL_Number

Adapting to this field is not recommended</a:documentation>
              <attribute name="rank">
                <value>0</value>
              </attribute>
              <attribute name="name">
                <value>CFLNumber</value>
              </attribute>
              <element name="diagnostic">
                <ref name="internal_algorithm"/>
                <ref name="velocity_mesh_choice"/>
                <ref name="diagnostic_scalar_field"/>
              </element>
            </element>
          </optional>
        </group>
        <!--
          scalar_field_choice*,
          vector_field_choice*,
          tensor_field_choice*
        -->
      </element>
    </element>
  </start>
  <!-- Choice of input method, e.g. for boundary conditions -->
  <define name="input_choice_real">
    <ref name="input_choice_real_contents"/>
  </define>
  <define name="input_choice_real_plus_boundary_forcing">
    <choice>
      <ref name="input_choice_real_contents"/>
      <element name="from_file">
        <oneOrMore>
          <element name="tidal">
            <attribute name="file_name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <attribute name="variable_name_amplitude">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <attribute name="variable_name_phase">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <attribute name="name">
              <a:documentation>See E.W. Schwiderski - Rev. Geophys. Space
Phys. Vol. 18 No. 1 pp. 243--268, 1980
for details of these constituent.</a:documentation>
              <choice>
                <value>M2</value>
                <value>S2</value>
                <value>N2</value>
                <value>K2</value>
                <value>K1</value>
                <value>O1</value>
                <value>P1</value>
                <value>Q1</value>
                <value>Mf</value>
                <value>Mm</value>
                <value>Ssa</value>
              </choice>
            </attribute>
          </element>
        </oneOrMore>
      </element>
    </choice>
  </define>
  <define name="input_choice_real_plus_file">
    <choice>
      <ref name="input_choice_real_contents"/>
      <element name="from_file">
        <a:documentation>Initialise the field from an existing file (indended primarily for picking up prescribed fields from previously run prognostic simulations). The file mesh must match the mesh of this field (except for piecewise constant fields which will be remapped back from the discontinuous nodal values).

THIS WILL NOT WORK FOR PRESCRIBED FIELDS NOT DIRECTLY UNDERNEATH /material_phase</a:documentation>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
        <element name="format">
          <a:documentation>The format of the input file containing field data.</a:documentation>
          <element name="string_value">
            <value>vtu</value>
          </element>
        </element>
        <ref name="comment"/>
      </element>
    </choice>
  </define>
  <define name="input_choice_real_contents">
    <choice>
      <element name="constant">
        <a:documentation>Constant value</a:documentation>
        <ref name="real"/>
      </element>
      <element name="python">
        <a:documentation>Python function prescribing real input. Functions should be of the form:

 def val(X, t):
    # Function code
    return # Return value

where X is a tuple of length geometry dimension.</a:documentation>
        <ref name="python_code"/>
      </element>
    </choice>
  </define>
  <!--
    Choice of input method for initial conditions
    Note: combine = "choice" should be used here to combine with input_choice_real, but Diamond doesn't support it
  -->
  <define name="input_choice_initial_condition_real">
    <choice>
      <element name="constant">
        <a:documentation>Constant value</a:documentation>
        <ref name="real"/>
      </element>
      <element name="python">
        <a:documentation>Python function prescribing real input. Functions should be of the form:

 def val(X, t):
    # Function code
    return # Return value

where X is a tuple of length geometry dimension.</a:documentation>
        <ref name="python_code"/>
      </element>
      <element name="from_file">
        <a:documentation>Initialise the field from an existing file (indended
primarily for use in checkpointing). The file mesh must match
the mesh of this field  (except for piecewise constant fields
which will be remapped back from the discontinuous nodal values).
In parallel the process number is
appended to the filename, e.g. if the file_name attribute is
set to "input.vtu", process 0 reads from "input-0.vtu".</a:documentation>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
        <element name="format">
          <a:documentation>The format of the input file containing field
data. Supported formats include: NetCDF CF 1.4
(http://cf-pcmdi.llnl.gov/)</a:documentation>
          <element name="string_value">
            <choice>
              <value>vtu</value>
              <value>NetCDF - CF 1.x</value>
            </choice>
          </element>
        </element>
        <ref name="comment"/>
      </element>
    </choice>
  </define>
  <!-- Choice of input method, e.g. for boundary conditions -->
  <define name="input_choice_real_dim_vector">
    <ref name="input_choice_real_dim_vector_contents"/>
  </define>
  <!-- Choice of input method, e.g. for prescribed fields -->
  <define name="input_choice_real_dim_vector_plus_file">
    <choice>
      <ref name="input_choice_real_dim_vector_contents"/>
      <element name="from_file">
        <a:documentation>Initialise the field from an existing file (indended primarily for picking up prescribed fields from previously run prognostic simulations). The file mesh must match the mesh of this field (except for piecewise constant fields which will be remapped back from the discontinuous nodal values).

THIS WILL NOT WORK FOR PRESCRIBED FIELDS NOT DIRECTLY UNDERNEATH /material_phase</a:documentation>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
        <element name="format">
          <a:documentation>The format of the input file containing field data.</a:documentation>
          <element name="string_value">
            <value>vtu</value>
          </element>
        </element>
        <ref name="comment"/>
      </element>
    </choice>
  </define>
  <define name="input_choice_real_dim_vector_contents">
    <choice>
      <element name="constant">
        <a:documentation>Constant value</a:documentation>
        <ref name="real_dim_vector"/>
      </element>
      <element name="python">
        <a:documentation>Python function prescribing dimensional vector input. Functions should be of the form:

 def val(X, t):
    # Function code
    return # Return value

where X and the return value are tuples of length geometry dimension.</a:documentation>
        <ref name="python_code"/>
      </element>
    </choice>
  </define>
  <!--
    Choice of input method, e.g. for boundary conditions
    this one specifies a vector field of dim minus one
  -->
  <define name="input_choice_real_dim_minus_one_vector">
    <choice>
      <element name="constant">
        <a:documentation>Constant value</a:documentation>
        <ref name="real_dim_minus_one_vector"/>
      </element>
      <element name="python">
        <a:documentation>Python function prescribing dimensional vector input. Functions should be of the form:

 def val(X, t):
    # Function code
    return # Return value

where X and the return value are tuples of length geometry dimension.</a:documentation>
        <ref name="python_code"/>
      </element>
    </choice>
  </define>
  <define name="input_choice_netcdf">
    <a:documentation>Import data from NetCDF CF-1.x file.</a:documentation>
    <element name="from_file">
      <attribute name="file_name">
        <a:documentation>The format of this file should conform to NetCDF CF 1.x
(http://cf-pcmdi.llnl.gov/)</a:documentation>
        <data type="string"/>
      </attribute>
      <ref name="comment"/>
    </element>
  </define>
  <!--
    Choice of input method for initial conditions
    Note: combine = "choice" should be used here to combine with input_choice_real, but Diamond doesn't support it
  -->
  <define name="input_choice_initial_condition_vector">
    <choice>
      <element name="constant">
        <a:documentation>Constant value</a:documentation>
        <ref name="real_dim_vector"/>
      </element>
      <element name="python">
        <a:documentation>Python function prescribing dimensional vector input. Functions should be of the form:

 def val(X, t):
    # Function code
    return # Return value

where X and the return value are tuples of length geometry dimension.</a:documentation>
        <ref name="python_code"/>
      </element>
      <element name="from_file">
        <a:documentation>Initialise the field from an existing file (indended primarily for use in checkpointing). The file mesh must match the mesh of this field (except for piecewise constant fields which will be remapped back from the discontinuous nodal values).</a:documentation>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
        <element name="format">
          <a:documentation>The format of the input file containing field data.</a:documentation>
          <element name="string_value">
            <value>vtu</value>
          </element>
        </element>
        <ref name="comment"/>
      </element>
    </choice>
  </define>
  <!--
    Choice of input method for initial/boundary conditions
    version for real symmetric tensor
  -->
  <define name="input_choice_real_dim_symmetric_tensor">
    <choice>
      <element name="constant">
        <a:documentation>Constant symmetric tensor</a:documentation>
        <ref name="real_dim_symmetric_tensor"/>
      </element>
      <element name="python">
        <a:documentation>Python command prescribing symmetric tensor input.

Note that it is for the python function to determine
that the results it produces are, in fact, symmetric.

An example that returns the three-dimensional identity:

 def val(X, t):
   return [[1, 0, 0],
               [0, 1, 0],
               [0, 0, 1]]</a:documentation>
        <ref name="python_code"/>
      </element>
    </choice>
  </define>
  <!--
    Choice of input method for initial/boundary conditions
    version for real tensor
  -->
  <define name="input_choice_real_dim_tensor">
    <choice>
      <element name="constant">
        <a:documentation>Constant tensor</a:documentation>
        <ref name="real_dim_tensor"/>
      </element>
      <element name="python">
        <a:documentation>Python command prescribing tensor input.

An example that returns the three-dimensional identity:

 def val(X, t):
   return [[1, 0, 0],
               [0, 1, 0],
               [0, 0, 1]]</a:documentation>
        <ref name="python_code"/>
      </element>
    </choice>
  </define>
  <define name="prognostic_velocity_field">
    <ref name="velocity_equation_choice"/>
    <element name="spatial_discretisation">
      <a:documentation>Spatial discretisation options</a:documentation>
      <choice>
        <element name="continuous_galerkin">
          <a:documentation>A new version of continuous galerkin assembly.</a:documentation>
          <element name="stabilisation">
            <a:documentation>Stabilisation options for the galerkin discretisation</a:documentation>
            <choice>
              <ref name="no_stabilisation"/>
              <ref name="su_stabilisation"/>
              <ref name="supg_stabilisation"/>
            </choice>
          </element>
          <element name="mass_terms">
            <a:documentation>Discretisation options for the mass terms in the velocity equation.</a:documentation>
            <optional>
              <element name="lump_mass_matrix">
                <a:documentation>Lump the mass matrix - currently required if solving for pressure</a:documentation>
                <optional>
                  <element name="use_submesh">
                    <a:documentation>Lump on the submesh.
This only works for simplex meshes and is only
strictly valid on 2d meshes.</a:documentation>
                    <empty/>
                  </element>
                </optional>
              </element>
            </optional>
            <optional>
              <element name="exclude_mass_terms">
                <a:documentation>Remove the mass terms from the equation.</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
          <element name="advection_terms">
            <a:documentation>Discretisation options for the advection terms in the velocity equation.</a:documentation>
            <optional>
              <element name="integrate_advection_by_parts">
                <a:documentation>Integrate the advection terms of the momentum equation by parts.
This allows for the imposition of weak boundary conditions.
If activated the element advection matrix takes the form:
   /                                            /
 - | (grad N_A dot nu) N_B rho dV - (1. - beta) | N_A ( div nu ) N_B rho dV
   /                                            /
otherwise it takes the standard form:
   /                                     /
   | N_A (nu dot grad N_B) rho dV + beta | N_A ( div nu ) N_B rho dV
   /                                     /
where beta is set in conservative_advection, N is
a shape function and nu is the relative nonlinear
velocity.</a:documentation>
                <empty/>
              </element>
            </optional>
            <optional>
              <element name="exclude_advection_terms">
                <a:documentation>Remove the advection terms (u.grad u rho + beta
div u rho u) from the equation.
This overrides any other advection term options
(including conservative_advection below).</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
          <element name="stress_terms">
            <a:documentation>Discretisation options for the stress terms in the velocity equation.</a:documentation>
            <choice>
              <element name="tensor_form">
                <a:documentation>Use tensor form of the stress terms.

This is only valid for incompressible
simulations as it is basically a simplication
of full stress form when divergent elements can
be cancelled out.

ONLY DIAGONAL COMPONENTS OF VISCOSITY CAN BE
SET (i.e. either isotropic or
anistropic_symmetric with zero off diagonals
tensors).

If diagonal components differ from each other
this must be for numerical reasons (i.e. not
physical variations in viscosity otherwise
simplification is not valid).

If activated, the dim x dim (in this example
3d) stress matrix takes the form:

 /  mu_xx*N_a,x*N_b,x + mu_yy*N_a,y*N_b,y + mu_zz*N_a,z*N_b,z
 |   0                                             ...
 \   0

     0
 ... mu_xx*N_a,x*N_b,x + mu_yy*N_a,y*N_b,y + mu_zz*N_a,z*N_b,z   ...
     0

     0                                                           \
 ... 0                                                           |
    mu_xx*N_a,x*N_b,x + mu_yy*N_a,y*N_b,y + mu_zz*N_a,z*N_b,z   /

which is derived from b_a^T c b_b, where:

 b_a = / N_a,x  \   c = /  mu_xx    0      0    \
       | N_a,y  |       |    0    mu_yy    0    |
       \ N_a,z  /       \    0      0    mu_zz  /

where N_a and N_b are shape functions of the
ath and bth node respectively and mu are the
components of the viscosity tensor.</a:documentation>
                <empty/>
              </element>
              <element name="stress_form">
                <a:documentation>Use full stress form of the stress tensor.

This is required if performing a compressible simulation.

If using a viscosity ALL COMPONENTS OF
VISCOSITY MUST BE SET (i.e. either
anisotropic_symmetric or
anisotropic_asymmetric tensors).

If components differ form each other this must
be for numerical reasons (i.e. not physical
variations in viscosity).

If activated, the dim x dim (in this example
3d) stress matrix takes the form:

 /   2*N_a,x*N_b,x*mu_xx + N_a,y*N_b,y*mu_yy + N_a,z*N_b,z*mu_zz - 2/3*N_a,x*N_b,x*mu_xx
 |   N_a,x*N_b,y*mu_xy - 2/3*N_a,y*N_b,x*mu_yx                                             ...
 \   N_a,x*N_b,z*mu_xz - 2/3*N_a,z*N_b,x*mu_zx

     N_a,y*N_b,x*mu_xy - 2/3*N_a,x*N_b,y*mu_xy
 ... N_a,x*N_b,x*mu_xx + 2*N_a,y*N_b,y*mu_yy + N_a,z*N_b,z*mu_zz - 2/3*N_a,y*N_b,y*mu_yy   ...
     N_a,y*N_b,z*mu_yz - 2/3*N_a,z*N_b,y*mu_zy

     N_a,z*N_b,x*mu_xz - 2/3*N_a,x*N_b,z*mu_xz                                             \
 ... N_a,z*N_b,y*mu_yz - 2/3*N_a,y*N_b,z*mu_yz                                             |
     N_a,x*N_b,x*mu_xx + N_a,y*N_b,y*mu_yy + 2*N_a,z*N_b,z*mu_zz - 2/3*N_a,z*N_b,z*mu_zz   /

which is derived from b_a^T c b_b, where:

 b_a = / N_a,x   0     0   \   c = /  4/3*mu_xx  -2/3*mu_xy -2/3*mu_xz  0    0    0   \
       |  0    N_a,y   0   |       | -2/3*mu_yx   4/3*mu_yy -2/3*mu_yz  0    0    0   |
       |   0     0   N_a,z |       | -2/3*mu_zx  -2/3*mu_zy  4/3*mu_zz  0    0    0   |
       | N_a,y N_a,x   0   |       |     0           0          0     mu_xy  0    0   |
       | N_a,z   0   N_a,x |       |     0           0          0       0  mu_xz  0   |
       \   0   N_a,z N_a,y /       \     0           0          0       0    0  mu_yz /

where N_a and N_b are shape functions of the ath and bth node respectively and mu are the components of the viscosity tensor.</a:documentation>
                <empty/>
              </element>
            </choice>
          </element>
          <optional>
            <element name="les_model">
              <element name="smagorinsky_coefficient">
                <a:documentation>suggested value 0.1</a:documentation>
                <ref name="real"/>
              </element>
              <element name="form">
                <choice>
                  <element name="tensor_form">
                    <empty/>
                  </element>
                  <element name="stress_form">
                    <empty/>
                  </element>
                </choice>
              </element>
              <element name="order">
                <choice>
                  <element name="second_order">
                    <empty/>
                  </element>
                  <element name="fourth_order">
                    <empty/>
                  </element>
                </choice>
              </element>
            </element>
          </optional>
        </element>
        <element name="discontinuous_galerkin">
          <a:documentation>Discontinuous galerkin formulation. This causes Momentum_DG to be
called instead of diff3d. Confusingly it is not necessary to provide
a discontinuous velocity field for this to work!</a:documentation>
          <optional>
            <element name="mass_terms">
              <a:documentation>Discretisation options for the mass terms in the velocity equation.</a:documentation>
              <optional>
                <element name="lump_mass_matrix">
                  <a:documentation>Lump the mass matrix</a:documentation>
                  <empty/>
                </element>
              </optional>
            </element>
          </optional>
          <element name="viscosity_scheme">
            <choice>
              <element name="bassi_rebay">
                <a:documentation>Classical scheme from Bassi and Rebay
(JCP 131 267-179 1997)</a:documentation>
                <empty/>
              </element>
              <element name="arbitrary_upwind">
                <a:documentation>Scheme in which upwinding is applied in
alternating directions. Devised by C.Pain.</a:documentation>
                <empty/>
              </element>
              <element name="interior_penalty">
                <a:documentation>Classical interior penalty scheme
see, e.g., SIAM Journal on Numerical Analysis
Vol. 39, No. 5 (2002), pp. 1749-1779 </a:documentation>
                <element name="penalty_parameter">
                  <a:documentation>Penalty_parameter
The penalty term Int [u][v] dS on element boundaries
is scaled by C = C_0 h**p
This option specifies the C_0
There is a theoretical lower bound for
stability and hence convergence</a:documentation>
                  <ref name="real"/>
                </element>
                <element name="edge_length_power">
                  <a:documentation>Penalty_parameter
The penalty term Int [u][v] dS on element boundaries
is scaled by C = C_0 h**p
This option specifies p
Theoretically p=-1 is required for linear elements</a:documentation>
                  <ref name="real"/>
                </element>
                <optional>
                  <element name="debug">
                    <a:documentation>Switch on debugging output</a:documentation>
                    <element name="gradient_test_bound">
                      <a:documentation>Bound for testing element gradient matrix</a:documentation>
                      <ref name="real"/>
                    </element>
                    <optional>
                      <element name="remove_element_integral">
                        <a:documentation>Remove the elemental integral:
Int grad u.kappa.grad v dV</a:documentation>
                        <empty/>
                      </element>
                    </optional>
                    <optional>
                      <element name="remove_primal_fluxes">
                        <a:documentation>Remove the primal fluxes</a:documentation>
                        <empty/>
                      </element>
                    </optional>
                    <optional>
                      <element name="remove_penalty_fluxes">
                        <a:documentation>Remove the penalty fluxes</a:documentation>
                        <empty/>
                      </element>
                    </optional>
                  </element>
                </optional>
              </element>
            </choice>
          </element>
          <element name="advection_scheme">
            <choice>
              <element name="upwind">
                <a:documentation>Straightforward upwinding of the nonlinear velocity.</a:documentation>
                <empty/>
              </element>
              <element name="none">
                <a:documentation>Disable advection</a:documentation>
                <empty/>
              </element>
            </choice>
            <element name="integrate_advection_by_parts">
              <a:documentation>Integrate the advection terms of the momentum equation by parts.

Integrating the advection term by parts is
necessary for a discontinuous
galerkin discretisation however it is possible to
select how many times the
integration by parts is performed.
Twice is the norm.</a:documentation>
              <choice>
                <element name="twice">
                  <a:documentation>If activated the element advection matrix takes the form:
   /                                 /
   | N_A (nu dot grad N_B) dV + beta | N_A ( div nu ) N_B dV
   /                                 /
     /                                         /
 + I | N_A_i (nu dot n) N_B_o ds + [(1-I) - 1] | N_A_i (nu dot n) N_B_i ds
     /                                         /
where beta is set in conservative_advection,
N is a shape function (uppercase
subscripts indicate nodes A or B while
lowercase subscripts indicate inner or outer
faces i and o respectively), nu is the
nonlinear velocity and n is the outward
pointing normal from the element.</a:documentation>
                  <empty/>
                </element>
                <element name="once">
                  <a:documentation>If activated the element advection matrix takes the form:
   /                                        /
 - | (grad N_A dot nu) N_B dV - (1. - beta) | N_A ( div nu ) N_B dV
   /                                        /
     /                                   /
 + I | N_A_i (nu dot n) N_B_o ds + (1-I) | N_A_i (nu dot n) N_B_i ds
     /                                   /
where beta is set in conservative_advection,
N is a shape function (uppercase
subscripts indicate nodes A or B while
lowercase subscripts indicate inner or outer
faces i and o respectively), nu is the
nonlinear velocity and n is the outward
pointing normal from the element.</a:documentation>
                  <empty/>
                </element>
              </choice>
            </element>
            <optional>
              <element name="integrate_conservation_term_by_parts">
                <a:documentation>If activated the conservation term:
 /
 | N_A ( div nu ) N_B dV
 /
is integrated_by_parts such that the element
advection matrix becomes:
        /                                        /
 - beta | (grad N_A dot nu) N_B dV + (1. - beta) | N_A (nu dot grad N_B) dV
        /                                        /
     /                                                /
 + I | N_A_i (nu dot n) N_B_o ds + [(1-I) - (1-beta)] | N_A_i (nu dot n) N_B_i ds
     /                                                /
where beta is set in conservative_advection, N is
a shape function (uppercase
subscripts indicate nodes A or B while lowercase
subscripts indicate inner or outer
faces i and o respectively), nu is the nonlinear
velocity and n is the outward pointing normal
from the element.
This is invariant regardless of whether the main
advection term is integrated by parts once or
twice.</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
        </element>
        <element name="legacy_continuous_galerkin">
          <a:documentation>Use the legacy finite element discretisation</a:documentation>
          <choice>
            <element name="balancing_diffusion_x">
              <a:documentation>balancing diffusion based on (x,y) space.</a:documentation>
              <empty/>
            </element>
            <element name="laxwendroff_balancing_diffusion">
              <a:documentation>Laxwendrof balancing diffusion.</a:documentation>
              <empty/>
            </element>
            <element name="balancing_diffusion_xt">
              <a:documentation>(x,y,t) -balancing diffusion.</a:documentation>
              <empty/>
            </element>
            <element name="no_balancing_diffusion">
              <a:documentation>No balancing diffusion.</a:documentation>
              <empty/>
            </element>
            <element name="nonlinear_streamline_w_crossstream_diffusion">
              <a:documentation>nonlinear streamline and cross stream diffusion.</a:documentation>
              <empty/>
            </element>
            <element name="nonlinear_upwind_steepest">
              <a:documentation>nonlinear upwind in steapest direction.</a:documentation>
              <empty/>
            </element>
            <element name="nonlinear_streamline_w_restricted_crossstream_diffusion">
              <a:documentation>nonlinear streamline+ cross stream diffusion(but restricted)</a:documentation>
              <empty/>
            </element>
            <element name="les_constant_length_scale">
              <a:documentation>LES option using constant length scale.</a:documentation>
              <empty/>
            </element>
            <element name="les_isotropic_length_scale">
              <a:documentation>LES option using isotropic length scale.</a:documentation>
              <empty/>
            </element>
            <element name="les_no_balancing_diffusion">
              <a:documentation>LES option which uses no balancing diffusion.</a:documentation>
              <empty/>
            </element>
            <element name="les_no_balancing_diffusion_2">
              <a:documentation>LES option which uses no balancing diffusion.</a:documentation>
              <empty/>
            </element>
            <element name="les_no_balancing_diffusion_fourth_order_dissipation">
              <a:documentation>same as 45 but with 4th order dissipation.</a:documentation>
              <empty/>
            </element>
            <element name="les_tensor_form">
              <a:documentation>LES but in tensor form like hart3d</a:documentation>
              <empty/>
            </element>
            <element name="les_fourth_order">
              <a:documentation>LES 4th order version of 47</a:documentation>
              <empty/>
            </element>
            <element name="no_balancing_diffusion_remove_nonlinear_terms">
              <a:documentation>NO balancing diffusion(DISOPT=4)and take out non-linear terms.</a:documentation>
              <empty/>
            </element>
          </choice>
          <optional>
            <element name="lump_mass_matrix">
              <a:documentation>Lump the mass matrix in the momentum equation</a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
        <element name="legacy_discretisation">
          <element name="legacy_disopt">
            <a:documentation>Legacy discretisation option (DISOPT)

 From diff3d comments (other possibilities are known to exist!):
 ==============================================================
 DISOPT=1 - balancing diffusion based on (x,y) space.
 DISOPT=2 - Laxwendrof balancing diffusion.
 DISOPT=3 - (x,y,t) -balancing diffusion.
 DISOPT=4 - No balancing diffusion.
 DISOPT=5 - nonlinear streamline and cross stream diffusion.
 DISOPT=6 - nonlinear upwind in steapest direction.
 DISOPT=7 - nonlinear streamline+ cross stream diffusion(but restricted)

 DISOPT=42- LES option using constant length scale.
 DISOPT=43- LES option using isotropic length scale.
 DISOPT=44- LES option which uses no balancing diffusion.
 DISOPT=45- LES option which uses no balancing diffusion.
 DISOPT=46- same as 45 but with 4th order dissipation.
 DISOPT=47 -LES but in tensor form like hart3d.
 DISOPT=48 -LES 4th order version of 47.

 DISOPT=125 - NO balancing diffusion(DISOPT=4)and take out non-linear terms.</a:documentation>
            <ref name="integer"/>
          </element>
          <optional>
            <element name="legacy_mlump">
              <a:documentation>Lump the mass matrix in the momentum equation</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="legacy_ndisop">
              <a:documentation>Legacy discretisation option for control volume advection of momentum (DISOPT)
Set to 0 if not activated
           Method for face-value est.   Time-stepping     Limiting
 ------------------------------------------------------------------
   =0      1st order in space          Theta=specified    UNIVERSAL
   =1      1st order in space          Theta=non-linear   UNIVERSAL
   =2      Trapazoidal rule in space   Theta=specified    UNIVERSAL
   =3      Trapazoidal rule in space   Theta=non-linear   UNIVERSAL
   =4      Finite elements in space    Theta=specified    UNIVERSAL
   =5      Finite elements in space    Theta=non-linear   UNIVERSAL
   =6      Finite elements in space    Theta=specified    NONE
   =7      Finite elements in space    Theta=non-linear   NONE
   =8      Finite elements in space    Theta=specified    DOWNWIND+
   =9      Finite elements in space    Theta=non-linear   DOWNWIND+</a:documentation>
              <ref name="integer"/>
            </element>
          </optional>
        </element>
      </choice>
      <element name="conservative_advection">
        <a:documentation>Conservative discretisation of momentum equations
 BETA=1. -- conservative (divergence form)
 BETA=0. -- non-conservative
 0. &lt; BETA &lt; 1.</a:documentation>
        <ref name="real"/>
      </element>
      <optional>
        <ref name="inner_element_velocity"/>
      </optional>
    </element>
    <element name="temporal_discretisation">
      <a:documentation>Temporal discretisation options</a:documentation>
      <element name="theta">
        <a:documentation>Implicit/explicit control (THETA)
 =0.  -- explicit
 =0.5 -- Crank-Nicolson
 =1.  -- implicit</a:documentation>
        <ref name="real"/>
      </element>
      <element name="relaxation">
        <a:documentation>Non-linear relaxation term
 =0.  -- previous timestep velocity solution used in non-linear terms of momentum equations
 =1.  -- previous iteration velocity solution used in non-linear terms of momentum equations
 0. &lt; ITHETA &lt; 1.</a:documentation>
        <ref name="real"/>
      </element>
      <optional>
        <element name="discontinuous_galerkin">
          <optional>
            <element name="number_advection_subcycles">
              <a:documentation>Use timestep subcycling to solve this equation.
Specify the number of subcycles.
This only works for pure control volume discretisations.</a:documentation>
              <ref name="integer"/>
            </element>
          </optional>
        </element>
      </optional>
    </element>
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options_asym"/>
    </element>
    <ref name="constitutive_laws"/>
    <oneOrMore>
      <choice>
        <element name="initial_condition">
          <a:documentation>Initial condition for WholeMesh

Only specify one condition if not using mesh regions.
Otherwise select other initial_condition option, specify region_ids
and distinct names.  Then add extra intial conditions for other regions.</a:documentation>
          <attribute name="name">
            <value>WholeMesh</value>
          </attribute>
          <ref name="input_choice_initial_condition_vector"/>
        </element>
        <element name="initial_condition">
          <a:documentation>Multiple initial_conditions are allowed if specifying
different values in different
regions of the mesh (defined by region_ids).  In this case
each initial_condition
requires a distinct name for the options dictionary.</a:documentation>
          <attribute name="name">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <ref name="region_ids"/>
          <ref name="input_choice_initial_condition_vector"/>
        </element>
      </choice>
    </oneOrMore>
    <zeroOrMore>
      <element name="boundary_conditions">
        <a:documentation>Boundary conditions</a:documentation>
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
        <element name="surface_ids">
          <a:documentation>Surface id:</a:documentation>
          <ref name="integer_vector"/>
        </element>
        <ref name="velocity_boundary_conditions"/>
      </element>
    </zeroOrMore>
    <optional>
      <element name="tensor_field">
        <a:documentation>For a Newtonian fluid this is the shear viscosity.

For continuous_galerkin see stress_terms to see how the
viscosity tensor is dealt with in the momentum equation.</a:documentation>
        <attribute name="name">
          <value>Viscosity</value>
        </attribute>
        <attribute name="rank">
          <value>2</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="prescribed_values_tensor_field"/>
          </element>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="diagnostic_tensor_field"/>
          </element>
        </choice>
      </element>
    </optional>
    <optional>
      <element name="vector_field">
        <a:documentation>Source</a:documentation>
        <attribute name="name">
          <value>Source</value>
        </attribute>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <optional>
              <ref name="mesh_choice"/>
            </optional>
            <ref name="prescribed_vector_field_no_adapt"/>
          </element>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="diagnostic_vector_field"/>
          </element>
        </choice>
        <optional>
          <element name="lump_source">
            <empty/>
          </element>
        </optional>
      </element>
    </optional>
    <optional>
      <element name="vector_field">
        <a:documentation>Absorption</a:documentation>
        <attribute name="name">
          <value>Absorption</value>
        </attribute>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="prescribed_vector_field_no_adapt"/>
          </element>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="diagnostic_vector_field"/>
          </element>
        </choice>
        <choice>
          <element name="default_absorption">
            <a:documentation>Default absorption: no lumping, is fully evaluated before the
the pressure correction.</a:documentation>
            <empty/>
          </element>
          <element name="lump_absorption">
            <a:documentation>Lump the inclusion of absorbtion terms.</a:documentation>
            <empty/>
          </element>
          <element name="include_pressure_correction">
            <a:documentation>Includes the pressure correction to the velocity in the
absorption term (for theta&gt;0). This makes the absorption
term more implicit. The absorption term is lumped if and
only if the mass matrix is lumped (lump_mass_matrix).</a:documentation>
            <empty/>
          </element>
        </choice>
      </element>
    </optional>
    <optional>
      <element name="tensor_field">
        <a:documentation>Elastic parameters for elastic and visco-elastic materials
For a linearly elastic solid
In legacy elastic solids were run with SOLIDS = 2 from solidity_options.inp.
In gem ONEMU and CONMU = .TRUE.
and RMUPZZ taken as the isotropic Young`s modulus
UNDER DEVELOPMENT
 - currently only works for lagrangian meshes
 - only single materials tested so far
 - momentum equations assembled in solid3d so not all
   discretisation options above are valid</a:documentation>
        <attribute name="name">
          <value>Elasticity</value>
        </attribute>
        <attribute name="rank">
          <value>2</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="prescribed_values_tensor_field"/>
          </element>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="diagnostic_tensor_field"/>
          </element>
        </choice>
      </element>
    </optional>
    <optional>
      <element name="tensor_field">
        <a:documentation>SurfaceTension</a:documentation>
        <attribute name="name">
          <value>SurfaceTension</value>
        </attribute>
        <attribute name="rank">
          <value>2</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <attribute name="field_name">
            <value>MaterialVolumeFraction</value>
          </attribute>
          <optional>
            <element name="lump_mass_matrix">
              <a:documentation>Choose whether the mass matrix is lumped or not for the calculation of the gradient</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="solver">
              <a:documentation>Solver options are necessary if you're not lumping your mass or if you're field isn't dg</a:documentation>
              <ref name="linear_solver_options_sym"/>
            </element>
          </optional>
          <optional>
            <element name="integrate_by_parts">
              <a:documentation>Choose whether the surface tension term in the momentum equation is integrated by parts or not</a:documentation>
              <empty/>
            </element>
          </optional>
          <ref name="diagnostic_tensor_field"/>
        </element>
      </element>
    </optional>
    <optional>
      <element name="scalar_field">
        <a:documentation>Cohesion for plastic materials
UNDER DEVELOPMENT
 - currently only works for lagrangian meshes
 - only single materials tested so far
 - momentum equations assembled in solid3d so not all
   discretisation options above are valid</a:documentation>
        <attribute name="name">
          <value>Cohesion</value>
        </attribute>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="prescribed_scalar_field_no_adapt"/>
          </element>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
        </choice>
      </element>
    </optional>
    <optional>
      <element name="scalar_field">
        <a:documentation>Friction Angle for plastic materials
UNDER DEVELOPMENT
 - currently only works for lagrangian meshes
 - only single materials tested so far
 - momentum equations assembled in solid3d so not all
   discretisation options above are valid</a:documentation>
        <attribute name="name">
          <value>FrictionAngle</value>
        </attribute>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="prescribed_scalar_field_no_adapt"/>
          </element>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
        </choice>
      </element>
    </optional>
    <ref name="prognostic_vector_output_options"/>
    <ref name="prognostic_vector_stat_options"/>
    <ref name="vector_convergence_options"/>
    <ref name="prognostic_detector_options"/>
    <ref name="vector_steady_state_options"/>
    <ref name="adaptivity_options_prognostic_vector_field"/>
    <ref name="interpolation_algorithm_vector"/>
    <optional>
      <ref name="discrete_properties_algorithm_vector"/>
    </optional>
  </define>
  <define name="prognostic_scalar_field">
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options_sym"/>
    </element>
    <choice>
      <element name="initial_condition">
        <a:documentation>Initial condition for WholeMesh

Only specify one condition if not using mesh regions.
Otherwise select other initial_condition option, specify region_ids
and distinct names.  Then add extra intial conditions for other regions.</a:documentation>
        <attribute name="name">
          <value>WholeMesh</value>
        </attribute>
        <ref name="input_choice_initial_condition_real"/>
      </element>
      <element name="initial_condition">
        <a:documentation>Multiple initial_conditions are allowed if specifying
different values in different
regions of the mesh (defined by region_ids).  In this case
each initial_condition
requires a distinct name for the options dictionary.</a:documentation>
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
        <ref name="region_ids"/>
        <ref name="input_choice_initial_condition_real"/>
      </element>
    </choice>
    <optional>
      <element name="tensor_field">
        <a:documentation>Diffusivity for field</a:documentation>
        <attribute name="name">
          <value>Diffusivity</value>
        </attribute>
        <attribute name="rank">
          <value>2</value>
        </attribute>
        <element name="prescribed">
          <optional>
            <ref name="mesh_choice"/>
          </optional>
          <ref name="prescribed_values_tensor_field"/>
        </element>
      </element>
    </optional>
    <ref name="prognostic_scalar_output_options"/>
    <ref name="prognostic_scalar_stat_options"/>
  </define>
  <!-- Default child of diagnostic scalar field -->
  <define name="diagnostic_scalar_field">
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_scalar_stat_options"/>
    <ref name="scalar_convergence_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="scalar_steady_state_options"/>
    <ref name="adaptivity_options_scalar_field"/>
    <optional>
      <ref name="recalculation_options"/>
    </optional>
  </define>
  <!-- Default child of diagnostic scalar field without adaptivity options -->
  <define name="diagnostic_scalar_field_no_adapt">
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_scalar_stat_options"/>
    <ref name="diagnostic_detector_options"/>
  </define>
  <!-- Default child of diagnostic scalar field -->
  <define name="diagnostic_scalar_field_tidal_range">
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_scalar_stat_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="adaptivity_options_scalar_field"/>
    <element name="spin_up_time">
      <ref name="real"/>
    </element>
  </define>
  <!--
    Default child of prescribed scalar field
    This is a choice of ways of inputing the prescribed field
  -->
  <define name="prescribed_scalar_field">
    <ref name="prescribed_scalar_field_no_adapt"/>
    <ref name="adaptivity_options_scalar_field"/>
    <optional>
      <ref name="interpolation_algorithm_scalar"/>
    </optional>
    <optional>
      <ref name="discrete_properties_algorithm_scalar"/>
    </optional>
    <optional>
      <ref name="recalculation_options"/>
    </optional>
  </define>
  <!--
    Default child of prescribed scalar field without adaptivity options
    This is a choice of ways of inputing the prescribed field
  -->
  <define name="prescribed_scalar_field_no_adapt">
    <ref name="prescribed_values_scalar_field"/>
    <ref name="prescribed_output_options"/>
    <ref name="prescribed_scalar_stat_options"/>
    <ref name="prescribed_detector_options"/>
  </define>
  <define name="prescribed_values_scalar_field">
    <oneOrMore>
      <choice>
        <element name="value">
          <a:documentation>Value for WholeMesh
Only specify one value if not using mesh regions.
Otherwise select other value option, specify region_ids
and distinct names.  Then add extra values for other regions.</a:documentation>
          <attribute name="name">
            <value>WholeMesh</value>
          </attribute>
          <ref name="input_choice_real_plus_file"/>
        </element>
        <element name="value">
          <a:documentation>Multiple values are now allowed if using different value assignments
in different regions of the mesh (specified by region_ids).
In this case each value requires a distinct name for the options dictionary.</a:documentation>
          <attribute name="name">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <ref name="region_ids"/>
          <ref name="input_choice_real_plus_file"/>
        </element>
      </choice>
    </oneOrMore>
  </define>
  <!--
    Default child of diagnostic vector field
    Currently, this is empty, but in future this might include
    options that are general to all diagnostic vector fields
  -->
  <define name="diagnostic_vector_field">
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_vector_stat_options"/>
    <ref name="vector_convergence_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="vector_steady_state_options"/>
    <ref name="adaptivity_options_vector_field"/>
    <optional>
      <ref name="recalculation_options"/>
    </optional>
  </define>
  <define name="diagnostic_vector_field_bed_shear_stress">
    <element name="density">
      <ref name="real"/>
    </element>
    <element name="drag_coefficient">
      <ref name="real"/>
    </element>
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_vector_stat_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="adaptivity_options_vector_field"/>
  </define>
  <!--
    Default child of prescribed vector field
    This is a choice of ways of inputing the prescribed field
  -->
  <define name="prescribed_vector_field">
    <ref name="prescribed_vector_field_no_adapt"/>
    <ref name="adaptivity_options_vector_field"/>
    <optional>
      <ref name="interpolation_algorithm_vector"/>
    </optional>
    <optional>
      <ref name="discrete_properties_algorithm_vector"/>
    </optional>
    <optional>
      <ref name="recalculation_options"/>
    </optional>
  </define>
  <!--
    Default child of prescribed vector field without adaptivity options
    This is a choice of ways of inputing the prescribed field
  -->
  <define name="prescribed_vector_field_no_adapt">
    <ref name="prescribed_values_vector_field"/>
    <ref name="prescribed_output_options"/>
    <ref name="prescribed_vector_stat_options"/>
    <ref name="prescribed_detector_options"/>
  </define>
  <define name="prescribed_values_vector_field">
    <oneOrMore>
      <choice>
        <element name="value">
          <a:documentation>Value for WholeMesh

Only specify one value if not using mesh regions.
Otherwise select other value option, specify region_ids
and distinct names.  Then add extra values for other regions.</a:documentation>
          <attribute name="name">
            <value>WholeMesh</value>
          </attribute>
          <ref name="input_choice_real_dim_vector_plus_file"/>
        </element>
        <element name="value">
          <a:documentation>Multiple values are now allowed if using different value assignments
in different regions of the mesh (specified by region_ids).
In this case each value requires a distinct name for the options dictionary.</a:documentation>
          <attribute name="name">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <ref name="region_ids"/>
          <ref name="input_choice_real_dim_vector_plus_file"/>
        </element>
      </choice>
    </oneOrMore>
  </define>
  <!--
    Default child of diagnostic tensor field
    Currently, this is empty, but in future this might include
    options that are general to all diagnostic tensor fields
  -->
  <define name="diagnostic_tensor_field">
    <ref name="diagnostic_output_options"/>
    <ref name="adaptivity_options_tensor_field"/>
  </define>
  <!--
    Default child of prescribed vector field
    This is a choice of ways of inputing the prescribed tensor field
    If the field is constant then a symmetric, or asymmetric tensor may be entered
  -->
  <define name="prescribed_tensor_field">
    <ref name="prescribed_values_tensor_field"/>
    <ref name="adaptivity_options_tensor_field"/>
  </define>
  <define name="prescribed_values_tensor_field">
    <oneOrMore>
      <choice>
        <element name="value">
          <a:documentation>Value for WholeMesh

Only specify one value if not using mesh regions.
Otherwise select other value option, specify region_ids
and distinct names.  Then add extra values for other regions.</a:documentation>
          <attribute name="name">
            <value>WholeMesh</value>
          </attribute>
          <ref name="input_choice_tensor_field"/>
        </element>
        <element name="value">
          <a:documentation>Multiple values are now allowed if using different value assignments
in different regions of the mesh (specified by region_ids).
In this case each value requires a distinct name for the options dictionary.</a:documentation>
          <attribute name="name">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <ref name="region_ids"/>
          <ref name="input_choice_tensor_field"/>
        </element>
      </choice>
    </oneOrMore>
  </define>
  <define name="prognostic_pressure_field">
    <element name="spatial_discretisation">
      <choice>
        <element name="continuous_galerkin">
          <optional>
            <element name="remove_stabilisation_term">
              <a:documentation>remove the  fourth order pressure stabilisation term KCMC
must be removed for multimaterial and free surface calculations</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="integrate_continuity_by_parts">
              <a:documentation>Integrate the continuity equation by parts.

This allows for the imposition of weak velocity boundary conditions with continuous_galerkin.
If activated this means that the pressure gradient operator is not integrated by parts.</a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
        <element name="control_volumes">
          <empty/>
        </element>
      </choice>
    </element>
    <optional>
      <element name="reference_node">
        <a:documentation>Reference node (Node at which pressure = 0.)

Must be less than the total number of nodes.
If parallel must be less than the total number of nodes of the first processor.

Note - it is also an option to remove the null-space of the residual vector. This
option is available under solvers.</a:documentation>
        <ref name="integer"/>
      </element>
    </optional>
    <optional>
      <element name="repair_stiff_nodes">
        <a:documentation>**UNDER DEVELOPMENT**
This searches the CMC matrix diagonal looking for nodes that are less than the maximum value time epsilon(0.0) (i.e. nodes that are effectively zero).
It then zeros that row and column and places a one on the diagonal and a zero on the rhs.
At a debug level of 2 it also prints out the value and the sum of the row values.
This is useful as a debugging tool if PETSc complains about zeros on the diagonal (i.e. if you have a stiff node in your mesh) but doesn't necessary produce nice answers at the end.</a:documentation>
        <empty/>
      </element>
    </optional>
    <optional>
      <element name="atmospheric_pressure">
        <a:documentation>Atmospheric pressure

Manual suggests 1.01325e+5 Pa</a:documentation>
        <ref name="real"/>
      </element>
    </optional>
    <element name="scheme">
      <a:documentation>scheme</a:documentation>
      <element name="poisson_pressure_solution">
        <a:documentation>Use a poisson pressure equation to calculate a first guess at pressure.
This does not necessarily satisfy continuity.
  = 1 -- use a poisson guess at every timestep
  = 0 -- never use a poisson guess
  =-1 -- use a poisson guess at the first timestep only
Manual suggests -1</a:documentation>
        <element name="string_value">
          <!--
            Lines is a hint to the gui about the size of the text box.
            It is not an enforced limit on string length.
          -->
          <attribute name="lines">
            <value>1</value>
          </attribute>
          <choice>
            <value>never</value>
            <value>every timestep</value>
            <value>only first timestep</value>
          </choice>
        </element>
        <ref name="comment"/>
      </element>
      <element name="use_projection_method">
        <a:documentation>Use the incompressible projection method to determine
the pressure and satisfy continuity</a:documentation>
        <optional>
          <element name="full_schur_complement">
            <a:documentation>Assemble and use the full schur complement.
This allows you to not lump the mass matrix if you're using
cg and to use the full momentum matrix in the projection if
you so desire.</a:documentation>
            <choice>
              <element name="inner_matrix">
                <a:documentation>Specify the inner matrix (IM) to form the projection schur complement (C^T*IM^{-1}*C).
Use the full mass matrix.

Make sure you've not lumped your mass in the velocity spatial_discretisation if you want to be consistent!</a:documentation>
                <attribute name="name">
                  <value>FullMassMatrix</value>
                </attribute>
                <element name="solver">
                  <ref name="linear_solver_options_sym"/>
                </element>
              </element>
              <element name="inner_matrix">
                <a:documentation>Specify the inner matrix (IM) to form the projection schur complement (C^T*IM^{-1}*C).
Use the full momentum matrix.

Doesn't really matter if you've lumped your mass or not but why would you if you're doing a full inner solve anyway?</a:documentation>
                <attribute name="name">
                  <value>FullMomentumMatrix</value>
                </attribute>
                <element name="solver">
                  <ref name="linear_solver_options_asym"/>
                </element>
              </element>
            </choice>
            <choice>
              <element name="preconditioner_matrix">
                <a:documentation>Specify the preconditioner matrix to use on the schur complement.

For DG, the LumpedSchurComplement is our best approximation to CMC.</a:documentation>
                <attribute name="name">
                  <value>LumpedSchurComplement</value>
                </attribute>
                <optional>
                  <element name="lump_on_submesh">
                    <empty/>
                  </element>
                </optional>
              </element>
              <element name="preconditioner_matrix">
                <a:documentation>Specify the preconditioner matrix to use on the schur complement.

DiagonalSchurComplement = C_P^T * [(Big_m)_diagonal]^-1 * C</a:documentation>
                <attribute name="name">
                  <value>DiagonalSchurComplement</value>
                </attribute>
                <empty/>
              </element>
              <element name="preconditioner_matrix">
                <a:documentation>Specify the preconditioner matrix to use on the schur complement.</a:documentation>
                <attribute name="name">
                  <value>NoPreconditionerMatrix</value>
                </attribute>
                <empty/>
              </element>
            </choice>
          </element>
        </optional>
      </element>
      <optional>
        <element name="update_discretised_equation">
          <a:documentation>rediscretise the equations at every timestep and iteration
(for instance if using a compressible formulation
or if density varies a lot or if not using a Boussinesque approximation)</a:documentation>
          <empty/>
        </element>
      </optional>
    </element>
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options_sym"/>
    </element>
    <zeroOrMore>
      <choice>
        <element name="initial_condition">
          <a:documentation>Initial condition for WholeMesh

Only specify one condition if not using mesh regions.
Otherwise select other initial_condition option, specify region_ids
and distinct names.  Then add extra intial conditions for other regions.</a:documentation>
          <attribute name="name">
            <value>WholeMesh</value>
          </attribute>
          <ref name="input_choice_initial_condition_real"/>
        </element>
        <element name="initial_condition">
          <a:documentation>Multiple initial_conditions are allowed if specifying
different values in different
regions of the mesh (defined by region_ids).  In this case
each initial_condition
requires a distinct name for the options dictionary.</a:documentation>
          <attribute name="name">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <ref name="region_ids"/>
          <ref name="input_choice_initial_condition_real"/>
        </element>
      </choice>
    </zeroOrMore>
    <zeroOrMore>
      <element name="boundary_conditions">
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
        <element name="surface_ids">
          <a:documentation>Surface id:</a:documentation>
          <ref name="integer_vector"/>
        </element>
        <element name="type">
          <a:documentation>Type</a:documentation>
          <attribute name="name">
            <value>dirichlet</value>
          </attribute>
          <optional>
            <element name="apply_weakly">
              <a:documentation>Apply the dirichlet bc weakly.  Available
automatically with discontinuous_galerkin,
control_volume, and legacy_mixed_cv_cg
spatial_discretisations.
If not selected boundary conditions are applied strongly.</a:documentation>
              <optional>
                <element name="boundary_overwrites_initial_condition">
                  <a:documentation>If the initial condition and boundary conditions
differ, setting this option will cause the initial
condition on the boundary to be overwritten with
the boundary condition. Since you are applying the
boundary condition weakly, you probably do *not*
want this.</a:documentation>
                  <empty/>
                </element>
              </optional>
            </element>
          </optional>
          <ref name="input_choice_real_plus_boundary_forcing"/>
        </element>
      </element>
    </zeroOrMore>
    <ref name="pressure_output_options"/>
    <ref name="prognostic_scalar_stat_options"/>
    <ref name="scalar_convergence_options"/>
    <ref name="detector_options_disabled_default"/>
    <ref name="scalar_steady_state_options"/>
    <ref name="adaptivity_options_prognostic_scalar_field"/>
    <ref name="interpolation_algorithm_scalar_full"/>
    <optional>
      <ref name="discrete_properties_algorithm_scalar"/>
    </optional>
  </define>
  <define name="prognostic_geostrophic_pressure_field">
    <element name="spatial_discretisation">
      <element name="geostrophic_pressure_option">
        <a:documentation>Select whether on not to include the buoyancy term "g" in the RHS:

  f = - grad p_gp + g</a:documentation>
        <element name="string_value">
          <choice>
            <value>include_buoyancy</value>
            <value>exclude_buoyancy</value>
          </choice>
        </element>
      </element>
    </element>
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options_sym"/>
    </element>
    <zeroOrMore>
      <choice>
        <element name="initial_condition">
          <a:documentation>Initial condition for WholeMesh

Only specify one condition if not using mesh regions.
Otherwise select other initial_condition option, specify region_ids
and distinct names.  Then add extra intial conditions for other regions.</a:documentation>
          <attribute name="name">
            <value>WholeMesh</value>
          </attribute>
          <ref name="input_choice_initial_condition_real"/>
        </element>
        <element name="initial_condition">
          <a:documentation>Multiple initial_conditions are allowed if specifying
different values in different
regions of the mesh (defined by region_ids).  In this case
each initial_condition
requires a distinct name for the options dictionary.</a:documentation>
          <attribute name="name">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <ref name="region_ids"/>
          <ref name="input_choice_initial_condition_real"/>
        </element>
      </choice>
    </zeroOrMore>
    <ref name="prognostic_scalar_output_options"/>
    <ref name="prognostic_scalar_stat_options"/>
    <ref name="prognostic_detector_options"/>
    <ref name="scalar_steady_state_options"/>
    <ref name="adaptivity_options_prognostic_scalar_field"/>
    <ref name="interpolation_algorithm_scalar_full"/>
    <optional>
      <ref name="discrete_properties_algorithm_scalar"/>
    </optional>
  </define>
  <!--
    Balance pressure field, this is a copy of prognostic_scalar_field above
    removing all options that don't apply (mainly advection related)
  -->
  <define name="prognostic_balance_pressure_field">
    <element name="spatial_discretisation">
      <a:documentation>Spatial discretisation options</a:documentation>
      <!--
        note I removed disott here as it
        will switch on free-surface options in geoeli1p
        should be hard-coded to 0 in comsca therefore
        tlump is irrelevant
        suftem should be hard-coded to .false. if nlevel is set
      -->
      <element name="geostrophic_pressure_option">
        <a:documentation>Geostrophic pressure option</a:documentation>
        <element name="string_value">
          <choice>
            <value>include_buoyancy</value>
            <value>exclude_buoyancy</value>
          </choice>
        </element>
      </element>
      <!--
        unfortunately tbeta doesn`t make sense here
        so we have to code an exception for not having it in comsca
      -->
    </element>
    <!--
      Temporal_discretisation doesn`t apply to balance pressure
      (there`s no time derivative). Exception again
      Solver block is the same as prognostic_scalar_field
    -->
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options_sym"/>
    </element>
    <!-- Alas, no initial_condition either, so we'd better not checkpointing it... -->
    <element name="exclude_from_checkpointing">
      <a:documentation>Disables checkpointing of this field</a:documentation>
      <ref name="comment"/>
    </element>
    <!--
      There are boundary conditions, but nothing you can set
      (all derived from velocity b.c.s)
      no Diffusivity tensor_field
      no Source scalar_field
      no Absorption scalar_field
      no adaptive time-stepping
    -->
    <ref name="prognostic_scalar_output_options"/>
    <ref name="prognostic_scalar_stat_options"/>
    <ref name="scalar_convergence_options"/>
    <ref name="prognostic_detector_options"/>
    <ref name="scalar_steady_state_options"/>
    <ref name="adaptivity_options_prognostic_scalar_field"/>
    <ref name="interpolation_algorithm_scalar_full"/>
    <optional>
      <ref name="discrete_properties_algorithm_scalar"/>
    </optional>
  </define>
  <!--
    Vertical balance pressure field, this is a copy of prognostic_scalar_field above
    removing all options that don't apply (mainly advection related)
  -->
  <define name="prognostic_vertical_balance_pressure_field">
    <element name="spatial_discretisation">
      <a:documentation>Spatial discretisation options</a:documentation>
      <!-- we don't have any yet -->
      <empty/>
    </element>
    <!--
      Temporal_discretisation doesn`t apply to balance pressure
      (there`s no time derivative). Exception again
      no solver block as we don't do a PETSc solve
      Alas, no initial_condition either...
      boundary conditions are fixed (p=0 on top)
      no Diffusivity tensor_field
      no Source scalar_field
      no Absorption scalar_field
      no adaptive time-stepping
    -->
    <ref name="prognostic_scalar_output_options"/>
    <ref name="prognostic_scalar_stat_options"/>
    <ref name="scalar_convergence_options"/>
    <ref name="prognostic_detector_options"/>
    <ref name="scalar_steady_state_options"/>
    <ref name="adaptivity_options_prognostic_scalar_field"/>
    <ref name="interpolation_algorithm_scalar"/>
    <optional>
      <ref name="discrete_properties_algorithm_scalar"/>
    </optional>
  </define>
  <!--
    stream function, this is a copy of prognostic_scalar_field above
    removing all options that don't apply (mainly advection related)
  -->
  <define name="prognostic_stream_function_field">
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options_asym"/>
    </element>
    <element name="exclude_from_checkpointing">
      <a:documentation>Disables checkpointing of this field</a:documentation>
      <ref name="comment"/>
    </element>
    <!--
      no Diffusivity for field
      no source term
      no Absorption term
      no Adaptive timestepping option
    -->
    <ref name="prognostic_scalar_output_options"/>
    <ref name="prognostic_scalar_stat_options"/>
    <ref name="prognostic_detector_options"/>
    <ref name="adaptivity_options_prognostic_scalar_field"/>
    <ref name="interpolation_algorithm_scalar"/>
    <optional>
      <ref name="discrete_properties_algorithm_scalar"/>
    </optional>
  </define>
  <!--
    Richardson number field. This is a normal diagnostic scalar field, but with
    Richardson number metric options added
  -->
  <define name="adaptivity_options_richardson_number_field.adaptivity_options">
    <element name="no_interpolation_measure">
      <a:documentation>Do not use an interpolation error driven metric for this field</a:documentation>
      <ref name="comment"/>
    </element>
  </define>
  <define name="adaptivity_options_richardson_number_field.adaptivity_options" combine="choice">
    <ref name="adaptivity_options_scalar_field.adaptivity_options"/>
  </define>
  <define name="adaptivity_options_richardson_number_field">
    <optional>
      <element name="adaptivity_options">
        <ref name="adaptivity_options_richardson_number_field.adaptivity_options"/>
        <optional>
          <element name="richardson_number_metric">
            <a:documentation>An isotropic metric formulation based on the Richardson number. Uses
the logic that wherever the Richardson number is small, we expect
to need resolution. Generates edge lengths using:

  Edge length = min_edge_length if Ri &lt;= min_ri
                max_edge_length if Ri &gt;= max_ri
                a linear fit between min_edge_length and max_edge_length otherwise</a:documentation>
            <optional>
              <element name="min_ri">
                <a:documentation>Richardson number at which we have minimum edge length (default 0.0)</a:documentation>
                <ref name="real"/>
              </element>
            </optional>
            <element name="max_ri">
              <a:documentation>Richardson number at which we have maximum edge length</a:documentation>
              <ref name="real"/>
            </element>
            <element name="min_edge_length">
              <a:documentation>Minimum edge length that can be requested by the Richardson number
metric</a:documentation>
              <ref name="real"/>
            </element>
            <element name="max_edge_length">
              <a:documentation>Maximum edge length that can be requested by the Richardson number
metric</a:documentation>
              <ref name="real"/>
            </element>
            <optional>
              <element name="anisotropy_preserving_merge">
                <a:documentation>Enable to preserve anisotropy when merging with other metric
formulations</a:documentation>
                <ref name="comment"/>
              </element>
            </optional>
            <ref name="comment"/>
          </element>
        </optional>
        <ref name="adaptivity_preprocessing"/>
      </element>
    </optional>
  </define>
  <define name="diagnostic_richardson_number_field">
    <ref name="diagnostic_scalar_field_no_adapt"/>
  </define>
  <define name="diagnostic_richardson_number_field" combine="interleave">
    <ref name="adaptivity_options_richardson_number_field"/>
  </define>
  <define name="diagnostic_cv_gradient_vector_field">
    <optional>
      <element name="lump_mass_matrix">
        <a:documentation>Choose whether the mass matrix is lumped or not</a:documentation>
        <empty/>
      </element>
    </optional>
    <optional>
      <element name="solver">
        <a:documentation>Solver options are necessary if you're not lumping your mass or if you're field isn't dg</a:documentation>
        <ref name="linear_solver_options_sym"/>
      </element>
    </optional>
    <optional>
      <element name="normalise">
        <a:documentation>Normalise the gradient by its magnitude</a:documentation>
        <empty/>
      </element>
    </optional>
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_vector_stat_options"/>
    <ref name="vector_convergence_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="vector_steady_state_options"/>
    <ref name="adaptivity_options_vector_field"/>
    <optional>
      <ref name="recalculation_options"/>
    </optional>
  </define>
  <define name="diagnostic_gradient_vector_field">
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options_sym"/>
    </element>
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_vector_stat_options"/>
    <ref name="vector_convergence_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="vector_steady_state_options"/>
    <ref name="adaptivity_options_vector_field"/>
    <optional>
      <ref name="recalculation_options"/>
    </optional>
  </define>
  <define name="diagnostic_cv_divergence_scalar_field">
    <!-- No solver options because it can be solved directly! -->
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_scalar_stat_options"/>
    <ref name="scalar_convergence_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="scalar_steady_state_options"/>
    <ref name="adaptivity_options_scalar_field"/>
    <optional>
      <ref name="recalculation_options"/>
    </optional>
  </define>
  <define name="diagnostic_fe_divergence_scalar_field">
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options_sym"/>
    </element>
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_scalar_stat_options"/>
    <ref name="scalar_convergence_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="scalar_steady_state_options"/>
    <ref name="adaptivity_options_scalar_field"/>
    <optional>
      <ref name="recalculation_options"/>
    </optional>
  </define>
  <!-- three optional input vectors for user-specified rotation matrix -->
  <define name="rotation_matrix_components">
    <optional>
      <element name="normal_direction">
        <a:documentation>Select if you want to specify the normal direction
of the rotation matrix.
If off then fluidity computes the normal
If on the tangents vectors must also be specified.</a:documentation>
        <ref name="input_choice_real_dim_vector"/>
      </element>
    </optional>
    <optional>
      <element name="tangent_direction_1">
        <a:documentation>specify first unit tangent vector to boundary</a:documentation>
        <ref name="input_choice_real_dim_vector"/>
      </element>
    </optional>
    <optional>
      <element name="tangent_direction_2">
        <a:documentation>specify second (if exists, i.e. if 3d) unit tangent vector to boundary</a:documentation>
        <ref name="input_choice_real_dim_vector"/>
      </element>
    </optional>
  </define>
  <define name="velocity_components_choice">
    <!--
      rotated bcs are not implemented... this is where they should go when they are
              element align_bc_with_surface {
                 element normal_component {
                    input_choice_real
                 }?,
                 element tangent_component_1 {
                    input_choice_real
                 }?,
                 element tangent_component_2 {
                    input_choice_real
                 }?,
                 rotation_matrix_components
              }|
    -->
    <element name="align_bc_with_cartesian">
      <optional>
        <element name="x_component">
          <ref name="input_choice_real_bc_component"/>
        </element>
      </optional>
      <optional>
        <element name="y_component">
          <ref name="input_choice_real_bc_component"/>
        </element>
      </optional>
      <optional>
        <element name="z_component">
          <ref name="input_choice_real_bc_component"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="input_choice_real_bc_component">
    <choice>
      <ref name="input_choice_real"/>
      <element name="synthetic_eddy_method">
        <element name="number_of_eddies">
          <a:documentation>use a large number to ensure Gaussian
behaviour of the fluctuating component</a:documentation>
          <ref name="integer"/>
        </element>
        <element name="turbulence_lengthscale">
          <ref name="input_choice_real"/>
        </element>
        <element name="mean_profile">
          <a:documentation>mean profile

usually a function of height,
for ABL simulations use a log profile</a:documentation>
          <ref name="input_choice_real"/>
        </element>
        <element name="Re_stresses_profile">
          <a:documentation>Reynolds stresses profile

usually a function of height,
assumes that the remaining stresses are negligible </a:documentation>
          <ref name="input_choice_real"/>
        </element>
      </element>
    </choice>
  </define>
  <!-- and again for robin b.c.s -->
  <define name="robin_velocity_components_choice">
    <!--
              element align_bc_with_surface {
                 element normal_component {
                    element order_zero_coefficient {
                       input_choice_real
                    },
                    element order_one_coefficient {
                       input_choice_real
                    }
                 }?,
                 element tangent_component_1 {
                    element order_zero_coefficient {
                       input_choice_real
                    },
                    element order_one_coefficient {
                       input_choice_real
                    }
                 }?,
                 element tangent_component_2 {
                    element order_zero_coefficient {
                       input_choice_real
                    },
                    element order_one_coefficient {
                       input_choice_real
                    }
                 }?,
                 rotation_matrix_components
              }|
    -->
    <element name="align_bc_with_cartesian">
      <optional>
        <element name="x_component">
          <element name="order_zero_coefficient">
            <ref name="input_choice_real"/>
          </element>
          <element name="order_one_coefficient">
            <ref name="input_choice_real"/>
          </element>
        </element>
      </optional>
      <optional>
        <element name="y_component">
          <element name="order_zero_coefficient">
            <ref name="input_choice_real"/>
          </element>
          <element name="order_one_coefficient">
            <ref name="input_choice_real"/>
          </element>
        </element>
      </optional>
      <optional>
        <element name="z_component">
          <element name="order_zero_coefficient">
            <ref name="input_choice_real"/>
          </element>
          <element name="order_one_coefficient">
            <ref name="input_choice_real"/>
          </element>
        </element>
      </optional>
    </element>
  </define>
  <define name="velocity_boundary_conditions">
    <choice>
      <element name="type">
        <attribute name="name">
          <value>dirichlet</value>
        </attribute>
        <optional>
          <element name="apply_weakly">
            <a:documentation>Apply the dirichlet bc weakly.  Available automatically
with a discontinuous_galerkin Velocity
spatial_discretisation.  Available if you
integrate_continuity_by_parts with a
continuous_galerkin Pressure or use a control_volume
Pressure spatial_discretisation and/or
integrate_advection_by_parts under Velocity
spatial_discretisation with continuous_galerkin.

If not selected boundary conditions are applied strongly.</a:documentation>
            <optional>
              <element name="boundary_overwrites_initial_condition">
                <a:documentation>If the initial condition and boundary conditions
differ, setting this option will cause the initial
condition on the boundary to be overwritten with
the boundary condition. Since you are applying the
boundary condition weakly, you probably do *not*
want this.</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
        </optional>
        <ref name="velocity_components_choice"/>
      </element>
      <element name="type">
        <attribute name="name">
          <value>neumann</value>
        </attribute>
        <ref name="velocity_components_choice"/>
      </element>
      <element name="type">
        <attribute name="name">
          <value>robin</value>
        </attribute>
        <ref name="robin_velocity_components_choice"/>
      </element>
      <element name="type">
        <attribute name="name">
          <value>free_surface</value>
        </attribute>
      </element>
      <element name="type">
        <a:documentation>Apply quadratic drag. Specify drag coefficient. If you
want to exactly replicate results from using the OCEDRA
option, set this to 0.003 and remember to apply to both
bottom and sides.</a:documentation>
        <attribute name="name">
          <value>drag</value>
        </attribute>
        <ref name="input_choice_real"/>
        <choice>
          <element name="quadratic_drag">
            <a:documentation>Use a quadratic drag.

This means that the drag coefficient is nondimensional.</a:documentation>
            <empty/>
          </element>
          <element name="linear_drag">
            <a:documentation>Use a linear drag (basically just a surface absorption term).

This means that the drag coefficient has units of momentum.</a:documentation>
            <empty/>
          </element>
        </choice>
      </element>
      <element name="type">
        <a:documentation>Apply wind forcing specified by stress or wind velocity.
Replaces windy.dat and windy.py</a:documentation>
        <attribute name="name">
          <value>wind_forcing</value>
        </attribute>
        <choice>
          <element name="wind_stress">
            <a:documentation>Wind forcing with user specified wind stress

&lt;b&gt; Note that the stress needs to be specified
using the same density units as the reference_density
under equation of state.&lt;/b&gt;So if you use the recommended
non-dimensional value of 1.0 for reference_density and
your calculated stress is in kg m^-1s^-2 and the dimensional
reference_density is 1000.0 kg m^-3, you need to divide
the calculated stress in SI units by 1000.0.</a:documentation>
            <choice>
              <ref name="input_choice_real_dim_minus_one_vector"/>
              <element name="from_netcdf">
                <attribute name="file_name">
                  <a:documentation>The format of this file should conform to NetCDF CF 1.x
(http://cf-pcmdi.llnl.gov/).</a:documentation>
                  <data type="string"/>
                </attribute>
                <attribute name="east_west">
                  <data type="string"/>
                </attribute>
                <attribute name="north_south">
                  <data type="string"/>
                </attribute>
                <ref name="comment"/>
              </element>
            </choice>
          </element>
          <element name="wind_velocity">
            <a:documentation>Wind forcing with user specified 10m wind velocity</a:documentation>
            <element name="wind_drag_coefficient">
              <a:documentation>Specify wind drag coefficient (dimensionless)
Suggested value: 4.0e-4</a:documentation>
              <ref name="input_choice_real"/>
            </element>
            <element name="density_air">
              <a:documentation>Density of air.

&lt;b&gt;Note that you have to specify
this density in the same units as the
reference_density under equation of state.&lt;/b&gt;
So with a typicial value of rho_air=1.3 kgm^-3
and rho_water=1000 kgm^-3, if you fill in the
recommended (non-dimensional) value of 1.0 for
reference_density, this field needs to be 1.3e-3.</a:documentation>
              <ref name="real"/>
            </element>
            <element name="wind_velocity">
              <a:documentation>Specify wind velocity</a:documentation>
              <choice>
                <ref name="input_choice_real_dim_minus_one_vector"/>
                <element name="from_netcdf">
                  <attribute name="file_name">
                    <a:documentation>The format of this file should conform to NetCDF CF 1.x
(http://cf-pcmdi.llnl.gov/)</a:documentation>
                    <data type="string"/>
                  </attribute>
                  <attribute name="east_west">
                    <data type="string"/>
                  </attribute>
                  <attribute name="north_south">
                    <data type="string"/>
                  </attribute>
                  <ref name="comment"/>
                </element>
              </choice>
            </element>
          </element>
        </choice>
      </element>
      <element name="type">
        <a:documentation>When using control_volumes under Pressure
spatial_discretisation or when using
integrate_continuity_by_parts with continuous_galerkin
Pressure and continuous_galerkin Velocity this
boundary condition type imposes a weak no normal flow
boundary condition on the surface_ids specified.</a:documentation>
        <attribute name="name">
          <value>no_normal_flow</value>
        </attribute>
        <empty/>
      </element>
    </choice>
  </define>
  <!-- Output options for prognostic fields -->
  <define name="prognostic_scalar_output_options">
    <element name="output">
      <a:documentation>Specify what is written to vtu dump files</a:documentation>
      <optional>
        <element name="exclude_from_vtu">
          <a:documentation>By default each field in the options file is written to vtu.
Select this option to exclude this field.</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="include_previous_time_step">
          <a:documentation>Select this option to also write the values of this field
on the previous timestep.
(included under the name: Old&lt;field_name&gt; )</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="include_nonlinear_field">
          <a:documentation>Select this option to also write the values of this field
used in the nonlinear iteration.
(included under the name: Nonlinear&lt;field_name&gt; )</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="convergence_file">
          <a:documentation>Output a file details the convergence (or otherwise) of
this field with every advective nonlinear
iteration.
ONLY WORKS FOR PURE CONTROL VOLUME DISCRETISATIONS.</a:documentation>
          <ref name="comment"/>
        </element>
      </optional>
    </element>
  </define>
  <!-- Output options for pressure (can't have a convergence file) -->
  <define name="pressure_output_options">
    <element name="output">
      <a:documentation>Specify what is written to vtu dump files</a:documentation>
      <optional>
        <element name="exclude_from_vtu">
          <a:documentation>By default each field in the options file is written to vtu.
Select this option to exclude this field.</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="include_previous_time_step">
          <a:documentation>Select this option to also write the values of this field
on the previous timestep.
(included under the name: Old&lt;field_name&gt; )</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="include_nonlinear_field">
          <a:documentation>Select this option to also write the values of this field
used in the nonlinear iteration.
(included under the name: Nonlinear&lt;field_name&gt; )</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="debugging_vtus">
          <a:documentation>Write out some extra debugging vtu files that can be used
to analyse what goes on in the pressure projection steps.
WARNING: this may create a huge amount of vtu files, as
multiple files are written per nonlinear iteration.</a:documentation>
          <empty/>
        </element>
      </optional>
    </element>
  </define>
  <!-- Output options for prognostic fields -->
  <define name="prognostic_vector_output_options">
    <element name="output">
      <a:documentation>Specify what is written to vtu dump files</a:documentation>
      <optional>
        <element name="exclude_from_vtu">
          <a:documentation>By default each field in the options file is written to vtu.
Select this option to exclude this field.</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="include_previous_time_step">
          <a:documentation>Select this option to also write the values of this field
on the previous timestep.
(included under the name: Old&lt;field_name&gt; )</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="include_nonlinear_field">
          <a:documentation>Select this option to also write the values of this field
used in the nonlinear iteration.
(included under the name: Nonlinear&lt;field_name&gt; )</a:documentation>
          <empty/>
        </element>
      </optional>
    </element>
  </define>
  <!-- Output options for all other fields -->
  <define name="field_output_options">
    <element name="output">
      <a:documentation>Specify what is written to vtu dump files</a:documentation>
      <optional>
        <element name="exclude_from_vtu">
          <a:documentation>By default each field in the options file is written to vtu.
Select this option to exclude this field.</a:documentation>
          <empty/>
        </element>
      </optional>
    </element>
  </define>
  <define name="diagnostic_output_options">
    <ref name="field_output_options"/>
  </define>
  <define name="prescribed_output_options">
    <ref name="field_output_options"/>
  </define>
  <!--
    Options for inclusion/exclusion of standard field statistics from the .stat
    file
  -->
  <define name="include_stat">
    <element name="include_in_stat">
      <a:documentation>Include this field in the .stat file (magnitude and components)</a:documentation>
      <ref name="comment"/>
    </element>
  </define>
  <define name="exclude_components_from_stat">
    <element name="exclude_components_from_stat">
      <a:documentation>Include just the magnitude of this field in the .stat file
(excluding the components)</a:documentation>
      <ref name="comment"/>
    </element>
  </define>
  <define name="exclude_stat">
    <element name="exclude_from_stat">
      <a:documentation>Exclude this field from the .stat file.</a:documentation>
      <ref name="comment"/>
    </element>
  </define>
  <!-- Diagnostic statistics options for prognostic scalar fields -->
  <define name="prognostic_scalar_stat_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <ref name="prognostic_scalar_stat_options.stat"/>
    </element>
  </define>
  <!-- Diagnostic statistics for all other scalar fields -->
  <define name="prognostic_scalar_stat_no_old_or_nonlinear_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <ref name="prognostic_scalar_stat_no_old_or_nonlinear_options.stat"/>
    </element>
  </define>
  <define name="diagnostic_scalar_stat_options">
    <ref name="prognostic_scalar_stat_no_old_or_nonlinear_options"/>
  </define>
  <define name="prescribed_scalar_stat_options">
    <ref name="prognostic_scalar_stat_no_old_or_nonlinear_options"/>
  </define>
  <!-- Combining of stat elements for scalar fields -->
  <define name="prognostic_scalar_stat_options.stat">
    <ref name="prognostic_scalar_stat_no_old_or_nonlinear_options.stat"/>
  </define>
  <define name="prognostic_scalar_stat_options.stat" combine="interleave">
    <optional>
      <element name="include_previous_time_step">
        <a:documentation>Enable to include the previous timestep value of this field in the .stat file.</a:documentation>
        <ref name="comment"/>
      </element>
    </optional>
    <optional>
      <element name="include_nonlinear_field">
        <a:documentation>Enable to include the values of this field in the nonlinear
iteration in the .stat file.</a:documentation>
        <ref name="comment"/>
      </element>
    </optional>
  </define>
  <define name="prognostic_scalar_stat_no_old_or_nonlinear_options.stat">
    <optional>
      <ref name="exclude_stat"/>
    </optional>
    <optional>
      <ref name="cv_stats"/>
    </optional>
    <zeroOrMore>
      <ref name="surface_integral_stats_scalar"/>
    </zeroOrMore>
    <zeroOrMore>
      <ref name="mixing_stats"/>
    </zeroOrMore>
  </define>
  <!-- Diagnostic statistics options for vector fields, with enabled by default -->
  <define name="vector_field_stat_options_enabled_default">
    <ref name="include_stat"/>
  </define>
  <define name="vector_field_stat_options_enabled_default" combine="choice">
    <ref name="exclude_components_from_stat"/>
  </define>
  <define name="vector_field_stat_options_enabled_default" combine="choice">
    <ref name="exclude_stat"/>
  </define>
  <!-- Diagnostic statistics options for vector fields, with enabled by default -->
  <define name="vector_field_stat_options_disabled_default">
    <ref name="exclude_stat"/>
  </define>
  <define name="vector_field_stat_options_disabled_default" combine="choice">
    <ref name="exclude_components_from_stat"/>
  </define>
  <define name="vector_field_stat_options_disabled_default" combine="choice">
    <ref name="include_stat"/>
  </define>
  <!-- Diagnostic statistics for prognostic vector fields -->
  <define name="prognostic_vector_stat_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <ref name="prognostic_vector_stat_options.stat"/>
    </element>
  </define>
  <!-- Diagnostic statistics for all other vector fields -->
  <define name="prognostic_vector_stat_no_old_or_nonlinear_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <ref name="prognostic_vector_stat_no_old_or_nonlinear_options.stat"/>
    </element>
  </define>
  <define name="diagnostic_vector_stat_options">
    <ref name="prognostic_vector_stat_no_old_or_nonlinear_options"/>
  </define>
  <define name="prescribed_vector_stat_options">
    <ref name="prognostic_vector_stat_no_old_or_nonlinear_options"/>
  </define>
  <!-- Combining of stat elements for vector fields -->
  <define name="prognostic_vector_stat_options.stat">
    <ref name="prognostic_vector_stat_no_old_or_nonlinear_options.stat"/>
  </define>
  <define name="prognostic_vector_stat_options.stat" combine="interleave">
    <element name="previous_time_step">
      <a:documentation>Specify how the previous timestep value of this field is added to the .stat file.</a:documentation>
      <ref name="vector_field_stat_options_disabled_default"/>
    </element>
    <element name="nonlinear_field">
      <a:documentation>Specify how the values of this field used in the nonlinear iteration are added to the .stat file.</a:documentation>
      <ref name="vector_field_stat_options_disabled_default"/>
    </element>
    <optional>
      <element name="compute_body_forces_on_surfaces">
        <a:documentation>What surface IDs do you want to do the calculation over?</a:documentation>
        <ref name="integer_vector"/>
      </element>
    </optional>
  </define>
  <define name="prognostic_vector_stat_no_old_or_nonlinear_options.stat">
    <ref name="vector_field_stat_options_enabled_default"/>
    <zeroOrMore>
      <ref name="surface_integral_stats_vector"/>
    </zeroOrMore>
  </define>
  <!-- Convergence options for prognostic scalar fields -->
  <define name="scalar_convergence_options">
    <element name="convergence">
      <a:documentation>Decide whether this field is tested for convergence
during nonlinear iterations
(if /timestepping/nonlinear_iterations and
/timestepping/nonlinear_iterations/tolerance are
enabled).
Also specifies whether the field is added to the
convergence file (if /io/convergence_file is enabled).</a:documentation>
      <choice>
        <element name="include_in_convergence">
          <a:documentation>Include this field in convergence testing
(if /timestepping/nonlinear_iterations and
/timestepping/nonlinear_iterations/tolerance are
enabled) and file (if /io/convergence_file is enabled)</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_from_convergence">
          <a:documentation>Exclude this field from convergence testing and file </a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!-- Convergence statistics options for prognostic vector fields (velocity) -->
  <define name="vector_convergence_options">
    <element name="convergence">
      <a:documentation>Decide whether this field is tested for convergence
during nonlinear iterations
(if /timestepping/nonlinear_iterations and
/timestepping/nonlinear_iterations/tolerance are
enabled).
Also specifies whether the field is added to the
convergence file (if /io/convergence_file is enabled).</a:documentation>
      <choice>
        <element name="include_in_convergence">
          <a:documentation>Include this field (magnitude and components)
in convergence testing
(if /timestepping/nonlinear_iterations and
/timestepping/nonlinear_iterations/tolerance are
enabled) and file (if /io/convergence_file is enabled)</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_components_from_convergence">
          <a:documentation>Include just the magnitude of this field
in convergence testing
(if /timestepping/nonlinear_iterations and
/timestepping/nonlinear_iterations/tolerance are
enabled) and file (if /io/convergence_file is enabled)
i.e. excluding the components</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_from_convergence">
          <a:documentation>Exclude this field entirely from convergence testing and file </a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!-- Steady state options for prognostic scalar fields -->
  <define name="scalar_steady_state_options">
    <element name="steady_state">
      <a:documentation>Decide whether this field is tested for a steady state
between timesteps
(if /timestepping/steady_state is
enabled).</a:documentation>
      <choice>
        <element name="include_in_steady_state">
          <a:documentation>Include this field in steady state testing
(if /timestepping/steady_state is
enabled)</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_from_steady_state">
          <a:documentation>Exclude this field from steady state testing</a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!-- Steady state statistics options for prognostic vector fields (velocity) -->
  <define name="vector_steady_state_options">
    <element name="steady_state">
      <a:documentation>Decide whether this field is tested for a steady state
between timesteps
(if /timestepping/steady_state is
enabled).</a:documentation>
      <choice>
        <element name="include_in_steady_state">
          <a:documentation>Include this field (magnitude and components)
in steady state testing
(if /timestepping/steady_state is enabled)</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_components_from_steady_state">
          <a:documentation>Include just the magnitude of this field
in steady state testing
(if /timestepping/steady_state is
enabled)
i.e. excluding the components</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_from_steady_state">
          <a:documentation>Exclude this field entirely from convergence testing and file </a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!-- Options for whether a field is to be included in detector output. -->
  <define name="detector_options_enabled_default">
    <element name="detectors">
      <a:documentation>Specify what is added to detector files</a:documentation>
      <choice>
        <element name="include_in_detectors">
          <a:documentation>This field is output at each detector location.</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_from_detectors">
          <a:documentation>This field is not output at detector locations.</a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!-- Options for whether a field is to be included in detector output. -->
  <define name="detector_options_disabled_default">
    <element name="detectors">
      <a:documentation>Specify what is added to detector files</a:documentation>
      <choice>
        <element name="exclude_from_detectors">
          <a:documentation>This field is not output at detector locations.</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="include_in_detectors">
          <a:documentation>This field is output at each detector location.</a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!--
    Detector output defaults on for prognostic and diagnostic fields,
    off for prescribed.
  -->
  <define name="prognostic_detector_options">
    <ref name="detector_options_enabled_default"/>
  </define>
  <define name="diagnostic_detector_options">
    <ref name="detector_options_enabled_default"/>
  </define>
  <define name="prescribed_detector_options">
    <ref name="detector_options_disabled_default"/>
  </define>
  <define name="adaptivity_preprocessing">
    <optional>
      <element name="preprocessing">
        <a:documentation>Occasionally, it is desirable to apply operations or filters
to fields before using them for the purposes of adaptivity.</a:documentation>
        <element name="helmholtz_smoother">
          <a:documentation>Invert a helmholtz operator to smooth out the field
before using it to adapt. This can help with noisy
fields.</a:documentation>
          <element name="smoothing_length_scale">
            <ref name="real_dim_symmetric_tensor"/>
          </element>
          <element name="solver">
            <ref name="linear_solver_options_sym"/>
          </element>
        </element>
      </element>
    </optional>
  </define>
  <define name="adaptivity_options_prognostic_scalar_field">
    <optional>
      <element name="adaptivity_options">
        <choice>
          <element name="absolute_measure">
            <a:documentation>When specifying absolute measure
one specifies the absolute interpolation
error in the units of the field that is
being adapted, e.g. you can specify
the error to be 1.3 units </a:documentation>
            <element name="scalar_field">
              <attribute name="rank">
                <value>0</value>
              </attribute>
              <attribute name="name">
                <value>InterpolationErrorBound</value>
              </attribute>
              <element name="prescribed">
                <ref name="prescribed_scalar_field_no_adapt"/>
              </element>
            </element>
          </element>
          <element name="relative_measure">
            <a:documentation>When specifying relative measure
one specifies the interpolation error
relative to the field that is
being adapted, e.g. you can specify
the error to be 5% (i.e. 0.05)</a:documentation>
            <element name="scalar_field">
              <attribute name="rank">
                <value>0</value>
              </attribute>
              <attribute name="name">
                <value>InterpolationErrorBound</value>
              </attribute>
              <element name="prescribed">
                <ref name="prescribed_scalar_field_no_adapt"/>
              </element>
            </element>
            <element name="tolerance">
              <a:documentation>The relative Hessian is calculated according to:

  Q = H / max{ |psi|, psi_min}

where H is the Hessian, psi is the field value and
psi_min is the tolerance. The tolerance prevents
division by zero errors.

Source: Fluidity/ICOM manual draft version 1.2</a:documentation>
              <ref name="real"/>
            </element>
          </element>
          <element name="anisotropic_zienkiewicz_zhu">
            <a:documentation>Adapt using the anisotropic strategy of
Formaggia, Perotto, Micheletti.
Rather than taking two derivatives
and deriving the anisotropic information,
this approach computes an anisotropic Zienkiewicz-Zhu
error estimator for each element. The approach then
optimises the element orientation and length scales
to equidistribute the estimated error.</a:documentation>
            <element name="tau">
              <a:documentation>Tau is an anisotropic estimate for the H1 seminorm of the
error. This estimator is efficient and reliable, under the
caveat that the initial mesh is sufficiently fine so as to
prevent data oscillation. (Micheletti &amp; Perotto, 2006)
Typically, tau will be ~= 6-8 * |e|_H1.</a:documentation>
              <ref name="real"/>
            </element>
          </element>
        </choice>
        <ref name="adaptivity_preprocessing"/>
      </element>
    </optional>
  </define>
  <define name="adaptivity_options_scalar_field.adaptivity_options">
    <choice>
      <element name="absolute_measure">
        <a:documentation>When specifying absolute measure
one specifies the absolute interpolation
error in the units of the field that is
being adapted, e.g. you can specify
the error to be 1.3 units </a:documentation>
        <element name="scalar_field">
          <attribute name="rank">
            <value>0</value>
          </attribute>
          <attribute name="name">
            <value>InterpolationErrorBound</value>
          </attribute>
          <element name="prescribed">
            <ref name="prescribed_scalar_field_no_adapt"/>
          </element>
        </element>
      </element>
      <element name="relative_measure">
        <a:documentation>When specifying relative measure
one specifies the interpolation error
relative to the field that is
being adapted, e.g. you can specify
the error to be 5% (i.e. 0.05)</a:documentation>
        <element name="scalar_field">
          <attribute name="rank">
            <value>0</value>
          </attribute>
          <attribute name="name">
            <value>InterpolationErrorBound</value>
          </attribute>
          <element name="prescribed">
            <ref name="prescribed_scalar_field_no_adapt"/>
          </element>
        </element>
        <element name="tolerance">
          <a:documentation>The relative Hessian is calculated according to:

  Q = H / max{ |psi|, psi_min}

where H is the Hessian, psi is the field value and
psi_min is the tolerance. The tolerance prevents
division by zero errors.

Source: Fluidity/ICOM manual draft version 1.2</a:documentation>
          <ref name="real"/>
        </element>
      </element>
      <element name="anisotropic_zienkiewicz_zhu">
        <a:documentation>Adapt using the anisotropic strategy of
Formaggia, Perotto, Micheletti.
Rather than taking two derivatives
and deriving the anisotropic information,
this approach computes an anisotropic Zienkiewicz-Zhu
error estimator for each element. The approach then
optimises the element orientation and length scales
to equidistribute the estimated error.</a:documentation>
        <element name="tau">
          <a:documentation>Tau is an anisotropic estimate for the H1 seminorm of the
error. This estimator is efficient and reliable, under the
caveat that the initial mesh is sufficiently fine so as to
prevent data oscillation. (Micheletti &amp; Perotto, 2006)
Typically, tau will be ~= 6-8 * |e|_H1.</a:documentation>
          <ref name="real"/>
        </element>
      </element>
    </choice>
  </define>
  <define name="adaptivity_options_scalar_field">
    <optional>
      <element name="adaptivity_options">
        <ref name="adaptivity_options_scalar_field.adaptivity_options"/>
        <ref name="adaptivity_preprocessing"/>
      </element>
    </optional>
  </define>
  <define name="adaptivity_options_prognostic_vector_field">
    <optional>
      <element name="adaptivity_options">
        <a:documentation>Adaptivity weights</a:documentation>
        <choice>
          <element name="absolute_measure">
            <a:documentation>When specifying absolute measure
one specifies the absolute interpolation
error in the units of the field that is
being adapted, e.g. you can specify
the error to be 1.3 units </a:documentation>
            <element name="vector_field">
              <attribute name="rank">
                <value>1</value>
              </attribute>
              <attribute name="name">
                <value>InterpolationErrorBound</value>
              </attribute>
              <element name="prescribed">
                <ref name="prescribed_vector_field_no_adapt"/>
              </element>
            </element>
          </element>
          <element name="relative_measure">
            <a:documentation>When specifying relative measure
one specifies the interpolation error
relative to the field that is
being adapted, e.g. you can specify
the error to be 5% (i.e. 0.05)</a:documentation>
            <element name="vector_field">
              <attribute name="rank">
                <value>1</value>
              </attribute>
              <attribute name="name">
                <value>InterpolationErrorBound</value>
              </attribute>
              <element name="prescribed">
                <ref name="prescribed_vector_field_no_adapt"/>
              </element>
            </element>
            <element name="tolerance">
              <a:documentation>The relative Hessian is calculated according to:

  Q = H / max{ |psi|, psi_min}

where H is the Hessian, psi is the field value and
psi_min is the tolerance. The tolerance prevents
division by zero errors.

Source: Fluidity/ICOM manual draft version 1.2</a:documentation>
              <ref name="real_dim_vector"/>
            </element>
          </element>
        </choice>
        <ref name="adaptivity_preprocessing"/>
      </element>
    </optional>
  </define>
  <define name="adaptivity_options_vector_field">
    <optional>
      <element name="adaptivity_options">
        <a:documentation>Adaptivity weights</a:documentation>
        <choice>
          <element name="absolute_measure">
            <a:documentation>When specifying absolute measure
one specifies the absolute interpolation
error in the units of the field that is
being adapted, e.g. you can specify
the error to be 1.3 units </a:documentation>
            <element name="vector_field">
              <attribute name="rank">
                <value>1</value>
              </attribute>
              <attribute name="name">
                <value>InterpolationErrorBound</value>
              </attribute>
              <element name="prescribed">
                <ref name="prescribed_vector_field_no_adapt"/>
              </element>
            </element>
          </element>
          <element name="relative_measure">
            <a:documentation>When specifying relative measure
one specifies the interpolation error
relative to the field that is
being adapted, e.g. you can specify
the error to be 5% (i.e. 0.05)</a:documentation>
            <element name="vector_field">
              <attribute name="rank">
                <value>1</value>
              </attribute>
              <attribute name="name">
                <value>InterpolationErrorBound</value>
              </attribute>
              <element name="prescribed">
                <ref name="prescribed_vector_field_no_adapt"/>
              </element>
            </element>
            <element name="tolerance">
              <a:documentation>The relative Hessian is calculated according to:

  Q = H / max{ |psi|, psi_min}

where H is the Hessian, psi is the field value and
psi_min is the tolerance. The tolerance prevents
division by zero errors.

Source: Fluidity/ICOM manual draft version 1.2</a:documentation>
              <ref name="real_dim_vector"/>
            </element>
          </element>
        </choice>
        <ref name="adaptivity_preprocessing"/>
      </element>
    </optional>
  </define>
  <define name="adaptivity_options_prognostic_tensor_field">
    <optional>
      <element name="adaptivity_options">
        <a:documentation>Adaptivity weights</a:documentation>
        <choice>
          <element name="absolute_measure">
            <a:documentation>When specifying absolute measure
one specifies the absolute interpolation
error in the units of the field that is
being adapted, e.g. you can specify
the error to be 1.3 units </a:documentation>
            <element name="tensor_field">
              <attribute name="rank">
                <value>2</value>
              </attribute>
              <attribute name="name">
                <value>InterpolationErrorBound</value>
              </attribute>
              <element name="prescribed">
                <ref name="prescribed_values_tensor_field"/>
              </element>
            </element>
          </element>
          <element name="relative_measure">
            <a:documentation>When specifying relative measure
one specifies the interpolation error
relative to the field that is
being adapted, e.g. you can specify
the error to be 5% (i.e. 0.05)</a:documentation>
            <element name="tensor_field">
              <attribute name="rank">
                <value>2</value>
              </attribute>
              <attribute name="name">
                <value>InterpolationErrorBound</value>
              </attribute>
              <element name="prescribed">
                <ref name="prescribed_values_tensor_field"/>
              </element>
            </element>
            <element name="tolerance">
              <a:documentation>The relative Hessian is calculated according to:

  Q = H / max{ |psi|, psi_min}

where H is the Hessian, psi is the field value and
psi_min is the tolerance. The tolerance prevents
division by zero errors.

Source: Fluidity/ICOM manual draft version 1.2</a:documentation>
              <ref name="real_dim_tensor"/>
            </element>
          </element>
        </choice>
        <ref name="adaptivity_preprocessing"/>
      </element>
    </optional>
  </define>
  <define name="adaptivity_options_tensor_field">
    <optional>
      <element name="adaptivity_options">
        <a:documentation>Adaptivity weights</a:documentation>
        <choice>
          <element name="absolute_measure">
            <a:documentation>When specifying absolute measure
one specifies the absolute interpolation
error in the units of the field that is
being adapted, e.g. you can specify
the error to be 1.3 units </a:documentation>
            <element name="tensor_field">
              <attribute name="rank">
                <value>2</value>
              </attribute>
              <attribute name="name">
                <value>InterpolationErrorBound</value>
              </attribute>
              <element name="prescribed">
                <ref name="prescribed_values_tensor_field"/>
              </element>
            </element>
          </element>
          <element name="relative_measure">
            <a:documentation>When specifying relative measure
one specifies the interpolation error
relative to the field that is
being adapted, e.g. you can specify
the error to be 5% (i.e. 0.05)</a:documentation>
            <element name="tensor_field">
              <attribute name="rank">
                <value>2</value>
              </attribute>
              <attribute name="name">
                <value>InterpolationErrorBound</value>
              </attribute>
              <element name="prescribed">
                <ref name="prescribed_values_tensor_field"/>
              </element>
            </element>
            <element name="tolerance">
              <a:documentation>The relative Hessian is calculated according to:

  Q = H / max{ |psi|, psi_min}

where H is the Hessian, psi is the field value and
psi_min is the tolerance. The tolerance prevents
division by zero errors.

Source: Fluidity/ICOM manual draft version 1.2</a:documentation>
              <ref name="real_dim_tensor"/>
            </element>
          </element>
        </choice>
        <ref name="adaptivity_preprocessing"/>
      </element>
    </optional>
  </define>
  <define name="generic_aliased_field">
    <attribute name="material_phase_name">
      <data type="string"/>
    </attribute>
    <attribute name="field_name">
      <data type="string"/>
    </attribute>
  </define>
  <!-- Most common mesh choices -->
  <define name="mesh_choice">
    <choice>
      <element name="mesh">
        <attribute name="name">
          <data type="string"/>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>CoordinateMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>VelocityMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>PressureMesh</value>
        </attribute>
      </element>
    </choice>
  </define>
  <!--
    Not really a choice, for fields that have to be on the velocity mesh
    currently that's all scalar fields, except pressure
    and of course velocity itself
    If you want to implement scalar fields on other meshes, feel free to do so
    but bare in mind you need to make sure the field stays outside RMEM.
    Currently all scalar fields are packed in RMEM with length nonods
  -->
  <define name="velocity_mesh_choice">
    <choice>
      <element name="mesh">
        <attribute name="name">
          <value>VelocityMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>PressureMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>CoordinateMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
      </element>
    </choice>
  </define>
  <define name="pressure_mesh_choice">
    <choice>
      <element name="mesh">
        <attribute name="name">
          <value>PressureMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>VelocityMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>CoordinateMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
      </element>
    </choice>
  </define>
  <!-- This is the choice of additional scalar field to be solved for -->
  <define name="scalar_field_choice">
    <!--
      The first is a generic field, which may be used for any user-defined field
      that FLUIDITY knows nothing about, or a generic diagnostic
    -->
    <choice>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <choice>
          <a:documentation>Field type</a:documentation>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="diagnostic">
            <ref name="scalar_diagnostic_algorithms"/>
            <ref name="velocity_mesh_choice"/>
            <optional>
              <ref name="python_diagnostic_field_code"/>
            </optional>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="___Prognostic_Fields_Below___">
        <a:documentation>Prognostic scalar fields below this</a:documentation>
        <empty/>
      </element>
      <!--
        This is the long list of fields that FLUIDITY knows about
        - - First is a list of fields that are primarily prognostic,
           but can be set to prescribed, or aliased...
        - - The list is in order of most frequently used.
      -->
      <element name="scalar_field">
        <a:documentation>Salinity</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Salinity</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Temperature</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Temperature</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Background Temperature</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>BackgroundTemperature</value>
        </attribute>
        <element name="prescribed">
          <ref name="velocity_mesh_choice"/>
          <ref name="prescribed_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Passive Tracer</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Tracer</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Free Surface</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>FreeSurface</value>
        </attribute>
        <element name="diagnostic">
          <a:documentation>Free Surface
NOTE: the diagnostic FreeSurface field only works in combination
with the free_surface boundary condition applied to the Velocity
field. It gives you a 3D field (constant over the vertical)
of the free surface elevation.</a:documentation>
          <ref name="internal_algorithm"/>
          <!--
            this is hard-coded on the PressureMesh as long as the Pressure is
            if this is no longer true, it should be option-checked to be on the
            same mesh as Pressure
          -->
          <element name="mesh">
            <a:documentation>Must be on the same mesh as Pressure</a:documentation>
            <attribute name="name">
              <value>PressureMesh</value>
            </attribute>
          </element>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Second Fluid</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>SecondFluid</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Diffuse Interface</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>DiffuseInterface</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>BalancePressure</value>
        </attribute>
        <element name="prognostic">
          <!--
            Note the assumptions about quadratic/linear below and hard-coding
            of the mesh, this is because of restrictions of the
            current code, will change in the near future.
          -->
          <element name="mesh">
            <a:documentation>Note that this is not the quadratic mesh balance pressure is
actually calculated on, but the linear mesh it is projected back
on for output purposes.</a:documentation>
            <attribute name="name">
              <value>VelocityMesh</value>
            </attribute>
          </element>
          <ref name="prognostic_balance_pressure_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>If enabled, decomposes Pressure by solving for the balanced part of
Pressure using a "geopressure" solver:

  f = - grad p_gp + g

By choosing an appropriate mesh (typically velocity mesh order + 1)
for the balanced part of pressure, physical balance can be
represented to a higher degree of accuracy.

Expanded BalancePressure field. As BalancePressure, but with
additional options, including the ability to choose a general
mesh for the geopressure solver.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>GeostrophicPressure</value>
        </attribute>
        <element name="prognostic">
          <element name="mesh">
            <a:documentation>The GeostrophicPressure mesh

&lt;b&gt;WARNING: It is usual for this to be a higher degree
mesh than the velocity mesh&lt;/b&gt;</a:documentation>
            <attribute name="name">
              <data type="string"/>
            </attribute>
            <ref name="comment"/>
          </element>
          <ref name="prognostic_geostrophic_pressure_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>VerticalBalancePressure</value>
        </attribute>
        <element name="prognostic">
          <ref name="mesh_choice">
            <a:documentation>This needs to be a quadratic DG mesh</a:documentation>
          </ref>
          <ref name="prognostic_vertical_balance_pressure_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>MaterialVolumeFraction field:

Volume fraction of this material.
Required in multimaterial simulations.
 - if prognostic solves for the volume fraction
 - if prescribed uses a specified volume fraction
 - if diagnostic solves for the final material volume fraction
Only 1 diagnostic MaterialVolumeFraction field allowed per
simulation or solves for all the volume fractions based on
the SumMaterialVolumeFractions field.

A diagnostic MaterialVolumeFraction field is currently required for
compressible multimaterial simulations (even if only 1 material).
Generally also requires a MaterialDensity field.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MaterialVolumeFraction</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
            <optional>
              <ref name="cap_option"/>
            </optional>
            <optional>
              <ref name="surface_tension_option"/>
            </optional>
          </element>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
            <optional>
              <ref name="cap_option"/>
            </optional>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
            <optional>
              <ref name="cap_option"/>
            </optional>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>MaterialDensity field:

Field for the density of this material.
Required in multimaterial simulations.
 - prescribed if an incompressible simulation
 - diagnostic if using a linear equation of state
 - prognostic if a compressible simulation
(note that if you set a multimaterial
equation of state and this field is
prognostic then its initial condition
will be overwritten by the density that
satisfies the initial pressure and
the equation of state)</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MaterialDensity</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>MaterialInternalEnergy field:

Field for the internal energy of this material.
Required in multimaterial compressible simulations
with full stiffened_gas (perfect gas) eos.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MaterialInternalEnergy</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>SumMaterialVolumeFractions field:

Sums the prognostic MaterialVolumeFraction fields.
- diagnostic: sums all the volume fractions in the other
  material phases</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>SumMaterialVolumeFractions</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>CopiedField - This field copies the previous timesteps
values from another (specified) field at every iteration
and then solves the field using different (again, specified)
scheme and solution options.
For instance, this field can be used to create a diffused
field to adapt to.
Unless someone requests otherwise this is only currently possible
for fields within the same material_phase.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>CopiedField</value>
        </attribute>
        <element name="prognostic">
          <ref name="velocity_mesh_choice"/>
          <attribute name="copy_from_field">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <ref name="prognostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Calculate the stream function of 2D incompressible flow. Note
that this *only* makes sense for proper 2D (not pseudo-2D) simulations.
Requires a continuous mesh.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>StreamFunction</value>
        </attribute>
        <element name="prognostic">
          <ref name="mesh_choice"/>
          <ref name="prognostic_stream_function_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Phytoplankton</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Phytoplankton</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Zooplankton</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Zooplankton</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Nutrient</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Nutrient</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Detritus</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Detritus</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>PhaseVolumeFraction:
Required in porous_media problem type</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>PhaseVolumeFraction</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Electrical Potential:
Required in electrokinetic, electrothermal
and electrochemical problems
(sub-option of porous_media problem type)</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ElectricalPotential</value>
        </attribute>
        <element name="prognostic">
          <ref name="velocity_mesh_choice"/>
          <ref name="prognostic_scalar_field"/>
        </element>
      </element>
      <!--
        Insert new prognostic scalar fields here using the template:
               element scalar_field {
                   attribute rank { "0" },
                   attribute name { "NewFieldName" },
                   (
                      element prognostic {
                         velocity_mesh_choice,
                         prognostic_scalar_field
                      }|
                      element prescribed {
                         velocity_mesh_choice,
                         prescribed_scalar_field
                      }|
                      element aliased {
                         generic_aliased_field
                      }
                   )
               }
      -->
      <!--
        - - Second is a list of fields that are primarily prescribed,
           but can be aliased. An example is wind velocity.
        - - The list is in order of most frequently used.
      -->
      <element name="___Prescribed_fields_below___">
        <a:documentation>Prescribed scalar fields below this</a:documentation>
        <empty/>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>DistanceToSideBoundaries</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>MaterialFrictionAngle for multimaterial
plasticity problems

Requires a diagnostic bulk FrictionAngle field
- not tested yet</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MaterialFrictionAngle</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>MaterialCohesion for multimaterial
plasticity problems

Requires a diagnostic bulk Cohesion field
- not tested yet</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MaterialCohesion</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <!--

        Insert new prescribed scalar fields here using the template:
               element scalar_field {
                   attribute rank { "0" },
                   attribute name { "NewFieldName" },
                   (
                      element prescribed {
                         velocity_mesh_choice,
                         prescribed_scalar_field
                      }|
                      element aliased {
                         generic_aliased_field
                      }
                   )
               }

        - - Last is a list of fields that are primarily diagnostic,
           but can be aliased. An example is Tidal Range.
        - - The list is in order of most frequently used.

      -->
      <element name="___Diagnostic_Fields_Below___">
        <a:documentation>Diagnostic scalar fields below this</a:documentation>
        <empty/>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>PerturbationDensity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>ControlVolumeDivergence:

div field

Divergence of the velocity field where
the divergence operator is defined using
the control volume C^T matrix.
This assumes that the test space is discontinuous
control volumes.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ControlVolumeDivergence</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_cv_divergence_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>FiniteElementDivergence:

div field

Divergence of the velocity field where
the divergence operator is defined using
the finite element C^T matrix.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>FiniteElementDivergence</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="velocity_mesh_choice"/>
            <optional>
              <element name="integrate_divergence_by_parts">
                <empty/>
              </element>
            </optional>
            <ref name="diagnostic_fe_divergence_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Diffusive dissipation</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>DiffusiveDissipation</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Richardson Number:

 Ri = \frac{N^2}{(\frac{\partial u}{\partial z})^2 + (\frac{\partial u}{\partial z})^2}
with
 N^2 = -\frac{g}{\rho_0}\frac{\partial \rho}{\partial z}

Limitations:
 - Gravity must be constant.
 - Assumes gravity is in -ve final coordinate direction.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>RichardsonNumber</value>
        </attribute>
        <attribute name="depends">
          <value>Velocity,PerturbationDensity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_richardson_number_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>CFLNumber

See http://amcg.ese.ic.ac.uk/index.php?title=Local:Diagnostics#CFL_Number

Adapting to this field is not recommended</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>CFLNumber</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>ControlVolumeCFLNumber

Courant Number as defined on a control volume mesh

Adapting to this field is not recommended</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ControlVolumeCFLNumber</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>DG_CourantNumber

Courant Number as defined on a DG mesh

Adapting to this field is not recommended</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>DG_CourantNumber</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>CVMaterialDensityCFLNumber

Courant Number as defined on a control volume mesh and
incorporating the MaterialDensity.
Requires a MaterialDensity field!

Adapting to this field is not recommended</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>CVMaterialDensityCFLNumber</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>SolidConcentration</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>This scalar field is meant to replace DENTRAF.
Basically, if you use new options, DENTRAF is no longer needed
No repointing is done from this field to DENTRAF.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>CopyofDensity</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Add field to be used by Solid_configuration to
Visualize the solids and MaterialVolumeFraction together</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>VisualizeSolidFluid</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Add field to be used by Solid_configuration to
Visualize the solid_Concentration</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>VisualizeSolid</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Add field to be used by Solid_configuration to
map  the solid_Concentration from particle mesh to
the fluid mesh.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ParticleScalar</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Add field to be used by Explicit_ALE to
visualize functional values before iterations start.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>FunctionalBegin</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Add field to be used by Explicit_ALE to
visualize functional values at each iteration.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>FunctionalIter</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>add a MaterialVolume scalar_field to calculate the spatially varying
volume of a material (requires a MaterialVolumeFraction)</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MaterialVolume</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>add a MaterialMass scalar_field to calculate the spatially varying
mass of a material (requires a MaterialVolumeFraction and a MaterialDensity)</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MaterialMass</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Calculates the MaterialDensity based on the bulk Pressure
(and MaterialInternalEnergy if appropriate) for the equation
of state of this material.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MaterialEOSDensity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Calculates the MaterialPressure based on the MaterialDensity
(and MaterialInternalEnergy if appropriate) for the equation
of state of this material.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MaterialPressure</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Calculates the BulkMaterialPressure based on the MaterialDensity
and MaterialVolumeFraction (and MaterialInternalEnergy if appropriate)
for the equation of state of all materials.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>BulkMaterialPressure</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Grid Reynolds number</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>GridReynoldsNumber</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <element name="mesh">
              <attribute name="name">
                <value>VelocityMesh</value>
              </attribute>
            </element>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>GridPecletNumber

Peclet Number Pe = U*dx/2*diffusivity

Also see the test case 'grid_peclet_number'
if you wish to see the effect of changing the
diffusivity on a 1D, cg-discretised tracer-field

Adapting to this field is not recommended</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>GridPecletNumber</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="mesh_choice">
              <a:documentation>Mesh on which to calculate dx</a:documentation>
            </ref>
            <element name="field_name">
              <a:documentation>This is the name of the scalar field
to calculate the Peclet number for
Note this field needs to have a diffusivity</a:documentation>
              <data type="string" datatypeLibrary=""/>
            </element>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Horizontal velocity divergence:

div_H velocity

Uses the gravity field direction to determine the horizontal plane.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HorizontalVelocityDivergence</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Velocity divergence:

div velocity
</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>VelocityDivergence</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Kinetic energy density:

 1/2 rho_0*|u|^2

where rho_0 is the (reference) density

Limitations:
 - The Density, PerturbationDensity, KineticEnergyDensity and Velocity fields must be on the same mesh.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>KineticEnergyDensity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Gravitational potential energy density:

rho_0*(1.0 + rho')*(g dot (r - r_0))

where rho_0 is the (reference) density, rho' is the perturbation density and r_0 is the potential energy zero point.

Limitations:
 - Requires a constant gravity direction.
 - The Density, PerturbationDensity and GravitationalPotentialEnergyDensity fields must be on the same mesh.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>GravitationalPotentialEnergyDensity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
            <element name="zero_point">
              <a:documentation>Coordinate of a point with a potential energy of zero.</a:documentation>
              <ref name="real_dim_vector"/>
            </element>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Isopycnal coordinate

 z_star(x,t) = 1/A int_V' H(rho(x',t)-rho(x,t)) dV'

where rho is the density, A is the width/area of the domain

Limitations:
 - You need to specify a (fine) mesh to redistribute the PerturbationDensity onto
 - Requires a constant gravity direction.
 - The Density, PerturbationDensity and GravitationalPotentialEnergyDensity fields must be on the same mesh.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>IsopycnalCoordinate</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <element name="fine_mesh">
              <a:documentation>This is the mesh onto which we redistribute the PerturbationDensity</a:documentation>
              <attribute name="name">
                <data type="string" datatypeLibrary=""/>
              </attribute>
            </element>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Background potential energy density:

PE_b = rho*z_star

where rho is the density, z_star is the isopycnal coordinate

Limitations:
 - Requires a constant gravity direction.
 - The Density, PerturbationDensity and
 GravitationalPotentialEnergyDensity fields must be on the
 same mesh.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>BackgroundPotentialEnergyDensity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Ertel potential vorticity:

 (f + curl u) dot grad rho'

Limitations:
 - Requires a geometry dimension of 3.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>PotentialVorticity</value>
        </attribute>
        <attribute name="depends">
          <value>Velocity,PerturbationDensity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Relative potential vorticity:

  curl u dot grad rho'</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>RelativePotentialVorticity</value>
        </attribute>
        <attribute name="depends">
          <value>Velocity,PerturbationDensity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Calculate the horizontal stream function psi where:
  \partial_x \psi = -v
  \partial_y \psi = u
where u and v are perpendicular to the gravity direction. Applies a
strong Dirichlet boundary condition of 0 on all boundaries.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HorizontalStreamFunction</value>
        </attribute>
        <attribute name="depends">
          <value>Velocity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <element name="solver">
              <a:documentation>Solver</a:documentation>
              <ref name="linear_solver_options_sym"/>
            </element>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Speed:

 |u|

Limitations:
 - The Speed and Velocity fields must be on the same mesh.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Speed</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Volume of the vehicles

used in Traffic Modelling</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>SolidPhase</value>
        </attribute>
        <attribute name="raplaces">
          <value>IDENT = -42</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Absolute Difference between two scalar fields.

Both fields must be in this material_phase.
Assumes both fields are on the same mesh as the AbsoluteDifference field.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>AbsoluteDifference</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name_a">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <attribute name="field_name_b">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
            <optional>
              <element name="relative_to_average">
                <a:documentation>Evaluate the absolute difference once the average difference has been removed?</a:documentation>
                <empty/>
              </element>
            </optional>
            <optional>
              <element name="ignore_boundaries">
                <a:documentation>Ignore boundary nodes (i.e. zero them when calculating the difference)</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Absolute Difference between two scalar fields.

Both fields must be in this material_phase.
Assumes both fields are on the same mesh as the AbsoluteDifference field.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ScalarAbsoluteDifference</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name_a">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <attribute name="field_name_b">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
            <optional>
              <element name="relative_to_average">
                <a:documentation>Evaluate the absolute difference once the average difference has been removed?</a:documentation>
                <empty/>
              </element>
            </optional>
            <optional>
              <element name="ignore_boundaries">
                <a:documentation>Ignore boundary nodes (i.e. zero them when calculating the difference)</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Galerkin projection of one field onto another mesh.

The field must be in this material_phase.

NOTE: you need the solver options if the mesh
of this field is continuous.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>GalerkinProjection</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <element name="source_field_name">
              <data type="string" datatypeLibrary=""/>
            </element>
            <ref name="mesh_choice"/>
            <optional>
              <element name="lump_mass">
                <a:documentation>Lump the mass matrix of the galerkin projection
less accurate but faster and might give smoother result.                  </a:documentation>
                <empty/>
              </element>
            </optional>
            <optional>
              <element name="solver">
                <ref name="linear_solver_options_sym"/>
              </element>
            </optional>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Primary production of Phytoplankton. This is calculated by
the ocean biology module and will not be calculated unless
ocean biology is being simulated.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>PrimaryProduction</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Grazing of Phytoplankton by Zooplankton. This is calculated by
the ocean biology module and will not be calculated unless
ocean biology is being simulated.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>PhytoplanktonGrazing</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>TidalRange</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field_tidal_range"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicAmplitudeM2</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicPhaseM2</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicAmplitudeS2</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicPhaseS2</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicAmplitudeN2</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicPhaseN2</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicAmplitudeK2</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicPhaseK2</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicAmplitudeK1</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicPhaseK1</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicAmplitudeO1</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicPhaseO1</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicAmplitudeP1</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicPhaseP1</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicAmplitudeQ1</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicPhaseQ1</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicAmplitudeMf</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicPhaseMf</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicAmplitudeMm</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicPhaseMm</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicAmplitudeSSa</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Output the universal numbering of the mesh on which this field is based.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>UniversalNumber</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Output the processors which own the nodes of the mesh on which this field is based.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>NodeOwner</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Output the processors which own the elements of the mesh on which this field is based.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ElementOwner</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
    </choice>
    <!--
      Insert new diagnostic scalar fields here using the template:
             element scalar_field {
                 attribute rank { "0" },
                 attribute name { "NewFieldName" },
                 (
                    element diagnostic {
                       internal_algorithm,
                       velocity_mesh_choice,
                       diagnostic_scalar_field
                    }|
                    element aliased {
                       generic_aliased_field
                    }
                 )
             }
    -->
  </define>
  <!-- This is the choice of additional vector field to be solved for -->
  <define name="vector_field_choice">
    <!--
      The first is a generic field, which may be used for any user-defined field
      that FLUIDITY knows nothing about, or a generic diagnostic
      Prognostic vector fields are not possible (other than velocity and those known fields below).
    -->
    <choice>
      <element name="vector_field">
        <a:documentation>Generic field variable (vector)</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <choice>
          <a:documentation>Field type</a:documentation>
          <element name="prescribed">
            <ref name="mesh_choice"/>
            <ref name="prescribed_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
          <element name="diagnostic">
            <ref name="vector_diagnostic_algorithms"/>
            <ref name="velocity_mesh_choice"/>
            <optional>
              <ref name="python_diagnostic_field_code"/>
            </optional>
            <ref name="diagnostic_vector_field"/>
          </element>
        </choice>
      </element>
      <!--

        - - List of fields that are primarily prognostic,
           but can be aliased.
        - - The list is in order of most frequently used.

      -->
      <element name="___Prognostic_fields_below___">
        <a:documentation>Prescribed vector fields below this</a:documentation>
        <empty/>
      </element>
      <!--

        - - List of fields that are primarily prescribed,
           but can be aliased. An example is Maximum bed shear stress.
        - - The list is in order of most frequently used.

      -->
      <element name="___Prescribed_fields_below___">
        <a:documentation>Prescribed vector fields below this</a:documentation>
        <empty/>
      </element>
      <element name="vector_field">
        <a:documentation>Gradient of a scalar field evaluated using the C gradient
matrix constructed using finite elements.
Field must be in this material_phase.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>FiniteElementGradient</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="mesh_choice"/>
            <optional>
              <element name="integrate_gradient_by_parts">
                <empty/>
              </element>
            </optional>
            <ref name="diagnostic_gradient_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Gradient of a scalar field evaluated using the transpose
of the C^T divergence matrix constructed using finite
elements.
Field must be in this material_phase.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>FiniteElementDivergenceTransposed</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="mesh_choice"/>
            <optional>
              <element name="integrate_divergence_by_parts">
                <empty/>
              </element>
            </optional>
            <ref name="diagnostic_gradient_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Relative vorticity field - curl of the velocity field</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>Vorticity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <!--
              element algorithm {
                attribute name { "curl" },
                attribute material_phase_support { "single" },
                attribute source_field_name { "Velocity" }
              },
            -->
            <element name="mesh">
              <a:documentation>Relative vorticity</a:documentation>
              <attribute name="name">
                <value>VelocityMesh</value>
              </attribute>
            </element>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Planetary vorticity

Limitations:
 - Requires geometry dimension of 3.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>PlanetaryVorticity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Absolute vorticity:

  f + curl u

Limitations:
 - Requires a geometry dimension of 3.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>AbsoluteVorticity</value>
        </attribute>
        <attribute name="depends">
          <value>Velocity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Gradient of a scalar field evaluated using the transpose
of the C^T matrix constructed using control volumes.
Field must be in this material_phase.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>ControlVolumeDivergenceTransposed</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_cv_gradient_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Full velocity in an
inner element SGS treatment of momentum

Limitations:
 - Requires a geometry dimension of 3.
 - Requires inner element active for momentum</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>InnerElementFullVelocity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <element name="mesh">
              <attribute name="name">
                <value>InnerElementMesh</value>
              </attribute>
            </element>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Vorticity of the full velocity in an
inner element SGS treatment of momentum

Limitations:
 - Requires a geometry dimension of 3.
 - Requires inner element active for momentum</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>InnerElementFullVorticity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <element name="mesh">
              <attribute name="name">
                <value>InnerElementMesh</value>
              </attribute>
            </element>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Vorticity of the SGS velocity in an
inner element SGS treatment of momentum

Limitations:
 - Requires a geometry dimension of 3.
 - Requires inner element active for momentum</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>InnerElementVorticity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <element name="mesh">
              <attribute name="name">
                <value>InnerElementMesh</value>
              </attribute>
            </element>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>The continuous solution mapped to a discontinuous mesh

Limitations:
 - Requires a geometry dimension of 3.
 - Requires inner element active for momentum</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>DgMappedVelocity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <element name="mesh">
              <attribute name="name">
                <value>InnerElementMesh</value>
              </attribute>
            </element>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Vorticity of the DG mapped Velocity
Note vorticity is actually calculated over a DG field

Limitations:
 - Requires a geometry dimension of 3.
 - Requires inner element active for momentum</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>DgMappedVorticity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <element name="mesh">
              <attribute name="name">
                <value>InnerElementMesh</value>
              </attribute>
            </element>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Solid Velocity field.  Used to generate the momentum source </a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>SolidVelocity</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="mesh_choice"/>
          <ref name="diagnostic_vector_field"/>
        </element>
      </element>
      <element name="vector_field">
        <a:documentation>Same as Solid Velocity field but it is on the Particle mesh.
It is used to map the velocities coming from an external program like
FEMDEM or DEM to the fluid mesh. </a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>ParticleVector</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="mesh_choice"/>
          <ref name="diagnostic_vector_field"/>
        </element>
      </element>
      <element name="vector_field">
        <a:documentation>Same as Solid Velocity field but it is on the Particle mesh.
It is used to map the velocities coming from an external program like
FEMDEM or DEM to the fluid mesh. </a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>ParticleForce</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="mesh_choice"/>
          <ref name="diagnostic_vector_field"/>
        </element>
      </element>
      <element name="vector_field">
        <a:documentation>Same as Solid Velocity field but it is on the Particle mesh.
It is used to map the velocities coming from an external program like
FEMDEM or DEM to the fluid mesh. </a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>SolidForce</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_vector_field"/>
        </element>
      </element>
      <element name="vector_field">
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>VelocityPlotForSolids</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_vector_field"/>
        </element>
      </element>
      <element name="vector_field">
        <a:documentation>Same as Solid Velocity field but it is on the Particle mesh.
It is used to map the velocities coming from an external program like
FEMDEM or DEM to the fluid mesh. </a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>FunctionalGradient</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_vector_field"/>
        </element>
      </element>
      <element name="vector_field">
        <a:documentation>LinearMomentum field.
 p = \rho*u
(where p is the linear momentum, \rho the density and u the velocity)</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>LinearMomentum</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Absolute Difference between two vector fields.

Both fields must be in this material_phase.
Assumes both fields are on the same mesh as the AbsoluteDifference field.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>AbsoluteDifference</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name_a">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <attribute name="field_name_b">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Absolute Difference between two vector fields.

Both fields must be in this material_phase.
Assumes both fields are on the same mesh as the AbsoluteDifference field.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>VectorAbsoluteDifference</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name_a">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <attribute name="field_name_b">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Bed Shear Stress = density*drag_coeff*|u|*u

at the moment this assumes the density and drag coefficients are constants.
This diagnostic vector field is only calculated over surface elements/nodes,
interior nodes will have zero value.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>BedShearStress</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_vector_field_bed_shear_stress"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Max Bed Shear Stress.

Note that you need BedShearStress turned on for this to work.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>MaxBedShearStress</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <group>
              <ref name="internal_algorithm"/>
              <ref name="velocity_mesh_choice"/>
            </group>
            <!-- diagnostic_vector_field_max_bed_shear_stress -->
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
        <element name="spin_up_time">
          <a:documentation>This is the time after which the max operator is
applied to the bed shear stress.</a:documentation>
          <ref name="real"/>
        </element>
      </element>
      <element name="vector_field">
        <a:documentation>Galerkin projection of one field onto another mesh.

The field must be in this material_phase.

NOTE: you need the solver options if the mesh
of this field is continuous.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>GalerkinProjection</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <element name="source_field_name">
              <data type="string" datatypeLibrary=""/>
            </element>
            <ref name="mesh_choice"/>
            <optional>
              <element name="lump_mass">
                <a:documentation>Lump the mass matrix of the galerkin projection
less accurate but faster and might give smoother result.                  </a:documentation>
                <empty/>
              </element>
            </optional>
            <optional>
              <element name="solver">
                <ref name="linear_solver_options_sym"/>
              </element>
            </optional>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Compute the imbalanced component of velocity,
that is,
u - u_bal
where u_bal is the velocity that puts the state in geostrophic
balance.
Note: if your VelocityMesh is continuous, then the solver option
is necessary.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>ImbalancedVelocity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <optional>
              <element name="solver">
                <ref name="linear_solver_options_sym"/>
              </element>
            </optional>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Compute the balanced component of velocity,
that is, the velocity that puts the state in geostrophic
balance.
This diagnostic depends on ImbalancedVelocity.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>BalancedVelocity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
    </choice>
    <!--
      Insert new diagnostic vector field here using the template:
             element vector_field {
                 attribute rank { "1" },
                 attribute name { "NewFieldName" },
                 (
                    element diagnostic {
                       internal_algorithm,
                       mesh_choice,
                       diagnostic_vector_field
                    }|
                    element aliased {
                       generic_aliased_field
                    }
                 )
             }
    -->
  </define>
  <!-- This is the choice of additional tensor fields -->
  <define name="tensor_field_choice">
    <!--
      The first is a generic field, which may be used for any user-defined field
      that FLUIDITY knows nothing about, or a generic diagnostic
      Prognostic tensor fields are not possible.
    -->
    <choice>
      <element name="tensor_field">
        <a:documentation>Generic field variable (tensor)</a:documentation>
        <attribute name="rank">
          <value>2</value>
        </attribute>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <choice>
          <a:documentation>Field type</a:documentation>
          <element name="prescribed">
            <ref name="mesh_choice"/>
            <ref name="prescribed_tensor_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
          <element name="diagnostic">
            <ref name="tensor_diagnostic_algorithms"/>
            <ref name="velocity_mesh_choice"/>
            <optional>
              <ref name="python_diagnostic_field_code"/>
            </optional>
            <ref name="diagnostic_tensor_field"/>
          </element>
        </choice>
      </element>
      <!--

        - - Second is a list of tensor fields that are primarily prescribed,
           but can be aliased.
        - - The list is in order of most frequently used.

      -->
      <element name="___Prescribed_fields_below___">
        <a:documentation>Prescribed scalar fields below this</a:documentation>
        <empty/>
      </element>
      <element name="tensor_field">
        <a:documentation>MaterialViscosity field:

Field for the viscosity of this material.
Required if using a diagnostic bulk viscosity
in a multimaterial simulation.</a:documentation>
        <attribute name="rank">
          <value>2</value>
        </attribute>
        <attribute name="name">
          <value>MaterialViscosity</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="mesh_choice"/>
            <ref name="prescribed_tensor_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="tensor_field">
        <attribute name="rank">
          <value>2</value>
        </attribute>
        <attribute name="name">
          <value>MaterialElasticity</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="mesh_choice"/>
            <ref name="prescribed_tensor_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <!--

        Insert new prescribed tensor fields here using the template:
               element tensor_field {
                   attribute rank { "2" },
                   attribute name { "NewFieldName" },
                   (
                      element prescribed {
                         mesh_choice,
                         prescribed_tensor_field
                      }|
                      element aliased {
                         generic_aliased_field
                      }
                   )
               }|

        - - Last is a list of fields that are primarily diagnostic,
           but can be aliased.
        - - The list is in order of most frequently used.

      -->
      <element name="___Diagnostic_Fields_Below___">
        <a:documentation>Diagnostic tensor fields below this</a:documentation>
        <empty/>
      </element>
    </choice>
    <!--
      Insert new diagnostic tensor field here using the template:
             element tensor_field {
                 attribute name { "NewFieldName" },
                 (
                    element diagnostic {
                       internal_algorithm,
                       mesh_choice,
                       diagnostic_tensor_field
                    }|
                    element aliased {
                       generic_aliased_field
                    }
                 )
             }
    -->
  </define>
  <define name="mesh_info">
    <choice>
      <element name="from_file">
        <a:documentation>Read mesh from file.</a:documentation>
        <choice>
          <element name="format">
            <a:documentation>Triangle mesh format.

Enter the base name without the .edge .ele, .face or
.node extensions, and without process numbers.</a:documentation>
            <attribute name="name">
              <value>triangle</value>
            </attribute>
            <!-- string_value elements are used only for backwards compatibility - any new format choices should NOT have these -->
            <element name="string_value">
              <value>triangle</value>
            </element>
            <ref name="comment"/>
          </element>
          <element name="format">
            <a:documentation>Read the mesh from a vtu. Note that the mesh will have no surface
or region IDs.</a:documentation>
            <attribute name="name">
              <value>vtu</value>
            </attribute>
            <ref name="comment"/>
          </element>
        </choice>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
        <ref name="from_file_mesh_stat_options"/>
        <ref name="comment"/>
      </element>
      <element name="from_mesh">
        <a:documentation>Make mesh from existing mesh. The existing mesh cannot itself
be made from an existing mesh (i.e. it must be read from a
file).</a:documentation>
        <ref name="mesh_choice"/>
        <optional>
          <element name="mesh_shape">
            <element name="polynomial_degree">
              <ref name="integer"/>
            </element>
          </element>
        </optional>
        <optional>
          <element name="mesh_continuity">
            <element name="string_value">
              <choice>
                <value>continuous</value>
                <value>discontinuous</value>
              </choice>
            </element>
          </element>
        </optional>
        <zeroOrMore>
          <element name="periodic_boundary_conditions">
            <a:documentation>Make mesh periodic</a:documentation>
            <attribute name="name">
              <data type="string"/>
            </attribute>
            <element name="physical_boundary_ids">
              <a:documentation>List of boundary ids that are aliased to</a:documentation>
              <ref name="integer_vector"/>
            </element>
            <element name="aliased_boundary_ids">
              <a:documentation>List of boundary ids that are aliased</a:documentation>
              <ref name="integer_vector"/>
            </element>
            <element name="coordinate_map">
              <a:documentation>Python code which takes coordinate of an aliased
boundary node and returns the coordinate of a physical
boundary node</a:documentation>
              <ref name="python_code"/>
            </element>
          </element>
        </zeroOrMore>
        <optional>
          <element name="extrude">
            <a:documentation>Extrude a horizontal (1D or 2D) mesh in the vertical</a:documentation>
            <element name="bottom_depth">
              <a:documentation>Depth over which to extrude
top will be at z=0
bottom will be at z=-bottom_depth</a:documentation>
              <ref name="real"/>
            </element>
            <element name="sizing_function">
              <a:documentation>Constant or function to specify the depth of the
layers. The function is a function of all coordinates
(so in 2+1D: x,y and z) to specify a layer depth that
varies both in the horizontal as in the vertical.</a:documentation>
              <ref name="input_choice_real"/>
            </element>
            <optional>
              <element name="top_surface_id">
                <a:documentation>surface_id to assign to the top of the extruded mesh</a:documentation>
                <ref name="integer"/>
              </element>
            </optional>
            <optional>
              <element name="bottom_surface_id">
                <a:documentation>surface_id to assign to the bottom of the extruded mesh</a:documentation>
                <ref name="integer"/>
              </element>
            </optional>
          </element>
        </optional>
        <ref name="derived_mesh_stat_options"/>
        <ref name="comment"/>
      </element>
    </choice>
  </define>
  <!-- Options for inclusion/exclusion of mesh statistics from the .stat file -->
  <define name="include_mesh_in_stat">
    <element name="include_in_stat">
      <a:documentation>Include this mesh in the .stat file</a:documentation>
      <ref name="comment"/>
    </element>
  </define>
  <define name="exclude_mesh_from_stat">
    <element name="exclude_from_stat">
      <a:documentation>Exclude this mesh from the .stat file</a:documentation>
      <ref name="comment"/>
    </element>
  </define>
  <!-- Diagnostic statistics options for meshed, with enabled by default -->
  <define name="mesh_stat_options_enabled_default">
    <ref name="include_mesh_in_stat"/>
  </define>
  <define name="mesh_stat_options_enabled_default" combine="choice">
    <ref name="exclude_mesh_from_stat"/>
  </define>
  <!-- Diagnostic statistics options for meshed, with disabled by default -->
  <define name="mesh_stat_options_disabled_default">
    <ref name="exclude_mesh_from_stat"/>
  </define>
  <define name="mesh_stat_options_disabled_default" combine="choice">
    <ref name="include_mesh_in_stat"/>
  </define>
  <define name="from_file_mesh_stat_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <ref name="mesh_stat_options_enabled_default"/>
    </element>
  </define>
  <define name="derived_mesh_stat_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <ref name="mesh_stat_options_disabled_default"/>
    </element>
  </define>
  <define name="linear_solver_options_asym">
    <choice>
      <a:documentation>Iterative (Krylov) method to solve the linear discretised equation
Given are the most frequently used methods. The solution is done
by the PETSc library. Many more methods are provided.
</a:documentation>
      <element name="iterative_method">
        <a:documentation>GMRES

Your safest bet for non-symmetric systems.</a:documentation>
        <attribute name="name">
          <value>gmres</value>
        </attribute>
        <element name="restart">
          <a:documentation>Restart value for gmres iteration
Higher values give better convergence but require more memory.
Suggested value: 30</a:documentation>
          <ref name="integer"/>
        </element>
      </element>
      <element name="iterative_method">
        <a:documentation>Conjugate gradient method

Only works for symmetric systems.</a:documentation>
        <attribute name="name">
          <value>cg</value>
        </attribute>
      </element>
      <element name="iterative_method">
        <a:documentation>Direct method

This is for non-iterative methods
Only makes sense in combination with preconditioners that do a complete solve, e.g. lu.</a:documentation>
        <attribute name="name">
          <value>preonly</value>
        </attribute>
      </element>
      <element name="iterative_method">
        <a:documentation>Richardson iteration

Only apply preconditioner each iteration, no krylov acceleration</a:documentation>
        <attribute name="name">
          <value>richardson</value>
        </attribute>
      </element>
      <element name="iterative_method">
        <a:documentation>Other methods

Any method provided by the PETSc library
http://www-unix.mcs.anl.gov/petsc/petsc-2/snapshots/petsc-dev/docs/manualpages/KSP/KSPType.html
(available methods may depend on the PETSc library installed on your system)</a:documentation>
        <attribute name="name">
          <data type="string"/>
        </attribute>
      </element>
    </choice>
    <choice>
      <a:documentation>Preconditioner to be used in combination with the iterative method.</a:documentation>
      <element name="preconditioner">
        <a:documentation>Succesive Over-Relaxation

This includes SSOR (symmetric sor)</a:documentation>
        <attribute name="name">
          <value>sor</value>
        </attribute>
      </element>
      <element name="preconditioner">
        <a:documentation>The Eisenstat method

This preconditioner is equivalent to SOR but only uses
half the number of flops,
i.e. same convergence rate but twice as fast per
iteration. Because it computes
a different preconditioned residual the convergence in
practice may be quite different though.

It does not work in parallel!</a:documentation>
        <attribute name="name">
          <value>eisenstat</value>
        </attribute>
      </element>
      <element name="preconditioner">
        <a:documentation>Incomplete LU decomposition</a:documentation>
        <attribute name="name">
          <value>ilu</value>
        </attribute>
      </element>
      <element name="preconditioner">
        <a:documentation>LU direct solver

This performs a complete, direct solve of the equation and should only be used in combination with preonly as iterative method.</a:documentation>
        <attribute name="name">
          <value>lu</value>
        </attribute>
      </element>
      <element name="preconditioner">
        <a:documentation>Fluidity`s own multigrid method

Especially suited for ill-conditioned, large aspect ratio problems.</a:documentation>
        <attribute name="name">
          <value>mg</value>
        </attribute>
      </element>
      <element name="preconditioner">
        <a:documentation>Prometheus multigrid method</a:documentation>
        <attribute name="name">
          <value>prometheus</value>
        </attribute>
      </element>
      <element name="preconditioner">
        <a:documentation>Hypre preconditioners (includes boomeramg)</a:documentation>
        <attribute name="name">
          <value>hypre</value>
        </attribute>
        <choice>
          <element name="hypre_type">
            <a:documentation>BoomerAMG multigrid method</a:documentation>
            <attribute name="name">
              <value>boomeramg</value>
            </attribute>
          </element>
          <element name="hypre_type">
            <a:documentation>Other Hypre preconditioners</a:documentation>
            <attribute name="name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
          </element>
        </choice>
      </element>
      <element name="preconditioner">
        <a:documentation>Complete solve

This only makes sense for solves where a different approximated preconditioner
matrix is provided. For instance when solving pressure with the
option full_schur_complement and using a masslumped schur complement
as preconditioner matrix.

NOTE: If you are using a krylov method (cg/gmres) for this preconditioner
solve you either need to set your tolerances much stricter for it
than in the outer solve (so that the preconditioner is close to an
exact matrix inversion), or use fgmres in the outer solve.</a:documentation>
        <attribute name="name">
          <value>ksp</value>
        </attribute>
        <element name="solver">
          <a:documentation>Solver options for the full solve done by this preconditioner</a:documentation>
          <ref name="pc_ksp_solver_options"/>
        </element>
      </element>
      <element name="preconditioner">
        <a:documentation>Other preconditioners

Any preconditioner provided by the PETSc library
http://www-unix.mcs.anl.gov/petsc/petsc-2/snapshots/petsc-dev/docs/manualpages/PC/PCType.html
(available preconditiors may depend on the PETSc library installed on your system)</a:documentation>
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
      </element>
    </choice>
    <ref name="generic_solver_options"/>
  </define>
  <define name="linear_solver_options_sym">
    <choice>
      <a:documentation>Iterative (Krylov) method to solve the linear discretised equation
Given are the most frequently used methods. The solution is done
by the PETSc library. Many more methods are provided.
</a:documentation>
      <element name="iterative_method">
        <a:documentation>Conjugate gradient method

Only works for symmetric systems.</a:documentation>
        <attribute name="name">
          <value>cg</value>
        </attribute>
      </element>
      <element name="iterative_method">
        <a:documentation>GMRES

Your safest bet for non-symmetric systems.</a:documentation>
        <attribute name="name">
          <value>gmres</value>
        </attribute>
        <element name="restart">
          <a:documentation>Restart value for gmres iteration
Higher values give better convergence but require more memory.
Suggested value: 30</a:documentation>
          <ref name="integer"/>
        </element>
      </element>
      <element name="iterative_method">
        <a:documentation>Direct method

This is for non-iterative methods
Only makes sense in combination with preconditioners that do a complete solve, e.g. lu.</a:documentation>
        <attribute name="name">
          <value>preonly</value>
        </attribute>
      </element>
      <element name="iterative_method">
        <a:documentation>Richardson iteration

Only apply preconditioner each iteration, no krylov acceleration</a:documentation>
        <attribute name="name">
          <value>richardson</value>
        </attribute>
      </element>
      <element name="iterative_method">
        <a:documentation>Other methods

Any method provided by the PETSc library
http://www-unix.mcs.anl.gov/petsc/petsc-2/snapshots/petsc-dev/docs/manualpages/KSP/KSPType.html
(available methods may depend on the PETSc library installed on your system)</a:documentation>
        <attribute name="name">
          <data type="string"/>
        </attribute>
      </element>
    </choice>
    <choice>
      <a:documentation>Preconditioner to be used in combination with the iterative method.</a:documentation>
      <element name="preconditioner">
        <a:documentation>Succesive Over-Relaxation

This includes SSOR (symmetric sor)</a:documentation>
        <attribute name="name">
          <value>sor</value>
        </attribute>
      </element>
      <element name="preconditioner">
        <a:documentation>The Eisenstat method

This preconditioner is equivalent to SOR but only uses
half the number of flops,
i.e. same convergence rate but twice as fast per
iteration. Because it computes
a different preconditioned residual the convergence in
practice may be quite different though.
It does not work in parallel!</a:documentation>
        <attribute name="name">
          <value>eisenstat</value>
        </attribute>
      </element>
      <element name="preconditioner">
        <a:documentation>Incomplete LU decomposition</a:documentation>
        <attribute name="name">
          <value>ilu</value>
        </attribute>
      </element>
      <element name="preconditioner">
        <a:documentation>Incomplete Cholesky decomposition (only works for symmetric matrices)</a:documentation>
        <attribute name="name">
          <value>icc</value>
        </attribute>
      </element>
      <element name="preconditioner">
        <a:documentation>LU direct solver

This performs a complete, direct solve of the equation and should only be used in combination with preonly as iterative method.</a:documentation>
        <attribute name="name">
          <value>lu</value>
        </attribute>
      </element>
      <element name="preconditioner">
        <a:documentation>Fluidity`s own multigrid method

Especially suited for ill-conditioned, large aspect ratio problems.</a:documentation>
        <attribute name="name">
          <value>mg</value>
        </attribute>
        <optional>
          <element name="vertical_lumping">
            <a:documentation>apply vertical lumping from the full mesh to the surface mesh
as the first coarsening step instead of the default
aggregation method.</a:documentation>
            <optional>
              <element name="internal_smoother">
                <a:documentation>Does additional smoothing by solving the equation but with
a dirichilet boundary condition on top given by the last iteration
of the multigrid cycle. May be quite expensive per iteration
but improves the solution quite a lot for difficult meshes.</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
        </optional>
      </element>
      <element name="preconditioner">
        <a:documentation>Prometheus multigrid method</a:documentation>
        <attribute name="name">
          <value>prometheus</value>
        </attribute>
      </element>
      <element name="preconditioner">
        <a:documentation>Hypre preconditioners (includes boomeramg)</a:documentation>
        <attribute name="name">
          <value>hypre</value>
        </attribute>
        <choice>
          <element name="hypre_type">
            <a:documentation>BoomerAMG multigrid method</a:documentation>
            <attribute name="name">
              <value>boomeramg</value>
            </attribute>
          </element>
          <element name="hypre_type">
            <a:documentation>Other Hypre preconditioners</a:documentation>
            <attribute name="name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
          </element>
        </choice>
      </element>
      <element name="preconditioner">
        <a:documentation>Complete solve

This only makes sense for solves where a different approximated preconditioner
matrix is provided. For instance when solving pressure with the
option full_schur_complement and using a masslumped schur complement
as preconditioner matrix.

NOTE: If you are using a krylov method (cg/gmres) for this preconditioner
solve you either need to set your tolerances much stricter for it
than in the outer solve (so that the preconditioner is close to an
exact matrix inversion), or use fgmres in the outer solve.</a:documentation>
        <attribute name="name">
          <value>ksp</value>
        </attribute>
        <element name="solver">
          <a:documentation>Solver options for the full solve done by this preconditioner</a:documentation>
          <ref name="pc_ksp_solver_options"/>
        </element>
      </element>
      <element name="preconditioner">
        <a:documentation>Other preconditioners

Any preconditioner provided by the PETSc library
http://www-unix.mcs.anl.gov/petsc/petsc-2/snapshots/petsc-dev/docs/manualpages/PC/PCType.html
(available preconditiors may depend on the PETSc library installed on your system)</a:documentation>
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
      </element>
    </choice>
    <ref name="generic_solver_options"/>
  </define>
  <!--
    this is a copy linear_solver_options_sym, but with preconditioner "ksp"
    removed to avoid infinite recursion
  -->
  <define name="pc_ksp_solver_options">
    <choice>
      <a:documentation>Iterative (Krylov) method to solve the linear discretised equation
Given are the most frequently used methods. The solution is done
by the PETSc library. Many more methods are provided.
</a:documentation>
      <element name="iterative_method">
        <a:documentation>Conjugate gradient method

Only works for symmetric systems.</a:documentation>
        <attribute name="name">
          <value>cg</value>
        </attribute>
      </element>
      <element name="iterative_method">
        <a:documentation>GMRES

Your safest bet for non-symmetric systems.</a:documentation>
        <attribute name="name">
          <value>gmres</value>
        </attribute>
        <element name="restart">
          <a:documentation>Restart value for gmres iteration
Higher values give better convergence but require more memory.
Suggested value: 30</a:documentation>
          <ref name="integer"/>
        </element>
      </element>
      <element name="iterative_method">
        <a:documentation>Direct method

This is for non-iterative methods
Only makes sense in combination with preconditioners that do a complete solve, e.g. lu.</a:documentation>
        <attribute name="name">
          <value>preonly</value>
        </attribute>
      </element>
      <element name="iterative_method">
        <a:documentation>Richardson iteration

Only apply preconditioner each iteration, no krylov acceleration</a:documentation>
        <attribute name="name">
          <value>richardson</value>
        </attribute>
      </element>
      <element name="iterative_method">
        <a:documentation>Other methods

Any method provided by the PETSc library
http://www-unix.mcs.anl.gov/petsc/petsc-2/snapshots/petsc-dev/docs/manualpages/KSP/KSPType.html
(available methods may depend on the PETSc library installed on your system)</a:documentation>
        <attribute name="name">
          <data type="string"/>
        </attribute>
      </element>
    </choice>
    <choice>
      <a:documentation>Preconditioner to be used in combination with the iterative method.</a:documentation>
      <element name="preconditioner">
        <a:documentation>Succesive Over-Relaxation

This includes SSOR (symmetric sor)</a:documentation>
        <attribute name="name">
          <value>sor</value>
        </attribute>
      </element>
      <element name="preconditioner">
        <a:documentation>The Eisenstat method

This preconditioner is equivalent to SOR but only uses
half the number of flops,
i.e. same convergence rate but twice as fast per
iteration. Because it computes
a different preconditioned residual the convergence in
practice may be quite different though.
It does not work in parallel!</a:documentation>
        <attribute name="name">
          <value>eisenstat</value>
        </attribute>
      </element>
      <element name="preconditioner">
        <a:documentation>Incomplete LU decomposition</a:documentation>
        <attribute name="name">
          <value>ilu</value>
        </attribute>
      </element>
      <element name="preconditioner">
        <a:documentation>Incomplete Cholesky decomposition (only works for symmetric matrices)</a:documentation>
        <attribute name="name">
          <value>icc</value>
        </attribute>
      </element>
      <element name="preconditioner">
        <a:documentation>LU direct solver

This performs a complete, direct solve of the equation and should only be used in combination with preonly as iterative method.</a:documentation>
        <attribute name="name">
          <value>lu</value>
        </attribute>
      </element>
      <element name="preconditioner">
        <a:documentation>Fluidity`s own multigrid method

Especially suited for ill-conditioned, large aspect ratio problems.</a:documentation>
        <attribute name="name">
          <value>mg</value>
        </attribute>
        <optional>
          <element name="vertical_lumping">
            <a:documentation>apply vertical lumping from the full mesh to the surface mesh
as the first coarsening step instead of the default
aggregation method.</a:documentation>
            <optional>
              <element name="internal_smoother">
                <a:documentation>Does additional smoothing by solving the equation but with
a dirichilet boundary condition on top given by the last iteration
of the multigrid cycle. May be quite expensive per iteration
but improves the solution quite a lot for difficult meshes.</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
        </optional>
      </element>
      <element name="preconditioner">
        <a:documentation>Prometheus multigrid method</a:documentation>
        <attribute name="name">
          <value>prometheus</value>
        </attribute>
      </element>
      <element name="preconditioner">
        <a:documentation>Hypre preconditioners (includes boomeramg)</a:documentation>
        <attribute name="name">
          <value>hypre</value>
        </attribute>
        <choice>
          <element name="hypre_type">
            <a:documentation>BoomerAMG multigrid method</a:documentation>
            <attribute name="name">
              <value>boomeramg</value>
            </attribute>
          </element>
          <element name="hypre_type">
            <a:documentation>Other Hypre preconditioners</a:documentation>
            <attribute name="name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
          </element>
        </choice>
      </element>
      <element name="preconditioner">
        <a:documentation>Other preconditioners

Any preconditioner provided by the PETSc library
http://www-unix.mcs.anl.gov/petsc/petsc-2/snapshots/petsc-dev/docs/manualpages/PC/PCType.html
(available preconditiors may depend on the PETSc library installed on your system)</a:documentation>
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
      </element>
    </choice>
    <ref name="generic_solver_options"/>
  </define>
  <define name="generic_solver_options">
    <element name="relative_error">
      <a:documentation>Relative error

The solver finishes if the preconditioned error becomes smaller than the original preconditioned error times this value.
Suggested value: 1.0e-7</a:documentation>
      <ref name="real"/>
    </element>
    <optional>
      <element name="absolute_error">
        <a:documentation>Absolute error bound

The solver finishes if the preconditioned error becomes smaller than this value.</a:documentation>
        <ref name="real"/>
      </element>
    </optional>
    <element name="max_iterations">
      <a:documentation>Maximum number of iterations allowed in the linear solver
before giving up.</a:documentation>
      <ref name="integer"/>
    </element>
    <optional>
      <element name="start_from_zero">
        <a:documentation>Switch on to not use an initial guess from a previous solve but
start with a zero vector. Note that some of the solves always
start at zero in which case this switch will have no effect (see the log output).</a:documentation>
        <empty/>
      </element>
    </optional>
    <optional>
      <element name="remove_null_space">
        <a:documentation>Remove Null-space from residual after applying preconditioner.
This often leads to better convergence rates, when compared to
imposing a reference_node to pin the solution.</a:documentation>
        <empty/>
      </element>
    </optional>
    <optional>
      <element name="petsc_options">
        <a:documentation>Miscellaneous PETSc options

Any options not included above can be set using the PETSc option syntax
For example: -ksp_dtol 1e5 -ksp_monitor_draw</a:documentation>
        <data type="string" datatypeLibrary=""/>
      </element>
    </optional>
    <choice>
      <element name="never_ignore_solver_failures">
        <a:documentation>Solver failures are always treated as fatal errors. The
model stops at the end of the time step in order to allow
for the latest output to be written.</a:documentation>
        <empty/>
      </element>
      <element name="ignore_non_convergence_during_spin_up">
        <a:documentation>Allow for an initial period in which solver failures
caused by non-convergence in the maximum number of
iterations are ignored.</a:documentation>
        <element name="spin_up_time">
          <a:documentation>As long as current_time &lt; spin_up_time, solver failures
due to non-convergence in the maximum number of
iterations are ignored. This might be used for spinning
up the model. As there is no guarantee we're actually
solving the flow equations to any accuracy, the results
in this period should not be trusted.</a:documentation>
          <ref name="real"/>
        </element>
      </element>
      <element name="ignore_all_solver_failures">
        <a:documentation>Ignore all solver failures. This is a dangerous option
that should only be used in exceptional cases.</a:documentation>
        <empty/>
      </element>
    </choice>
    <element name="diagnostics">
      <a:documentation>Extra diagnostics to help debug solver problems</a:documentation>
      <optional>
        <element name="print_norms">
          <a:documentation>Print out the norm of vectors and matrices before the
solve, and that of the solution vector afterwards.
Norms are printed at verbosity level 2, so run fluidity with -v2 or -v3</a:documentation>
          <empty/>
        </element>
      </optional>
      <element name="monitors">
        <a:documentation>Options to give extra information for each iteration of the
the solve. Some of those may really slow down your computation!</a:documentation>
        <optional>
          <element name="preconditioned_residual">
            <a:documentation>Prints the preconditioned residual for each iteration of the solve.
This is the error estimation PETSc uses during the solve.</a:documentation>
            <empty/>
          </element>
        </optional>
        <optional>
          <element name="true_residual">
            <a:documentation>Prints the "true" residual for each iteration of the solve,
i.e. PETSc computes the L2-norm of r=A-bx. This may mean
PETSc has to do extra computations.</a:documentation>
            <empty/>
          </element>
        </optional>
        <optional>
          <element name="preconditioned_residual_graph">
            <a:documentation>Draws a graph over the convergence of the preconditioned residual
during the solve. This option only works for systems where PETSc
has been linked with the X library.</a:documentation>
            <empty/>
          </element>
        </optional>
        <optional>
          <element name="true_error">
            <a:documentation>Prints the error by computing the difference with the provided
exact solution each time step.</a:documentation>
            <attribute name="exact_solution_field">
              <a:documentation>Give the field name of the field that contains the exact
solution to be compared with each iteration</a:documentation>
              <data type="string" datatypeLibrary=""/>
            </attribute>
          </element>
        </optional>
      </element>
    </element>
  </define>
  <define name="input_choice_tensor_field">
    <choice>
      <element name="isotropic">
        <a:documentation>An isotropic tensor, i.e.
one with no directional variation.
Can be represented as a scalar real.</a:documentation>
        <ref name="input_choice_real"/>
      </element>
      <element name="anisotropic_symmetric">
        <a:documentation>A symmetric tensor, i.e.
A^T = A</a:documentation>
        <ref name="input_choice_real_dim_symmetric_tensor"/>
      </element>
      <element name="anisotropic_asymmetric">
        <a:documentation>A general asymmetric tensor.</a:documentation>
        <ref name="input_choice_real_dim_tensor"/>
      </element>
    </choice>
  </define>
  <define name="constitutive_laws">
    <choice>
      <element name="constitutive_law">
        <a:documentation>Constitutive laws for fluids</a:documentation>
        <attribute name="name">
          <value>fluid</value>
        </attribute>
      </element>
      <element name="constitutive_law">
        <a:documentation>Constitutive laws for solids</a:documentation>
        <attribute name="name">
          <value>solid</value>
        </attribute>
      </element>
    </choice>
  </define>
  <define name="region_ids">
    <optional>
      <element name="region_ids">
        <a:documentation>Optional region ids to associate different values
to different regions of the mesh.
Leave unselected if you`re not using multiple regions or
region_ids.
Currently only works with triangle files created by gmsh2triangle.</a:documentation>
        <ref name="integer_vector"/>
      </element>
    </optional>
  </define>
  <define name="temporal_control_volume_options">
    <element name="control_volumes">
      <a:documentation>Temporal discretisation options that are only relevant if a control volume or mixed control volume - continuous galerkin spatial discretisation is selected for this field.</a:documentation>
      <optional>
        <element name="number_advection_iterations">
          <a:documentation>Number of iterations within an advection solve.
This increases the accuracy of the face values and ensures that
the pivoted solution is cancelled out.
Defaults to 1 if unselected.</a:documentation>
          <ref name="integer"/>
          <optional>
            <element name="tolerance">
              <a:documentation>Cut short advection_iterations if the specified tolerance
is reached.
This only works for pure control volume discretisations.</a:documentation>
              <ref name="real"/>
              <choice>
                <element name="infinity_norm">
                  <a:documentation>Select the norm with which you want the tolerance to be tested.

The infinity norm.</a:documentation>
                  <empty/>
                </element>
                <element name="l2_norm">
                  <a:documentation>Select the norm with which you want the tolerance to be tested.

The l2 norm.</a:documentation>
                  <empty/>
                </element>
                <element name="cv_l2_norm">
                  <a:documentation>Select the norm with which you want the tolerance to be tested.

The l2 norm evaluated on a control volume mesh.</a:documentation>
                  <empty/>
                </element>
              </choice>
            </element>
          </optional>
        </element>
      </optional>
      <optional>
        <choice>
          <element name="maximum_courant_number_per_subcycle">
            <a:documentation>Use timestep subcycling to solve this equation.
Specify the maximum courant number per subcycle.
This only works for pure control volume discretisations.</a:documentation>
            <ref name="real"/>
            <ref name="field_based_cfl_number_options"/>
          </element>
          <element name="number_advection_subcycles">
            <a:documentation>Use timestep subcycling to solve this equation.
Specify the number of subcycles.
This only works for pure control volume discretisations.</a:documentation>
            <ref name="integer"/>
          </element>
        </choice>
      </optional>
      <optional>
        <element name="limit_theta">
          <a:documentation>Only works if a control volume or mixed control volume -
continuous galerkin spatial discretisation is selected.
If not active then the theta specified above will be used.
Otherwise use variable limited theta on individual faces.</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="pivot_theta">
          <a:documentation>Only works if a control volume or mixed control volume -
continuous galerkin spatial discretisation is selected.
Time discretisation of upwind discretisation off which the
higher order solution is pivotted.
 - pivot_theta = 1 - implicit pivot (default if not set and
                     best choice if not intentionally modifying
                     scheme to be explicit)
 - pivot_theta = 0 - explicit pivot</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="temporal_discontinuous_galerkin_options">
    <element name="discontinuous_galerkin">
      <a:documentation>This enables DG-specific timestepping options, such as
explicit advection subcycling. </a:documentation>
      <optional>
        <choice>
          <element name="maximum_courant_number_per_subcycle">
            <a:documentation>Use timestep subcycling to solve this equation.
Specify the maximum courant number per subcycle.</a:documentation>
            <ref name="real"/>
          </element>
          <element name="number_advection_subcycles">
            <a:documentation>Use timestep subcycling to solve this equation.
Specify the number of subcycles.</a:documentation>
            <ref name="integer"/>
          </element>
        </choice>
      </optional>
    </element>
  </define>
  <define name="legacy_mixed_cv_cg_options">
    <element name="legacy_mixed_cv_cg">
      <a:documentation>Use a mixed control volume - continuous galerkin
discretisation.

This uses a control volume discretisation of the advective
terms and a continuous galerkin representation of the
diffusion, source and absorption terms.
Clearly, in terms of discretisation this does the same thing
as a pure control volume discretisation if diffusion terms
are zero.
However it still follows a partially legacy code path.</a:documentation>
      <ref name="spatial_control_volume_options"/>
      <optional>
        <element name="legacy_disott">
          <a:documentation>Allows legacy options to be set.
BE WARNED: this probably means you're using inconsistent discretisations
on different terms - make sure you're happy with what your code path is doing
before selecting this.</a:documentation>
          <ref name="integer"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="pure_cv_options">
    <element name="control_volumes">
      <a:documentation>Use a pure control volume discretisations.
Follows a new control volume code path.</a:documentation>
      <ref name="spatial_control_volume_options"/>
      <choice>
        <element name="diffusion_scheme">
          <a:documentation>Use the gradient of the field constructed using the
basis functions of the parent finite element mesh to
form the divergence.

DOES NOT CURRENTLY WORK WITH ROBIN OR WEAK DIRICHLET BOUNDARY CONDITIONS!

Based on schemes in Handbook of Numerical Analysis,
P.G. Ciarlet, J.L. Lions eds, vol 7, pp 713-1020</a:documentation>
          <attribute name="name">
            <value>ElementGradient</value>
          </attribute>
        </element>
        <element name="diffusion_scheme">
          <a:documentation>Use an auxiliary gradient equation to find the gradient of the field.

DOES NOT CURRENTLY WORK WITH ROBIN BOUNDARY CONDITIONS!

Based on scheme proposed in Bassi, F. &amp; Rebay, S., A
high-order accurate discontinuous finite element method
for the numerical solution of the compressible
Navier-Stokes equations, Journal Of Computational
Physics, 1997, 131, 267-279</a:documentation>
          <attribute name="name">
            <value>BassiRebay</value>
          </attribute>
        </element>
      </choice>
    </element>
  </define>
  <define name="coupled_cv_options">
    <element name="coupled_cv">
      <a:documentation>Use a pure control volume discretisations with face value
restrictions between different fields in different material_phases.

THIS DOES NOT WORK WITH DIFFUSION!

Follows a new control volume code path.</a:documentation>
      <ref name="coupled_spatial_control_volume_options"/>
      <element name="parent_sum">
        <a:documentation>Set the maximum and minimum bounds for the sum up to and including this field.
This defines the limiter used to enforce boundedness on this field.</a:documentation>
        <element name="target_maximum">
          <ref name="real"/>
        </element>
        <element name="target_minimum">
          <ref name="real"/>
        </element>
      </element>
    </element>
  </define>
  <define name="spatial_control_volume_options">
    <ref name="standard_control_volume_options"/>
  </define>
  <define name="spatial_control_volume_options" combine="choice">
    <ref name="compressive_control_volume_options"/>
  </define>
  <define name="standard_control_volume_options">
    <choice>
      <element name="face_value">
        <a:documentation>First Order Upwind face value discretisation
 face_value = donor_value,
where
 donor_value = income*val_1 + (1.-income)*val_2,
where val_i is the value on the ith node neighbouring the face and
income = [0, 1] depending on whether the flow is coming from node 1 or 2
First order upwinding is monotonic so no limiting is ever required</a:documentation>
        <attribute name="name">
          <value>FirstOrderUpwind</value>
        </attribute>
        <empty/>
      </element>
      <element name="face_value">
        <a:documentation>Trapezoidal face value discretisation
 face_value = 0.5*(val_1 + val_2),
where
 val_i is the value on the ith node neighbouring the face

Trapezoidal discretisation is unbounded so limiting is compulsory</a:documentation>
        <attribute name="name">
          <value>Trapezoidal</value>
        </attribute>
        <ref name="limiter_options"/>
      </element>
      <element name="face_value">
        <a:documentation>Finite Element face value discretisation
 face_value = finite element interpolation from surrounding nodes

Finite element discretisation may become unbounded so limiting is often necessary.</a:documentation>
        <attribute name="name">
          <value>FiniteElement</value>
        </attribute>
        <optional>
          <ref name="limiter_options"/>
        </optional>
      </element>
    </choice>
  </define>
  <define name="coupled_spatial_control_volume_options">
    <ref name="coupled_control_volume_options"/>
  </define>
  <define name="coupled_spatial_control_volume_options" combine="choice">
    <ref name="compressive_control_volume_options"/>
  </define>
  <!--
    coupled control volume options are the same as the standard ones (annoyingly copied and pasted)
    except that firstorderupwind gets limiter options
  -->
  <define name="coupled_control_volume_options">
    <choice>
      <element name="face_value">
        <a:documentation>First Order Upwind face value discretisation
 face_value = donor_value,
where
 donor_value = income*val_1 + (1.-income)*val_2,
where val_i is the value on the ith node neighbouring the face and
income = [0, 1] depending on whether the flow is coming from node 1 or 2
First order upwinding is monotonic so no limiting is ever required</a:documentation>
        <attribute name="name">
          <value>FirstOrderUpwind</value>
        </attribute>
        <optional>
          <ref name="limiter_options"/>
        </optional>
      </element>
      <element name="face_value">
        <a:documentation>Trapezoidal face value discretisation
 face_value = 0.5*(val_1 + val_2),
where
 val_i is the value on the ith node neighbouring the face

Trapezoidal discretisation is unbounded so limiting is compulsory</a:documentation>
        <attribute name="name">
          <value>Trapezoidal</value>
        </attribute>
        <ref name="limiter_options"/>
      </element>
      <element name="face_value">
        <a:documentation>Finite Element face value discretisation
 face_value = finite element interpolation from surrounding nodes

Finite element discretisation may become unbounded so limiting is often necessary.</a:documentation>
        <attribute name="name">
          <value>FiniteElement</value>
        </attribute>
        <optional>
          <ref name="limiter_options"/>
        </optional>
      </element>
    </choice>
  </define>
  <define name="compressive_control_volume_options">
    <choice>
      <element name="face_value">
        <a:documentation>HyperC face value discretisation

face_value calculated from upper bound of explicit TVD zone of NVD diagram
Normally used for MaterialVolumeFraction fields</a:documentation>
        <attribute name="name">
          <value>HyperC</value>
        </attribute>
        <optional>
          <ref name="upwind_value_options"/>
        </optional>
        <ref name="cv_face_cfl_number_options"/>
      </element>
      <element name="face_value">
        <a:documentation>UltraC face value discretisation

face_value calculated from extended upper bound of
explicit TVD zone of NVD diagram assuming
values bounded by target_maximum and target_minimum.</a:documentation>
        <attribute name="name">
          <value>UltraC</value>
        </attribute>
        <element name="target_maximum">
          <a:documentation>Specifiy the upper bound which UltraC will use to
calculate the maximum flux.</a:documentation>
          <ref name="real"/>
        </element>
        <element name="target_minimum">
          <a:documentation>Specifiy the lower bound which UltraC will use to
calculate the minimum flux.</a:documentation>
          <ref name="real"/>
        </element>
        <optional>
          <ref name="upwind_value_options"/>
        </optional>
        <ref name="cv_face_cfl_number_options"/>
      </element>
      <element name="face_value">
        <a:documentation>**UNDER TESTING**

PotentialUltraC face value discretisation

face_value calculated from extended upper bound of
explicit TVD zone of NVD diagram if potential
value of field is sufficient (as specified by
target_maximum) to ensure the correct front advection
velocity.

If not then either switch to HyperC or use a modified flux
based on the potential function.</a:documentation>
        <attribute name="name">
          <value>PotentialUltraC</value>
        </attribute>
        <element name="target_maximum">
          <a:documentation>Specifiy the upper bound which PotentialUltraC will use
to calculate the maximum flux if the potential function
value is sufficient to maintain the correct front
advection velocity.</a:documentation>
          <ref name="real"/>
        </element>
        <element name="target_minimum">
          <a:documentation>Specifiy the lower bound which PotentialUltraC will use to calculate the minimum flux.</a:documentation>
          <ref name="real"/>
        </element>
        <choice>
          <element name="switch_to_hyperc">
            <a:documentation>Select what PotentialUltraC should do if the
potential function value does not reach the required
value specified by the target_maximum.

Switch to using HyperC face values.  This ensures
that the advection velocity is correct however may
create isolated regions beneath the target_maximum.</a:documentation>
            <empty/>
          </element>
          <element name="use_potential_flux">
            <a:documentation>Select what PotentialUltraC should do if the
potential function value does not reach the required
value specified by the target_maximum.

Modify the maximum nodal values (both downwind and
upwind) so that the fluxes are at their maximum
possible without affecting the front advection
velocity.</a:documentation>
            <empty/>
          </element>
        </choice>
        <optional>
          <ref name="upwind_value_options"/>
        </optional>
        <ref name="cv_face_cfl_number_options"/>
      </element>
    </choice>
  </define>
  <!--
    Select the type of dynamic control to be used
    Note: DEM and FEMDEM require the respective libraries
    to be compiled.
  -->
  <define name="input_solid_dynamics_choice">
    <choice>
      <element name="dynamic_type">
        <a:documentation>Obtain values from point and radius file.

First line of file is free to use (for comments)
Second line must contain the number of particles
Third and fourth line are again for comments.
Following lines include 10 columns, corresponding to
the particle's x, y, and z positions, followed by the radius, then
velocities in x, y, and z directions, followed by angular velocities
in the x, y, and z directions.</a:documentation>
        <attribute name="name">
          <value>from_input_file</value>
        </attribute>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
      </element>
      <element name="dynamic_type">
        <a:documentation>Two python scripts must be provided. The script is cycled over each particle.
One script for particle position (output is tuple of position coords)
Second script is for particle radius (output is tuple of position coords)
Third script is for particle translational velocity.
Fourth script is for particle angular velocity. (Note: particles
have a no slip boundary condition at the surface, so this angular velocity
WILL matter to the flow.)
Python functions should be of the form:
 def val(X, t):
   Function code
   return # Return value
where X is a tuple of length geometry dimension.
   X[0] contains the number of the particle (in real format)</a:documentation>
        <attribute name="name">
          <value>python_script</value>
        </attribute>
      </element>
      <element name="dynamic_type">
        <attribute name="name">
          <value>use_simple_dynamics</value>
        </attribute>
        <element name="set_bottom">
          <ref name="real"/>
        </element>
        <element name="set_xmin">
          <ref name="real"/>
        </element>
        <element name="set_ymin">
          <ref name="real"/>
        </element>
        <element name="set_zmin">
          <ref name="real"/>
        </element>
        <element name="set_xmax">
          <ref name="real"/>
        </element>
        <element name="set_ymax">
          <ref name="real"/>
        </element>
        <element name="set_zmax">
          <ref name="real"/>
        </element>
      </element>
      <element name="dynamic_type">
        <a:documentation>Using y3D to model dynamics. Filename of input file for y3D must
be specified.</a:documentation>
        <attribute name="name">
          <value>use_y3D</value>
        </attribute>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
      </element>
      <element name="dynamic_type">
        <a:documentation>Using femdem 2D to model dynamics. Filename of input file must
be specified.</a:documentation>
        <attribute name="name">
          <value>use_2Dfemdem</value>
        </attribute>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
      </element>
      <element name="dynamic_type">
        <a:documentation>Using femdem 3D to model dynamics. Filename of input file must
be specified.</a:documentation>
        <attribute name="name">
          <value>use_3Dfemdem</value>
        </attribute>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
        <element name="quad2lin">
          <attribute name="file_name">
            <data type="string"/>
          </attribute>
        </element>
      </element>
    </choice>
  </define>
  <define name="cap_option">
    <element name="cap_values">
      <a:documentation>Cap the min and max values of this field when using
it as a volume fraction to work out bulk material
properties.
No capping used if not selected.</a:documentation>
      <optional>
        <element name="upper_cap">
          <a:documentation>Set the upper bound on the field.
Defaults to huge(0.0)*epsilon(0.0) if not set.</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
      <optional>
        <element name="lower_cap">
          <a:documentation>Set the lower bound on the field.
Defaults to -huge(0.0)*epsilon(0.0) if not set.</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="surface_tension_option">
    <element name="surface_tension">
      <element name="surface_tension_coefficient">
        <a:documentation>Surface tension coefficient</a:documentation>
        <ref name="real"/>
      </element>
      <optional>
        <element name="equilibrium_contact_angle">
          <a:documentation>The equilibrium contact angle (in radians) with the boundaries identified by the surface ids</a:documentation>
          <ref name="real"/>
          <element name="surface_ids">
            <a:documentation>Surface ids:</a:documentation>
            <ref name="integer_vector"/>
          </element>
        </element>
      </optional>
    </element>
  </define>
  <define name="limiter_options">
    <element name="limit_face_value">
      <a:documentation>Limit the face value to satisfy a boundedness criterion.</a:documentation>
      <choice>
        <ref name="sweby_limiter"/>
        <ref name="ultimate_limiter"/>
      </choice>
    </element>
  </define>
  <define name="sweby_limiter">
    <element name="limiter">
      <a:documentation>See "High-Resolution Schemes Using Flux Limiters for
Hyperblic Conservation-Laws", P. K. Sweby, 1984, Siam
Journal on Numerical Analysis, 21, 995-1011</a:documentation>
      <attribute name="name">
        <value>Sweby</value>
      </attribute>
      <optional>
        <ref name="slope_options"/>
      </optional>
      <optional>
        <ref name="upwind_value_options"/>
      </optional>
    </element>
  </define>
  <define name="ultimate_limiter">
    <element name="limiter">
      <a:documentation>See "The Ultimate Conservative Difference Scheme Applied
to Unsteady One-Dimensional Advection", B. P. Leonard,
1991, Computer Methods in Applied Mechanics and
Engineering, 88, 17-74</a:documentation>
      <attribute name="name">
        <value>Ultimate</value>
      </attribute>
      <ref name="field_based_cfl_number_options"/>
      <optional>
        <ref name="upwind_value_options"/>
      </optional>
    </element>
  </define>
  <define name="slope_options">
    <element name="slopes">
      <a:documentation>Control the upper and lower slopes of the NVD limiter</a:documentation>
      <optional>
        <element name="lower">
          <a:documentation>Defaults to Sweby, 1984 limiter (= 1.0) if unselected</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
      <optional>
        <element name="upper">
          <a:documentation>Defaults to Sweby, 1984 limiter (= 2.0) if unselected</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="upwind_value_options">
    <choice>
      <element name="project_upwind_value_from_point">
        <a:documentation>Select the method to be used for calculating the upwind value.
If not selected will default to project_upwind_value_from_point for
simplex element meshes and to a locally_bound_upwind_value for cube
element meshes.

This method projects the upwind value from a point in the element just
upwind of the node pair straddling the face.  It is otherwise known as
anisotropic limiting.
This is only available on simplex meshes as it involes a search around
the donor node to find the upwind element.</a:documentation>
        <optional>
          <element name="reflect_off_domain_boundaries">
            <a:documentation>When the donor node is on a domain boundary reflect the projection
back into the mesh.</a:documentation>
            <empty/>
          </element>
        </optional>
        <optional>
          <element name="bound_projected_value_locally">
            <a:documentation>Constrain the projected value to be between the min and max of the
element values which it was found from.</a:documentation>
            <empty/>
          </element>
        </optional>
        <optional>
          <element name="store_upwind_elements">
            <a:documentation>Store the locations of the elements where the upwind values
are projected from for each node pair.
This inserts an integer csr matrix into state so is memory expensive but
saves a significant amount of time (searching around the neighbouring elements).
This is unsafe for moving meshes but should be ok for adaptive meshes.</a:documentation>
            <optional>
              <element name="store_upwind_quadrature">
                <a:documentation>Store the quadrature locations within the elements
where the upwind values
are projected from for each node pair.
This inserts a real block csr matrix into state so is even more memory
expensive than just storing the upwind elements and
only saves a comparitively
marginal amount of time (as actually searching the
neighbouring elements is the
slowest bit, finding the quadrature is relatively easy).</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
        </optional>
      </element>
      <element name="project_upwind_value_from_gradient">
        <a:documentation>Select the method to be used for calculating the upwind value.
If not selected will default to project_upwind_value_from_point for
simplex element meshes and to a locally_bound_upwind_value for cube
element meshes.

Projects the value of the advected variable from the downwind or donor node
using the interpolated gradient at the donor node in the
direction of the vector
connecting the node pair straddling the face.
This is available on all meshes (except if bounding the values).</a:documentation>
        <choice>
          <element name="project_from_downwind_value">
            <a:documentation>Select which node to project from:
Project from the downwind node (Jasak et al., 1999) so that:
upwind_value = downwind_value - 2*gradient.vector</a:documentation>
            <ref name="comment"/>
          </element>
          <element name="project_from_donor_value">
            <a:documentation>Select which node to project from:
Project from the donor node so that:
upwind_value = donor_value - gradient.vector</a:documentation>
            <ref name="comment"/>
          </element>
        </choice>
        <optional>
          <element name="reflect_off_domain_boundaries">
            <a:documentation>When the donor node is on a domain boundary reflect the projection
back into the mesh.</a:documentation>
            <empty/>
          </element>
        </optional>
        <optional>
          <element name="bound_projected_value_locally">
            <a:documentation>Constrain the projected value to be between the min and max of the
element values which surround it.
This is only available on simplex meshes as it involes a search around
the donor node to find the upwind element.</a:documentation>
            <optional>
              <element name="store_upwind_elements">
                <a:documentation>Store the locations of the elements closest to the project value.
This inserts an integer csr matrix into state so is
memory expensive but
saves a significant amount of time (searching around
the neighbouring elements).
This is unsafe for moving meshes but should be ok for adaptive meshes.</a:documentation>
                <ref name="comment"/>
              </element>
            </optional>
          </element>
        </optional>
      </element>
      <element name="locally_bound_upwind_value">
        <a:documentation>Select the method to be used for calculating the upwind value.
If not selected will default to project_upwind_value_from_point for
simplex element meshes and to a locally_bound_upwind_value for cube
element meshes.

Chooses an upwind value by selecting the maximum or minimum of the neighbouring
nodes depending on the local slope of the donor and downwind values.
Otherwise known as isotropic limiting.
This is available on all meshes.</a:documentation>
        <empty/>
      </element>
      <element name="pseudo_structured_upwind_value">
        <a:documentation>Select the method to be used for calculating the upwind value.
If not selected will default to project_upwind_value_from_point for
simplex element meshes and to a locally_bound_upwind_value for cube
element meshes.

Chooses an upwind value by selecting the value at the node most directy
upwind from the vector connecting the donor and downwind nodes.
This is available on all meshes.</a:documentation>
        <empty/>
      </element>
    </choice>
  </define>
  <define name="field_based_cfl_number_options">
    <choice>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used.

This uses the control volume definition of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>ControlVolumeCFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>***UNDER TESTING***

Select the Courant Number definition to be used.

This uses the control volume definition of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>CVMaterialDensityCFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used.

This uses the finite element approximation of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>CFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used.</a:documentation>
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
        <empty/>
      </element>
    </choice>
  </define>
  <define name="cv_face_cfl_number_options">
    <choice>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used in the slope of
the NVD diagram upper bound.
This uses the finite difference definition of the CFL Number
consistent with the 1D version of HyperC (Leonard, 1981).
This is the default that reproduces old behaviour.
All others are under testing or construction.</a:documentation>
        <attribute name="name">
          <value>FiniteDifferenceCFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used in the slope of
the NVD diagram upper bound.
This uses the control volume definition of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>ControlVolumeCFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>***UNDER TESTING***

Select the Courant Number definition to be used in the slope of
the NVD diagram upper bound.
This uses a control volume definition of the CFL Number
that incorporates the MaterialDensity.
Requires a MaterialDensity field in this material_phase!</a:documentation>
        <attribute name="name">
          <value>CVMaterialDensityCFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>***UNDER TESTING***

Select the Courant Number definition to be used in the slope of
the NVD diagram upper bound.
This uses the finite element approximation of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>CFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>***UNDER TESTING***

Select the Courant Number definition to be used in the slope of
the NVD diagram upper bound.</a:documentation>
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
        <empty/>
      </element>
    </choice>
  </define>
  <define name="timestep_cfl_number_options">
    <choice>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used for adaptive timestepping.
This uses the finite element approximation of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>CFLNumber</value>
        </attribute>
        <ref name="velocity_mesh_choice">
          <a:documentation>Select the mesh on which you wish to evaluate the CFLNumber.</a:documentation>
        </ref>
      </element>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used for adaptive timestepping.
This uses the control volume definition of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>ControlVolumeCFLNumber</value>
        </attribute>
        <ref name="velocity_mesh_choice">
          <a:documentation>Select the mesh on which you wish to evaluate the ControlVolumeCFLNumber.</a:documentation>
        </ref>
      </element>
    </choice>
  </define>
  <define name="mixing_stats">
    <element name="include_mixing_stats">
      <a:documentation>Enable to include in the .stat file the fractions of the
scalar field contained in
bins specified by the user. This allows mixing of the field to be quantified.
Replaces and expands upon the old heaviside.dat file</a:documentation>
      <attribute name="name">
        <data type="string"/>
      </attribute>
      <choice>
        <element name="continuous_galerkin">
          <a:documentation>Select whether to evaluate the volume fraction over the finite element
(continuous galerkin) or within the control volume (control_volumes).

NOTE: continuous_galerkin only works with linear tets

NOTE: continuous_galerkin is not fully validated yet</a:documentation>
          <optional>
            <element name="normalise">
              <a:documentation>if select normalise the volume fractions will be
divided by the total volume of the domain</a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
        <element name="control_volumes">
          <a:documentation>Select whether to evaluate the volume fraction over the finite element
(continuous galerkin) or within the control volume (control_volumes).</a:documentation>
          <optional>
            <element name="normalise">
              <a:documentation>if select normalise the volume fractions will be divided by the total volume of the domain  </a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
      </choice>
      <element name="mixing_bin_bounds">
        <a:documentation>The values of the bounds of the bins
e.g. the values 0 1 2 3 will return 4 bins
and the fraction of the field in each bin with,
0&lt;=field&lt;1, 1&lt;=field&lt;2, 2&lt;=field&lt;3, 3&lt;=field,
will be calculated. </a:documentation>
        <ref name="real_vector"/>
      </element>
      <optional>
        <element name="tolerance">
          <a:documentation>Define the tolerance beneath the specified bins that should be included.
Defaults to zero at machine tolerance (epsilon(0.0)) if not selected.</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="cv_stats">
    <element name="include_cv_stats">
      <a:documentation>Include statistics evaluated on the control volume mesh.</a:documentation>
      <empty/>
    </element>
  </define>
  <!-- Options for inclusion of calculations of surface integrals in the .stat file   -->
  <define name="surface_integral_stats_base.surface_integral">
    <attribute name="name">
      <data type="string"/>
    </attribute>
    <optional>
      <element name="surface_ids">
        <a:documentation>Surface IDs defining the surface over which to integrate. If disabled, integrates over the whole surface.</a:documentation>
        <ref name="integer_vector"/>
      </element>
    </optional>
    <optional>
      <element name="normalise">
        <a:documentation>Enable to normalise the integral by dividing by the surface area</a:documentation>
        <ref name="comment"/>
      </element>
    </optional>
  </define>
  <define name="surface_integral_stats_scalar">
    <element name="surface_integral">
      <a:documentation>Surface integral calculations. The following integral types are available:
 value: Integrates the field
 gradient_normal: Integrates the normal component of the gradient of the field</a:documentation>
      <ref name="surface_integral_stats_scalar.surface_integral"/>
    </element>
  </define>
  <define name="surface_integral_stats_scalar.surface_integral">
    <ref name="surface_integral_stats_base.surface_integral"/>
  </define>
  <define name="surface_integral_stats_scalar.surface_integral" combine="interleave">
    <attribute name="type">
      <choice>
        <value>value</value>
        <value>gradient_normal</value>
      </choice>
    </attribute>
  </define>
  <define name="surface_integral_stats_vector">
    <element name="surface_integral">
      <a:documentation>Surface integral calculations. The following integral types are available:
 normal: Integrates the normal component of the field</a:documentation>
      <ref name="surface_integral_stats_vector.surface_integral"/>
    </element>
  </define>
  <define name="surface_integral_stats_vector.surface_integral">
    <ref name="surface_integral_stats_base.surface_integral"/>
  </define>
  <define name="surface_integral_stats_vector.surface_integral" combine="interleave">
    <attribute name="type">
      <value>normal</value>
    </attribute>
  </define>
  <define name="velocity_equation_choice">
    <choice>
      <element name="equation">
        <a:documentation>Select the equation used to solve for velocity.
LinearMomentum is the norm and works for all discretisation types.</a:documentation>
        <attribute name="name">
          <value>LinearMomentum</value>
        </attribute>
      </element>
      <element name="equation">
        <a:documentation>Select the equation used to solve for velocity.
Boussinesq only works for continuous_galerkin and discontinuous_galerkin.</a:documentation>
        <attribute name="name">
          <value>Boussinesq</value>
        </attribute>
      </element>
      <element name="equation">
        <a:documentation>Select the equation used to solve for velocity.
Drainage only works for continuous_galerkin and discontinuous_galerkin.</a:documentation>
        <attribute name="name">
          <value>Drainage</value>
        </attribute>
      </element>
    </choice>
  </define>
  <define name="scalar_equation_choice">
    <choice>
      <element name="equation">
        <a:documentation>Select the equation used to solve for this field.
Advection Diffusion is the norm for scalar fields.
Works for all discretisation types.</a:documentation>
        <attribute name="name">
          <value>AdvectionDiffusion</value>
        </attribute>
      </element>
      <element name="equation">
        <a:documentation>***UNDER TESTING***

Select the equation used to solve for this field.
Conservation of Mass equation - requires the selection of a Density field.
ONLY WORKS FOR CONTROL VOLUME DISCRETISATIONS WITHOUT A
DIFFUSIVITY, SOURCE OR ABSORPTION.</a:documentation>
        <attribute name="name">
          <value>ConservationOfMass</value>
        </attribute>
        <choice>
          <element name="density">
            <a:documentation>Select density to use in the Conservation of Mass Equation
Use the MaterialDensity - useful for multimaterial simulations
Clearly this requires a MaterialDensity field to be present</a:documentation>
            <attribute name="name">
              <value>MaterialDensity</value>
            </attribute>
          </element>
          <element name="density">
            <a:documentation>Select density to use in the Conservation of Mass Equation
Use the bulk Density
Clearly this requires a Density field to be present</a:documentation>
            <attribute name="name">
              <value>Density</value>
            </attribute>
          </element>
          <element name="density">
            <a:documentation>Select density to use in the Conservation of Mass Equation</a:documentation>
            <attribute name="name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
          </element>
        </choice>
      </element>
      <element name="equation">
        <a:documentation>***UNDER TESTING***

Select the equation used to solve for this field.
Reduced Conservation of Mass equation - requires the selection of a Density field.

ONLY WORKS FOR CONTROL VOLUME DISCRETISATIONS WITHOUT A
DIFFUSIVITY, SOURCE OR ABSORPTION.

This equation is very similar to a standard conservation of mass equation
except that the time discretisation uses only a single time level of density.
This enables consistency between the
MaterialVolumeFraction (ReducedConservationOfMass) and
MaterialDensity (Advection) equations in compressible multimaterial simulations.</a:documentation>
        <attribute name="name">
          <value>ReducedConservationOfMass</value>
        </attribute>
        <choice>
          <element name="density">
            <a:documentation>Select density to use in the Reduced Conservation of Mass Equation
Use the MaterialDensity - useful for multimaterial simulations
Clearly this requires a MaterialDensity field to be present</a:documentation>
            <attribute name="name">
              <value>MaterialDensity</value>
            </attribute>
          </element>
          <element name="density">
            <a:documentation>Select density to use in the Reduced Conservation of Mass Equation
Use the bulk Density
Clearly this requires a Density field to be present</a:documentation>
            <attribute name="name">
              <value>Density</value>
            </attribute>
          </element>
          <element name="density">
            <a:documentation>Select density to use in the Reduced Conservation of Mass Equation</a:documentation>
            <attribute name="name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
          </element>
        </choice>
      </element>
      <element name="equation">
        <a:documentation>***UNDER TESTING***

Select the equation used to solve for this field.
Internal Energy equation - requires the selection of a Density field.
ONLY WORKS FOR CONTROL VOLUME DISCRETISATIONS WITHOUT A
DIFFUSIVITY, SOURCE OR ABSORPTION.
Solve the internal energy equation for this field.
Requires pressure and velocity fields to be present.
Uses a nonconservative time discretisation.</a:documentation>
        <attribute name="name">
          <value>InternalEnergy</value>
        </attribute>
        <choice>
          <element name="density">
            <a:documentation>Select density to use in the Internal Energy Equation
Use the MaterialDensity - useful for multimaterial simulations
Clearly this requires a MaterialDensity field to be present
Whatever field is selected must be present.</a:documentation>
            <attribute name="name">
              <value>MaterialDensity</value>
            </attribute>
          </element>
          <element name="density">
            <a:documentation>Select density to use in the Internal Energy Equation
Use the bulk Density
Clearly this requires a Density field to be present
Whatever field is selected must be present.</a:documentation>
            <attribute name="name">
              <value>Density</value>
            </attribute>
          </element>
          <element name="density">
            <a:documentation>Select density to use in the Internal Energy Equation
Whatever field is selected must be present.</a:documentation>
            <attribute name="name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
          </element>
        </choice>
      </element>
      <element name="equation">
        <a:documentation>Option to solve for electrical potential from
electrokinetic, electrochemical or electrothermal sources </a:documentation>
        <attribute name="name">
          <value>ElectricalPotential</value>
        </attribute>
      </element>
    </choice>
  </define>
  <define name="inner_element_scalar">
    <element name="inner_element">
      <a:documentation>Inner element sub-grid scale model (Candy and Pain)
Requires continuous galerkin selected above.</a:documentation>
      <element name="scalar_field">
        <a:documentation>Inner element solution of the scalar field.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>InnerElement</value>
        </attribute>
        <element name="prognostic">
          <element name="mesh">
            <attribute name="name">
              <value>InnerElementMesh</value>
            </attribute>
          </element>
          <ref name="prognostic_scalar_output_options"/>
          <ref name="prognostic_scalar_stat_options"/>
          <ref name="prognostic_detector_options"/>
        </element>
      </element>
    </element>
  </define>
  <define name="inner_element_velocity">
    <optional>
      <element name="inner_element">
        <a:documentation>Inner element sub-grid scale model (Candy and Pain)
Requires continuous galerkin selected above.</a:documentation>
        <element name="vector_field">
          <a:documentation>SGS velocity in an inner element SGS treatment of momentum

Limitations:
 - Requires a geometry dimension of 3.
 - Requires inner element active for momentum</a:documentation>
          <attribute name="rank">
            <value>1</value>
          </attribute>
          <attribute name="name">
            <value>InnerElement</value>
          </attribute>
          <element name="prognostic">
            <element name="mesh">
              <attribute name="name">
                <value>InnerElementMesh</value>
              </attribute>
            </element>
            <ref name="prognostic_vector_output_options"/>
            <ref name="prognostic_vector_stat_options"/>
            <ref name="vector_convergence_options"/>
          </element>
        </element>
        <optional>
          <element name="use_filter">
            <a:documentation>A filter for the sub-grid scale equations
Add diffusion to matrix D of the Inner Element model</a:documentation>
            <element name="strength">
              <a:documentation>Strength of the diffusion term
Suggested value: 0.01</a:documentation>
              <ref name="real"/>
            </element>
            <empty/>
          </element>
        </optional>
        <optional>
          <element name="use_quadratic_pressure">
            <empty/>
          </element>
        </optional>
        <optional>
          <element name="apply_full_discontinuous_Galerkin">
            <empty/>
          </element>
        </optional>
      </element>
    </optional>
  </define>
  <define name="forcing">
    <element name="ocean_forcing">
      <a:documentation>Add forcing from ocean data
If you enable this you MUST enable the /geometry/ocean_boundaries option too</a:documentation>
      <element name="input_file">
        <a:documentation>The netCDF data file downloaded from ERA-40 reanalysis</a:documentation>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
      </element>
      <element name="mesh_choice">
        <ref name="velocity_mesh_choice"/>
      </element>
      <optional>
        <element name="surface_stress">
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="temperature_flux">
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="salinity_flux">
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="solar_radiation">
          <empty/>
        </element>
      </optional>
    </element>
  </define>
  <define name="biology">
    <element name="ocean_biology">
      <a:documentation>Model of biological processes in the ocean.</a:documentation>
      <element name="pznd">
        <a:documentation>A simple model of phytoplankton, zooplankton, general nutrient and detritus. </a:documentation>
        <choice>
          <element name="source_and_sink_algorithm">
            <a:documentation>Python code specifying the source and sink relationships
between the biological tracers. This is usually achieved by
importing fluidity.ocean_biology and calling a scheme from there. </a:documentation>
            <ref name="python_code"/>
          </element>
          <element name="disable_sources_and_sinks">
            <a:documentation>Do not calculate sources and sinks.
This option is generally only useful for testing. </a:documentation>
            <empty/>
          </element>
        </choice>
        <!--
                     ## Phytoplankton
                     element scalar_field {
                        attribute rank { "0" },
                        attribute name { "Phytoplankton" },
                        (
                           element prognostic {
                              velocity_mesh_choice,
                              prognostic_scalar_field
                           }|
                           element prescribed {
                              velocity_mesh_choice,
                              prescribed_scalar_field
                           }
                        )
                     },
                     ## Zooplankton
                     element scalar_field {
                        attribute rank { "0" },
                        attribute name { "Zooplankton" },
                        (
                           element prognostic {
                              velocity_mesh_choice,
                              prognostic_scalar_field
                           }|
                           element prescribed {
                              velocity_mesh_choice,
                              prescribed_scalar_field
                           }
                        )
                     },
                     ## Nutrient
                     element scalar_field {
                        attribute rank { "0" },
                        attribute name { "Nutrient" },
                        (
                           element prognostic {
                              velocity_mesh_choice,
                              prognostic_scalar_field
                           }|
                           element prescribed {
                              velocity_mesh_choice,
                              prescribed_scalar_field
                           }
                        )
                     },
                     ## Detritus
                     element scalar_field {
                        attribute rank { "0" },
                        attribute name { "Detritus" },
                        (
                           element prognostic {
                              velocity_mesh_choice,
                              prognostic_scalar_field
                           }|
                           element prescribed {
                              velocity_mesh_choice,
                              prescribed_scalar_field
                           }
                        )
                     },
        -->
        <element name="scalar_field">
          <a:documentation>Photosynthetically Active Radiation (PAR)</a:documentation>
          <attribute name="rank">
            <value>0</value>
          </attribute>
          <attribute name="name">
            <value>PhotosyntheticRadiation</value>
          </attribute>
          <choice>
            <element name="prognostic">
              <ref name="velocity_mesh_choice"/>
              <ref name="prognostic_photosynthetic_radiation"/>
            </element>
            <element name="prescribed">
              <ref name="velocity_mesh_choice"/>
              <ref name="prescribed_scalar_field"/>
            </element>
          </choice>
        </element>
      </element>
    </element>
  </define>
  <define name="prognostic_photosynthetic_radiation">
    <element name="equation">
      <a:documentation>PAR equation.</a:documentation>
      <attribute name="name">
        <value>PhotosyntheticRadiation</value>
      </attribute>
    </element>
    <element name="spatial_discretisation">
      <a:documentation>Spatial discretisation options</a:documentation>
      <element name="discontinuous_galerkin">
        <a:documentation>Discontinuous galerkin formulation. You can also use this
formulation with a continuous field in which case a simple
galerkin formulation will result. </a:documentation>
        <empty/>
      </element>
    </element>
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options_asym"/>
    </element>
    <element name="absorption_coefficients">
      <a:documentation>Coefficients of absorption of photosynthetically active
radiation for water and phytoplankton.</a:documentation>
      <element name="water">
        <a:documentation>Photosynthetically active radiation absorption coefficient for water.</a:documentation>
        <ref name="real"/>
      </element>
      <element name="phytoplankton">
        <a:documentation>Photosynthetically active radiation absorption coefficient for water.</a:documentation>
        <ref name="real"/>
      </element>
    </element>
    <oneOrMore>
      <element name="boundary_conditions">
        <a:documentation>Boundary conditions</a:documentation>
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
        <element name="surface_ids">
          <a:documentation>Surface id:</a:documentation>
          <ref name="integer_vector"/>
        </element>
        <choice>
          <a:documentation>Type</a:documentation>
          <element name="type">
            <attribute name="name">
              <value>dirichlet</value>
            </attribute>
            <element name="apply_weakly">
              <a:documentation>Apply the dirichlet bc weakly.  Only available with
discontinuous_galerkin, control_volume and
legacy_mixed_cv_cg spatial_discretisations.

If not selected boundary conditions are applied strongly.</a:documentation>
              <empty/>
            </element>
            <ref name="input_choice_real"/>
          </element>
          <element name="type">
            <attribute name="name">
              <value>neumann</value>
            </attribute>
            <ref name="input_choice_real"/>
          </element>
          <element name="type">
            <attribute name="name">
              <value>robin</value>
            </attribute>
            <element name="order_zero_coefficient">
              <ref name="input_choice_real"/>
            </element>
            <element name="order_one_coefficient">
              <ref name="input_choice_real"/>
            </element>
          </element>
        </choice>
      </element>
    </oneOrMore>
    <ref name="prognostic_scalar_output_options"/>
    <ref name="prognostic_scalar_stat_options"/>
    <ref name="scalar_convergence_options"/>
    <ref name="prognostic_detector_options"/>
    <ref name="scalar_steady_state_options"/>
    <ref name="adaptivity_options_scalar_field"/>
    <optional>
      <element name="priority">
        <a:documentation>Set the priority of this field
This determines the order in which scalar_fields are solved for:
 - higher numbers have the highest priority
 - lower numbers (including negative) have the lowest priority
 - default if not set is 0</a:documentation>
        <ref name="integer"/>
      </element>
    </optional>
  </define>
  <define name="recalculation_options">
    <element name="do_not_recalculate">
      <a:documentation>Prevent this field from being recalculated at every timestep.
This is cheaper especially if you are enforcing discrete properties on the field.</a:documentation>
      <empty/>
    </element>
  </define>
  <define name="discrete_properties_algorithm_scalar">
    <element name="enforce_discrete_properties">
      <a:documentation>Select discrete properties to enforce on the field
either after being prescribed or interpolated</a:documentation>
      <optional>
        <element name="solenoidal_lagrange_update">
          <a:documentation>Update this field using the lagrangian multiplier
calculated in the solenoidal projection of a
scalar field.

Note this field must be specified as the update field
underneath that vector field too.

Note also this only really makes sense for coupled
fields like velocity and pressure.</a:documentation>
          <empty/>
        </element>
      </optional>
    </element>
  </define>
  <define name="discrete_properties_algorithm_vector">
    <element name="enforce_discrete_properties">
      <a:documentation>Select discrete properties to enforce on the field
either after being prescribed or interpolated</a:documentation>
      <optional>
        <ref name="solenoidal_options"/>
      </optional>
    </element>
  </define>
  <define name="interpolation_algorithm_disabled">
    <element name="no_interpolation">
      <a:documentation>Disable interpolation</a:documentation>
      <ref name="comment"/>
    </element>
  </define>
  <define name="interpolation_algorithm_scalar">
    <choice>
      <element name="consistent_interpolation">
        <a:documentation>Basis function interpolation.
The standard algorithm. It is quick
and bounded, but non-conservative and dissipative.
All other algorithms require construction of a supermesh.</a:documentation>
        <empty/>
      </element>
      <element name="galerkin_projection">
        <a:documentation>Galerkin projection. By default, conservative, non-dissipative and
non-bounded. The most accurate choice, in the sense of minimising
the L2 norm of the residual</a:documentation>
        <ref name="galerkin_projection_scalar"/>
      </element>
    </choice>
  </define>
  <define name="interpolation_algorithm_scalar_full">
    <ref name="interpolation_algorithm_scalar"/>
  </define>
  <define name="interpolation_algorithm_scalar_full" combine="choice">
    <ref name="interpolation_algorithm_disabled"/>
  </define>
  <define name="interpolation_algorithm_vector">
    <choice>
      <element name="consistent_interpolation">
        <a:documentation>Basis function interpolation.
The standard algorithm. It is quick
and bounded, but non-conservative and dissipative.
All other algorithms require construction of a supermesh.</a:documentation>
        <ref name="consistent_interpolation_vector"/>
      </element>
      <element name="galerkin_projection">
        <a:documentation>Galerkin projection. By default, conservative, non-dissipative and
non-bounded. The most accurate choice, in the sense of minimising
the L2 norm of the residual</a:documentation>
        <ref name="galerkin_projection_vector"/>
      </element>
    </choice>
  </define>
  <define name="consistent_interpolation_vector">
    <optional>
      <ref name="balanced_interpolation"/>
    </optional>
  </define>
  <define name="galerkin_projection_vector">
    <ref name="continuous_discontinuous_projection"/>
    <optional>
      <ref name="balanced_interpolation"/>
    </optional>
    <optional>
      <ref name="supermesh_free"/>
    </optional>
    <optional>
      <ref name="supermesh_conservation"/>
    </optional>
  </define>
  <define name="galerkin_projection_scalar">
    <ref name="continuous_discontinuous_projection"/>
    <optional>
      <ref name="supermesh_free"/>
    </optional>
    <optional>
      <ref name="supermesh_conservation"/>
    </optional>
  </define>
  <define name="continuous_discontinuous_projection">
    <choice>
      <element name="continuous">
        <a:documentation>Continuous field Galerkin projection.
If the field you are interpolating is continuous, then
a linear solver is required to invert the mass matrix.</a:documentation>
        <optional>
          <element name="bounded">
            <a:documentation>Use a bounded Galerkin projection. Conservative, bounded in the
limit, and minimally dissipative. This algorithm starts with the
Galerkin projection and dissipates it until it achieves
boundedness.
If it does not converge, it may not be exactly bounded.
Note well: this only works for linear fields.</a:documentation>
            <attribute name="name">
              <value>Diffuse</value>
            </attribute>
            <element name="boundedness_iterations">
              <a:documentation>The number of dissipation iterations attempted to bound the
Galerkin projection.</a:documentation>
              <ref name="integer"/>
              <optional>
                <element name="tolerance">
                  <a:documentation>Specify the tolerance to which boundedness is to be tested.
Defaults to computer precision if unspecified.</a:documentation>
                  <ref name="real"/>
                </element>
              </optional>
            </element>
            <optional>
              <element name="bounds">
                <a:documentation>If the bounds on this field are known then they can be set here.
These can either further constrain the limits worked out by the
lumped version of the projection (i.e. to make sure that errors
don't accumulate with succesive interpolations) or if apply_globally
is set they are just made to be bounded within the bounds globally
(i.e. anything between those bounds is not smoothed).</a:documentation>
                <optional>
                  <element name="upper_bound">
                    <ref name="real"/>
                    <optional>
                      <element name="apply_globally">
                        <a:documentation>If this is set the upper_bound is used everywhere.
If left unset the upper_bound is only used to constrain
the smoothed bounds calculated by the code</a:documentation>
                        <empty/>
                      </element>
                    </optional>
                    <optional>
                      <element name="coupled">
                        <a:documentation>This field is to be considered as being coupled to another field
such that the sum of the two fields is constrained to be less than
the upper_bound specified above.

The relationships between fields are worked out according to their
priority ordering.

This method is akin to the coupled_cv advection method.</a:documentation>
                        <empty/>
                      </element>
                    </optional>
                  </element>
                </optional>
                <optional>
                  <element name="lower_bound">
                    <ref name="real"/>
                    <optional>
                      <element name="apply_globally">
                        <a:documentation>If this is set the upper_bound is used everywhere.
If left unset the upper_bound is only used to constrain
the smoothed bounds calculated by the code</a:documentation>
                        <empty/>
                      </element>
                    </optional>
                  </element>
                </optional>
              </element>
            </optional>
            <optional>
              <element name="repair_deviations">
                <a:documentation>If, after performing all the boundedness_iterations, the field
is still not bounded then perform surgery to redistribute the
deviations to nodes that have less than their bounds.</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
        </optional>
        <choice>
          <element name="solver">
            <a:documentation>Solver options for the linear solve.
This method requires the inversion of a mass matrix. Note that
conservation properties are affected by the tolerance of the
linear solve.</a:documentation>
            <ref name="linear_solver_options_sym"/>
          </element>
          <element name="lump_mass_matrix">
            <a:documentation>Lump the mass matrix on the left hand side of the galerkin projection.
Hence solver options aren't necessary.</a:documentation>
            <empty/>
          </element>
        </choice>
      </element>
      <element name="discontinuous">
        <a:documentation>Discontinuous field Galerkin projection
In this case, no linear solver is required to invert the mass matrix.</a:documentation>
        <empty/>
      </element>
    </choice>
  </define>
  <define name="solenoidal_options">
    <element name="solenoidal">
      <a:documentation>Constrained divergence-free projection.
This adds an additional constraint that ensures that the field
is solenoidal, i.e. divergence-free.
This is equivalent in cost to a pressure solve.
This is expensive, and thus best left until
needed.

Note well: this only makes sense for nondivergent
vector fields, such as incompressible velocity!</a:documentation>
      <element name="interpolated_field">
        <a:documentation>Options for the mass matrix of the field being interpolated</a:documentation>
        <choice>
          <element name="continuous">
            <element name="lump_mass_matrix">
              <a:documentation>Lump the mass matrix for the assembly of the projection matrix
(not for the initial galerkin projection)

Required when using interpolating continuous fields</a:documentation>
              <optional>
                <element name="use_submesh">
                  <a:documentation>Lump on the submesh.
This only works for simplex meshes and is only
strictly valid on 2d meshes.</a:documentation>
                  <empty/>
                </element>
              </optional>
            </element>
          </element>
          <element name="discontinuous">
            <optional>
              <element name="lump_mass_matrix">
                <a:documentation>Lump the mass matrix for the assembly of the projection matrix
(not for the initial galerkin projection)</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
        </choice>
      </element>
      <element name="lagrange_multiplier">
        <a:documentation>Options for the lagrange multiplier

Must be on a continuous mesh!</a:documentation>
        <ref name="pressure_mesh_choice"/>
        <element name="spatial_discretisation">
          <choice>
            <element name="continuous_galerkin">
              <optional>
                <element name="remove_stabilisation_term">
                  <a:documentation>Remove the stabilisation term from the projection operator.

Automatic when not using P1P1.</a:documentation>
                  <empty/>
                </element>
              </optional>
              <optional>
                <element name="integrate_divergence_by_parts">
                  <a:documentation>Integrate the divergence operator by parts.

Automatic when projecting a discontinuous field</a:documentation>
                  <empty/>
                </element>
              </optional>
            </element>
            <element name="control_volumes">
              <empty/>
            </element>
          </choice>
        </element>
        <optional>
          <element name="reference_node">
            <ref name="integer"/>
          </element>
        </optional>
        <optional>
          <choice>
            <element name="update_scalar_field">
              <a:documentation>Update a scalar field using the lagrange multiplier from
the divergence free projection of this field.  The selected
scalar field must have solenoidal selected in its interpolation
options too and it must be on the same mesh as used for the
solenoidal projection above.

Note well: this only really makes sense for scalar fields linked to nondivergent
vector fields, such as pressure to incompressible velocity!                  </a:documentation>
              <attribute name="name">
                <value>Pressure</value>
              </attribute>
              <empty/>
            </element>
            <element name="update_scalar_field">
              <a:documentation>Update a scalar field using the lagrange multiplier from
the divergence free projection of this field.  The selected
scalar field must have solenoidal selected in its interpolation
options too and it must be on the same mesh as used for the
solenoidal projection above.

Note well: this only really makes sense for scalar fields linked to nondivergent
vector fields, such as pressure to incompressible velocity!                  </a:documentation>
              <attribute name="name">
                <data type="string" datatypeLibrary=""/>
              </attribute>
              <empty/>
            </element>
          </choice>
        </optional>
        <element name="solver">
          <a:documentation>Solver options for the linear solve.
This method requires the inversion of a projection matrix.</a:documentation>
          <ref name="linear_solver_options_sym"/>
        </element>
      </element>
    </element>
  </define>
  <define name="balanced_interpolation">
    <element name="balanced_interpolation">
      <a:documentation>Geostrophically-balanced interpolation.
During the interpolation, the velocity is split into
balanced and imbalanced parts. The imbalanced part is
interpolated whereas the balanced part is recovered
on the other side of the interpolation from the pressure.
This means that if your velocity field is balanced before
interpolation, it will be balanced afterwards also.

Note well: this only makes sense for velocity.</a:documentation>
      <element name="solver">
        <a:documentation>The solver options for computing the balanced velocity to subtract.</a:documentation>
        <ref name="linear_solver_options_sym"/>
      </element>
    </element>
  </define>
  <define name="supermesh_free">
    <element name="supermesh_free">
      <a:documentation>Enables a supermesh free Galerkin projection. Uses incomplete
quadrature, and hence is not conservative.</a:documentation>
      <empty/>
    </element>
  </define>
  <define name="represcribe_before_interpolation">
    <element name="represcribe_before_interpolation">
      <a:documentation>Represcribe the field before interpolation.

This means the interpolation will not be conservative from the previous mesh so be careful what you're trying to achieve!</a:documentation>
      <empty/>
    </element>
  </define>
  <define name="supermesh_conservation">
    <element name="supermesh_conservation">
      <a:documentation>Options for checking the supermesh conservation properties</a:documentation>
      <optional>
        <element name="tolerance">
          <a:documentation>Specify the fraction of the original elemental area/volume
to be used to check the conservation of the supermesh.

Since all fields are supermeshed together the minimum tolerance
specified over all fields will be used.

Defaults to 0.001 if unspecified.
i.e. 0.1% of the area/volume of an element in the new mesh may
be lost without warning or attempts to fix (if compiled with cgal)
during the construction of the supermesh between the old
and new meshes.</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
      <optional>
        <element name="print_field_integral">
          <a:documentation>Compute the field integral after the interpolation and print the relative
mass loss to the logfile (level 2 verbosity).

Note this is a post interpolation step and offers no chance of
fixing the conservation error (unlike the tolerance above if compiled
with cgal)</a:documentation>
          <element name="tolerance">
            <a:documentation>Relative tolerance with which to test the conservation of the field
integral.  If the conservation fails this tolerance a warning is issued
(level 0 verbosity) and vtus containing the field are output.</a:documentation>
            <ref name="real"/>
          </element>
        </element>
      </optional>
    </element>
  </define>
</grammar>
