lagrangian_biology =
   (
      ## Lagrangian particle biology from the VEW project.
      element lagrangian_ensemble_biology {
         element functional_group {
            attribute name { xsd:string },
            ## An agent's stage determines the update function
            element state_variable {
               attribute name { 'Stage' }
            },
            ## Dynamic size of the ensemble the agent represents
            element state_variable {
               attribute name { 'Biomass' },
               ## Biology agent field
               element scalar_field {
                  attribute name { 'Biomass' },
                  element diagnostic {
                     internal_algorithm,
                     mesh_choice,
                     diagnostic_scalar_field_no_adapt
                  },
                  ## A diagnostic 'Biomass<stage>' field is created for each agent stage
                  element per_stage {
                     empty
                  }
               }
            },
            (
               ## Internal state variable of a biology agent
               element state_variable {
                  attribute name { xsd:string }
               }|
               ## State variable representing the internal chemical pool of an agent
               element chemical_variable {
                  attribute name { xsd:string },
                  ## Eulerian diagnostic field representing the particulate amount of this chemical
                  ## Must be on a discontinuous mesh
                  element scalar_field {
                     attribute name { 'Particulate' },
                     element diagnostic {
                        internal_algorithm,
                        mesh_choice,
                        diagnostic_scalar_field_no_adapt
                     },
                     ## Option to create a diagnostic field for each stage
                     element per_stage {
                        empty
                     }?
                  }?,
                  ## Name of the field representing the dissolved chemical in the environment.
                  ## Needed if uptake or release are specified.
                  element chemical_field {
                     attribute name { xsd:string }
                  }?,
                  element uptake {
                     ## Request field on a discontinuous mesh mesh
                     element scalar_field {
                        attribute name { "DGRequest" },
                        element diagnostic {
                           internal_algorithm,
                           mesh_choice,
                           diagnostic_scalar_field_no_adapt
                        }
                     },
                     ## Request field projected onto a continuous mesh
                     element scalar_field {
                        attribute name { "CGRequest" },
                        element diagnostic {
                           ## Galerkin projects the source field.
                           element algorithm {
                              attribute name { "scalar_galerkin_projection" },
                              attribute material_phase_support { "single" },
                              attribute source_field_name { "DGRequest" },
                              attribute source_field_type { "scalar" },
                              ## Solver options. Required if projecting onto a continuous mesh.
                              element solver {
                                 linear_solver_options_sym
                              }?
                           },
                           velocity_mesh_choice,
                           diagnostic_scalar_field
                        }
                     },
                     ## Depletion factor
                     element scalar_field {
                        attribute name { "Depletion" },
                        element diagnostic {
                           internal_algorithm,
                           velocity_mesh_choice,
                           diagnostic_scalar_field_no_adapt
                        }
                     }
                  }?,
                  element release {
                     ## Release field on a discontinuous mesh mesh
                     element scalar_field {
                        attribute name { "DGRelease" },
                        element diagnostic {
                           internal_algorithm,
                           mesh_choice,
                           diagnostic_scalar_field_no_adapt
                        }
                     },
                     ## Release field projected onto a continuous mesh
                     element scalar_field {
                        attribute name { "CGRelease" },
                        element diagnostic {
                           ## Galerkin projects the source field.
                           element algorithm {
                              attribute name { "scalar_galerkin_projection" },
                              attribute material_phase_support { "single" },
                              attribute source_field_name { "DGRequest" },
                              attribute source_field_type { "scalar" },
                              ## Solver options. Required if projecting onto a continuous mesh.
                              element solver {
                                 linear_solver_options_sym
                              }?
                           },
                           velocity_mesh_choice,
                           diagnostic_scalar_field
                        }
                     }
                  }?
               }
            )*,
            ## Environment fields needed to run update code. A dictionary will be passed to the Python update code containing
            ## the local values of the fields listed here.
            element environment_field {
               attribute name { xsd:string }
            }*,
            ## Detectors with their locations specified via a python function or from a file. Allows detector arrays to be added.
            element stage_array {
               comment,
               attribute name { xsd:string },
               ## Stage identifier
               element id { real },
               ## The number of detectors prescribed by the python function.
               element number_of_agents {
                  integer
               },                     
               ## Create detectors which move with the fluid velocity.
               element lagrangian {
                  empty
               },
               ## Enable to write detector output in binary format
               element binary_output {
                  empty
               },
               ## Python function prescribing dimensional vector input. Functions should be of the form:
               ##
               ##  def val(t):
               ##     # Function code
               ##     return # Return value
               ##
               ## The return value must have length number_of_detectors.
               ##
               ## *** IMPORTANT NOTE ***
               ##
               ## The t argument is for future use only - currently detector locations are only set at simulation start.
               element initial_position {
                  python_code
               },
               element initial_state {
                  element values {
                     real_vector
                  }
               },
               element random_walk {
                  (
                     ## Python function prescribing additional agent displacement due to turbulence. 
                     ## The return value will be added to the lagrangian advection at each sub-timestep. 
                     ## Fields should be pulled from 'state' before the val(ele, local_coord) function is evaluated.
                     ## Functions should be of the form:
                     ## 
                     ##  field = state.scalar_fields['Field_name']
                     ##
                     ##  def val(ele, local_coord):
                     ##     # x = field.eval_field(ele, local_coord)
                     ##     return # Return some f(x)
                     element python{
                        python_code
                     }|
                     ## Hardcoded Random Walk scheme for non-homogeneous diffusivity fields.
                     ## Described in Visser, 1997 and Ross and Sharples, 2004.
                     ## Requires name of diffusivity field and according gradient field.
                     element diffusive_random_walk {
                        attribute diffusivity_field { xsd:string },
                        attribute diffusivity_gradient { xsd:string }
                     }
                  )
               }?,
               (
                  ## Python code specifying the biology model for this type of agent.
                  element biology_update {
                     python_code
                  }|
                  ## Do not calculate biology
                  ## This option is generally only useful for testing. 
                  element disable_biology {
                     empty
                  }
               ),
               ## Debug options
               element debug {
                  ## Skip velocity advection algorithm (RK-GS)
                  element exclude_from_advection {
                     empty
                  }?
               }?
            }*,
            ## Number of agents
            element scalar_field {
               attribute name { 'Agents' },
               element diagnostic {
                  internal_algorithm,
                  mesh_choice,
                  diagnostic_scalar_field_no_adapt
               },
               ## A diagnostic 'Agents<stage>' field is created for each agent stage
               element per_stage {
                  empty
               }
            }?,
            lagrangian_timestepping
         }*,
         element random_seed{
            integer
         }
      }
   )

hyperlight = 
   (
      ## Hyperlight solar irradiance model, which 
      ## computes a fast approximation to the Radiative Transfer Equation.
      ## NOTE: This module requires fluidity to be compiled with the 
      ## --enable-hyperlight flag.
      element hyperlight {
         ## Hydrolight always computes the scalar irradiance 
         ## for 36 regular wavebands of width 10nm in PAR. 
         ## Particular wavebands or total PAR irradiance need 
         ## to be derived from these fixed bands.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "IrradianceTemplate" },
            element prescribed {
               velocity_mesh_choice,
               prescribed_scalar_field
            }
         },
         element scalar_field {
            attribute rank { "0" },
            attribute name { "IrradiancePAR" },
            element diagnostic {
               velocity_mesh_choice,
               scalar_python_diagnostic_algorithm,
               diagnostic_scalar_field_no_adapt
            }
         }?,
         ## F, the ratio for correlated CDOM
         element CDOM {
            real
         },
         ## BF_chl, the backscatter fraction for chlorophyll-bearing particles
         element BF_chl {
            real
         },
         ## Parameter for GC sky irradiance model - 
         ## if provided this overwrites the values from the forcing routines.
         element CloudCover {
            real
         }?,
         ## Parameter for GC sky irradiance model - 
         ## if provided this overwrites the values from the forcing routines.
         element WindSpeed {
            real
         }?,
         ## Optional performance parameter that determines the percentage of 
         ## surface irradiance at which the model stops computing.
         ## Default is 0.01 = 1% (standard definition of euphotic depth)
         element EuphoticRatio {
            real
         }?
      }
   )
