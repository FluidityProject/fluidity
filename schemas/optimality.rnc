include "spud_base.rnc"

start =
   (
      ## The root node of the options dictionary.
      element optimality_options {
         comment,
         ## Output files are named according to the optimisation
         ## name, e.g. [optimisation_name]_0.stat. Non-standard
         ## characters in the optimisation name should be avoided.
         element name {
            anystring
         },
         model,
         optimisation_options,
         control_io, 
         debugging_options
      }
   )

model = 
   (
      ## Options to specifing the *flml file containing to model
      ## configuration template
      element model {
         attribute option_file { xsd:string },
         attribute command_line { xsd:string }
      },
      ## Options to specifing the *flml file containing to model
      ## configuration template
      element functional {
         attribute name { xsd:string }
      }
   )

optimisation_options =
   (
      ## Options for the optimisation algorithm.
      element optimisation_options {
         (
            ## Minimize the functional using the BFGS algorithm.
            element optimisation_algorithm {
              attribute name { "BFGS" },
              ## Gradient norm must be less than tolerance before succesful termination. 
              element tolerance {
                   real
              },
              ## Maximum number of iterations to perform. 
              element iterations {
                   integer
              }?,
              comment
            }|
            ## Minimize the functional using the NCG algorithm.
            element optimisation_algorithm {
              attribute name { "NCG" },
              ## Convergence is assumed when the average relative error in the minimizer falls below this amount. 
              element tolerance {
                   real
              },
              ## Maximum number of iterations to perform. 
              element iterations {
                   integer
              }?,
              comment
            }|
            ## Minimize the functional using the LBFGS algorithm. 
            ## Note: This optimisation algorithm will produce no (optimisation) stat file.
            element optimisation_algorithm {
              attribute name { "L-BFGS-B" },
              ## The iteration will stop when max{|proj g_i | i = 1, ..., n} <= pgtol where pg_i is the i-th component of the projected gradient.
              ## 
              ## Default value is: 1.0000000000000001e-05
              element tolerance {
                   real
              }?,
              ## The iteration stops when (f^k - f^{k+1})/max{|f^k|,|f^{k+1}|,1} <= factr * eps, where eps is the machine precision, which is automatically generated by the code. Typical values for factr are: 1e12 for low accuracy; 1e7 for moderate accuracy; 10.0 for extremely high accuracy.
              ## 
              ## Default: 10
              element factr {
                   real
              }?,
              ## The maximum number of variable metric corrections used to define the limited memory matrix. (The limited memory BFGS method does not store the full hessian but uses this many terms in an approximation to it.)
              ##
              ## Default value: factr=10000000.0
              element memory_limit {
                   integer                   
              }?,
              ## Maximum number of function evaluations.
              ##
              ## Default: 15000
              element maximal_functional_evaluations {
                   integer
              }?,
              ## Controls the frequency of output. iprint < 0 means no output.
              ##
              ## Default: -1
              element verbosity {
                   integer
              }?,
              comment
            }|
            ## This optimisation algorithm does nothing. It is only useful if you want to use optimality
            ## in debugging mode (e.g. to check correctness of gradients produced with an adjoint).
            element optimisation_algorithm {
              attribute name { "NULL" }
            }
         ),
         comment
      }
   )

control_io =
   (
      ## Read mesh from file.
      element control_io {
            element control {
                attribute name { xsd:string },
                  (
                    ## A default control from the model. 
                    ## This option is used when a default control was selected in the model
                    ## (any control under /adjoint/controls/ in the model setup)
                    element type {
                      attribute name { "default" },
                      comment
                    }|
                    element type {
                      ## The custom control parameter is the most flexible option. 
                      ## It uses custom python functions for handling the controls input/ouput.
                      attribute name { "custom" },
                      ## Expects a python function "initial_control" which returns a numpy.array containing the initial guess of the control.
                      ##
                      ## Example:
                      ##
                      ##  def initial_control():
                      ##   import numpy
                      ##   return numpy.array([1])
                      element initial_control {
                         python_code
                      },
                      ## Python function which takes as input a numpy array containing the new model parameters and
                      ## updates the corresponding model configuration.
                      ##
                      ## Example:
                      ##
                      ##  def update_control(m):
                      ##   import pickle
                      ##   f = open('control_h.pkl', 'wb')    
                      ##   pickle.dump(m, f)
                      ##   f.close()
                      element update_control {
                         python_code
                      },
                      ## Expects a python function "control_derivative" which returns a numpy.array containing the derivative of the objective function with respect to the control.
                      ##
                      ## Example:
                      ##
                      ##   def control_derivative():
                      ##     import pickle
                      ##     func_deriv_file = open('control_derivative_h.pkl', 'rb')
                      ##     return pickle.load(func_deriv_file)
                      element control_derivative {
                         python_code
                      },
                      comment
                    }
                )
           }+
       }
   )

debugging_options = 
  (
      ## Debugging options.
      element debug {
         (
            ## Check the functional gradient with respect to the parameters using finite differences. 
            ## The l2 error of the result is saved in the stat file as [functional name]_gradient_error
            element check_gradient {
              empty
            }?
         ),
         ## Save model output at each optimisation iteration in a subdirectory opt_iter_X, where X is the iteration number.
         element save_model_output {
            empty
         }?,
         comment
      }?
  )
