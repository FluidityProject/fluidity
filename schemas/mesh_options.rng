<?xml version="1.0" encoding="UTF-8"?>
<grammar xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0" xmlns="http://relaxng.org/ns/structure/1.0" datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes">
  <define name="mesh_info">
    <choice>
      <element name="from_file">
        <a:documentation>Read mesh from file.</a:documentation>
        <choice>
          <element name="format">
            <a:documentation>GMSH mesh format</a:documentation>
            <attribute name="name">
              <value>gmsh</value>
            </attribute>
            <ref name="comment"/>
          </element>
          <element name="format">
            <a:documentation>Read the mesh from a vtu. Note that the mesh will have no 
surface or region IDs.</a:documentation>
            <attribute name="name">
              <value>vtu</value>
            </attribute>
            <ref name="comment"/>
          </element>
          <element name="format">
            <a:documentation>ExodusII mesh format.

&lt;b&gt;Note: Only works for serial mesh files and 
Checkpoints are dumped in the GMSH file format.&lt;/b&gt;</a:documentation>
            <attribute name="name">
              <value>exodusii</value>
            </attribute>
            <ref name="comment"/>
          </element>
        </choice>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
        <optional>
          <element name="dimension">
            <ref name="integer"/>
          </element>
        </optional>
        <ref name="from_file_mesh_stat_options"/>
        <ref name="comment"/>
      </element>
      <element name="from_mesh">
        <a:documentation>Make mesh from existing mesh. </a:documentation>
        <ref name="mesh_choice"/>
        <optional>
          <element name="mesh_shape">
            <optional>
              <element name="polynomial_degree">
                <ref name="integer"/>
              </element>
            </optional>
            <optional>
              <element name="element_type">
                <element name="string_value">
                  <a:documentation>Select the element type. "lagrangian" means the usual
Pn element type. "bubble" adds bubble functions that
vanish on the element boundaries, and
trace defines an element that is only defined on faces
and is undefined on the element interior (used for 
enforcing continuity by Lagrange multipliers).</a:documentation>
                  <choice>
                    <value>lagrangian</value>
                    <value>bubble</value>
                    <value>trace</value>
                  </choice>
                </element>
              </element>
            </optional>
          </element>
        </optional>
        <optional>
          <element name="mesh_continuity">
            <element name="string_value">
              <choice>
                <value>continuous</value>
                <value>discontinuous</value>
              </choice>
            </element>
          </element>
        </optional>
        <optional>
          <element name="constraint_type">
            <element name="string_value">
              <a:documentation>Set the constraint type. This is used to implement
div-conforming elements such as RT0 in a hybridised
solver.</a:documentation>
              <choice>
                <value>BDM</value>
                <value>BDFM</value>
                <value>RT</value>
              </choice>
            </element>
            <element name="solver">
              <ref name="linear_solver_options_sym">
                <a:documentation>Solver is used to apply projections to div-conforming
space, and in elliptic solvers</a:documentation>
              </ref>
            </element>
          </element>
        </optional>
        <zeroOrMore>
          <element name="periodic_boundary_conditions">
            <a:documentation>Make mesh periodic</a:documentation>
            <attribute name="name">
              <data type="string"/>
            </attribute>
            <element name="physical_boundary_ids">
              <a:documentation>List of boundary ids that are aliased to</a:documentation>
              <ref name="integer_vector"/>
            </element>
            <element name="aliased_boundary_ids">
              <a:documentation>List of boundary ids that are aliased</a:documentation>
              <ref name="integer_vector"/>
            </element>
            <element name="coordinate_map">
              <a:documentation>Python code which takes coordinate of an aliased
boundary node and returns the coordinate of a physical
boundary node.
Note that in adaptive simulations this will be applied to
arbitrary points in space, not just those on the original aliased
boundary.
Python function prescribing real input. Functions should be of the form:

 def val(X, t):
    # Function code
    return # Return value

where X is a tuple of length geometry dimension and t is time</a:documentation>
              <ref name="python_code"/>
            </element>
            <optional>
              <element name="inverse_coordinate_map">
                <a:documentation>Python code which takes coordinate of a physical
boundary node and returns the coordinate of an aliased
boundary node. This is used in adaptive simulations to
keep the adapted domain inside the bounding box of the
original domain.
Python function prescribing real input. Functions should be of the form:

 def val(X, t):
    # Function code
    return # Return value

where X is a tuple of length geometry dimension and t is time</a:documentation>
                <ref name="python_code"/>
              </element>
            </optional>
            <optional>
              <element name="remove_periodicity">
                <a:documentation>&lt;b&gt;Don't turn this on by hand!&lt;/b&gt;
This option gets set by the periodise tool, to indicate
that this mesh should have the periodic boundary conditions
&lt;b&gt;removed&lt;/b&gt;. See the discussion on the wiki about 
parallel periodic boundary conditions.</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
        </zeroOrMore>
        <optional>
          <element name="extrude">
            <a:documentation>Extrude a horizontal (1D or 2D) mesh in the vertical</a:documentation>
            <choice>
              <ref name="top_layer_whole_mesh_region"/>
              <ref name="top_layer_named_region"/>
              <element name="layer">
                <a:documentation>Extrusion options for the top layer. Give this layer a unique name
and if necessary add more layers below with different extrusion options.</a:documentation>
                <attribute name="name">
                  <data type="string" datatypeLibrary=""/>
                </attribute>
                <ref name="top_layer_extrusion_options"/>
              </element>
            </choice>
            <zeroOrMore>
              <choice>
                <ref name="top_layer_named_region"/>
                <element name="layer">
                  <a:documentation>Continue mesh extrusion under the previous extrusion layer with possibly different options.</a:documentation>
                  <attribute name="name">
                    <data type="string" datatypeLibrary=""/>
                  </attribute>
                  <ref name="next_layer_extrusion_options"/>
                </element>
              </choice>
            </zeroOrMore>
            <optional>
              <element name="checkpoint_from_file">
                <a:documentation>This is an internal option used by checkpointing. The
option is switched on automatically in writing a
checkpoint, so that when starting from the checkpoint .flml
fluidity picks up the extruded mesh from file. After the next
adapt the extrusion is again done as specified in the other
extrusion options and under the adaptivity options.</a:documentation>
                <choice>
                  <element name="format">
                    <a:documentation>Triangle mesh format.

Enter the base name without the .edge .ele, .face or
.node extensions, and without process numbers.</a:documentation>
                    <attribute name="name">
                      <value>triangle</value>
                    </attribute>
                    <ref name="comment"/>
                  </element>
                  <element name="format">
                    <a:documentation>GMSH mesh format</a:documentation>
                    <attribute name="name">
                      <value>gmsh</value>
                    </attribute>
                    <ref name="comment"/>
                  </element>
                </choice>
                <attribute name="file_name">
                  <data type="string"/>
                </attribute>
                <ref name="comment"/>
              </element>
            </optional>
          </element>
        </optional>
        <ref name="derived_mesh_stat_options"/>
        <ref name="comment"/>
      </element>
    </choice>
  </define>
  <!-- Options for inclusion/exclusion of mesh statistics from the .stat file -->
  <define name="include_mesh_in_stat">
    <element name="include_in_stat">
      <a:documentation>Include this mesh in the .stat file</a:documentation>
      <ref name="comment"/>
    </element>
  </define>
  <define name="exclude_mesh_from_stat">
    <element name="exclude_from_stat">
      <a:documentation>Exclude this mesh from the .stat file</a:documentation>
      <ref name="comment"/>
    </element>
  </define>
  <!-- Diagnostic statistics options for meshed, with enabled by default -->
  <define name="mesh_stat_options_enabled_default">
    <choice>
      <ref name="include_mesh_in_stat"/>
      <ref name="exclude_mesh_from_stat"/>
    </choice>
  </define>
  <!-- Diagnostic statistics options for meshed, with disabled by default -->
  <define name="mesh_stat_options_disabled_default">
    <choice>
      <ref name="exclude_mesh_from_stat"/>
      <ref name="include_mesh_in_stat"/>
    </choice>
  </define>
  <define name="from_file_mesh_stat_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <ref name="mesh_stat_options_enabled_default"/>
    </element>
  </define>
  <define name="derived_mesh_stat_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <ref name="mesh_stat_options_disabled_default"/>
    </element>
  </define>
  <define name="top_layer_whole_mesh_region">
    <element name="regions">
      <a:documentation>Extrusion options for WholeMesh

Only specify one set of parameters if not using mesh regions.
Otherwise use the dropdown menu to specify a named region,
specify the region_ids in the surface mesh that define this
named region, and then hen add extra regions for other regions.</a:documentation>
      <attribute name="name">
        <value>WholeMesh</value>
      </attribute>
      <ref name="top_layer_regional_extrusion_options"/>
    </element>
  </define>
  <define name="top_layer_named_region">
    <element name="regions">
      <a:documentation>Multiple extrusion options are allowed if specifying
different values in different
regions of the mesh (defined by region_ids).  In this case
each set of options
requires a distinct name for the options dictionary.</a:documentation>
      <attribute name="name">
        <data type="string" datatypeLibrary=""/>
      </attribute>
      <optional>
        <ref name="region_ids"/>
      </optional>
      <ref name="top_layer_regional_extrusion_options"/>
    </element>
  </define>
  <define name="top_layer_extrusion_options">
    <choice>
      <ref name="top_layer_whole_mesh_region"/>
      <ref name="top_layer_named_region"/>
    </choice>
    <zeroOrMore>
      <ref name="top_layer_named_region"/>
    </zeroOrMore>
  </define>
  <define name="next_layer_whole_mesh_region">
    <element name="regions">
      <a:documentation>Extrusion options for WholeMesh

Only specify one set of parameters if not using mesh regions.
Otherwise use the dropdown menu to specify a named region,
specify the region_ids in the surface mesh that define this
named region, and then hen add extra regions for other regions.</a:documentation>
      <attribute name="name">
        <value>WholeMesh</value>
      </attribute>
      <ref name="next_layer_regional_extrusion_options"/>
    </element>
  </define>
  <define name="next_layer_named_region">
    <element name="regions">
      <a:documentation>Multiple extrusion options are allowed if specifying
different values in different
regions of the mesh (defined by region_ids).  In this case
each set of options
requires a distinct name for the options dictionary.</a:documentation>
      <attribute name="name">
        <data type="string" datatypeLibrary=""/>
      </attribute>
      <optional>
        <ref name="region_ids"/>
      </optional>
      <ref name="next_layer_regional_extrusion_options"/>
    </element>
  </define>
  <define name="next_layer_extrusion_options">
    <choice>
      <ref name="next_layer_whole_mesh_region"/>
      <ref name="next_layer_named_region"/>
    </choice>
    <zeroOrMore>
      <ref name="next_layer_named_region"/>
    </zeroOrMore>
  </define>
  <!-- in the top layer we can specify both top and bottom surface id in each region: -->
  <define name="top_layer_regional_extrusion_options">
    <ref name="extrusion_options"/>
    <optional>
      <element name="top_surface_id">
        <a:documentation>surface_id to assign to the top of the extruded mesh</a:documentation>
        <ref name="integer"/>
      </element>
    </optional>
    <optional>
      <element name="bottom_surface_id">
        <a:documentation>surface_id to assign to the bottom of the extruded mesh, or to the internal
boundary below the current extrusion layer if multiple extrusion layers
are specified.</a:documentation>
        <ref name="integer"/>
      </element>
    </optional>
  </define>
  <!-- in the next layers we can only specify the bottom surface id in each region: -->
  <define name="next_layer_regional_extrusion_options">
    <ref name="extrusion_options"/>
    <optional>
      <element name="bottom_surface_id">
        <a:documentation>surface_id to assign to the bottom of the layer</a:documentation>
        <ref name="integer"/>
      </element>
    </optional>
  </define>
  <define name="extrusion_options">
    <element name="bottom_depth">
      <a:documentation>Depth over which to extrude
top will be at z=0
bottom will be at z=-bottom_depth</a:documentation>
      <ref name="input_choice_real_plus_map"/>
    </element>
    <element name="sizing_function">
      <a:documentation>Constant or function to specify the depth of the
layers. The function is a function of all coordinates
(so in 2+1D: x,y and z) to specify a layer depth that
varies both in the horizontal as in the vertical.</a:documentation>
      <ref name="input_choice_real_plus_list"/>
      <optional>
        <element name="varies_only_in_depth">
          <a:documentation>If your sizing function only varies in depth enable this option.
Do not use if your function depends on x and/or y as it takes a column of depth values and re-uses it. </a:documentation>
          <empty/>
        </element>
      </optional>
    </element>
    <optional>
      <element name="minimum_bottom_layer_fraction">
        <a:documentation>To prevent infinitesimally thin bottom layer if sizing function
is an integer multiple of total depth, the bottom layer needs
to have at least this fraction of the layer depth above it. 

Default is 1e-3.</a:documentation>
        <ref name="real"/>
      </element>
    </optional>
    <optional>
      <element name="extruded_region_id">
        <a:documentation>Change the region_id of this extruded region. If not specified
the region obtains the region_id of the horizontal mesh above.</a:documentation>
        <ref name="integer"/>
      </element>
    </optional>
  </define>
  <!-- Most common mesh choices -->
  <define name="mesh_choice">
    <choice>
      <element name="mesh">
        <attribute name="name">
          <data type="string"/>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>CoordinateMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>VelocityMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>PressureMesh</value>
        </attribute>
      </element>
    </choice>
  </define>
  <!-- Same choices, but with VelocityMesh offered first -->
  <define name="velocity_mesh_choice">
    <choice>
      <element name="mesh">
        <attribute name="name">
          <value>VelocityMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>PressureMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>CoordinateMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
      </element>
    </choice>
  </define>
  <!-- Same choices, but with PressureMesh offered first -->
  <define name="pressure_mesh_choice">
    <choice>
      <element name="mesh">
        <attribute name="name">
          <value>PressureMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>VelocityMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>CoordinateMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
      </element>
    </choice>
  </define>
  <!-- Same choices, but with CoordinateMesh offered first -->
  <define name="coordinate_mesh_choice">
    <choice>
      <element name="mesh">
        <attribute name="name">
          <value>CoordinateMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>VelocityMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>PressureMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
      </element>
    </choice>
  </define>
</grammar>
