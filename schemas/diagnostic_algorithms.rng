<?xml version="1.0" encoding="UTF-8"?>
<grammar xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0" xmlns="http://relaxng.org/ns/structure/1.0" datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes">
  <define name="source_field">
    <attribute name="source_field_name">
      <data type="string"/>
    </attribute>
  </define>
  <define name="scalar_source_field">
    <ref name="source_field"/>
  </define>
  <define name="scalar_source_field" combine="interleave">
    <attribute name="source_field_type">
      <value>scalar</value>
    </attribute>
  </define>
  <define name="vector_source_field">
    <ref name="source_field"/>
  </define>
  <define name="vector_source_field" combine="interleave">
    <attribute name="source_field_type">
      <value>vector</value>
    </attribute>
  </define>
  <define name="tensor_source_field">
    <ref name="source_field"/>
  </define>
  <define name="tensor_source_field" combine="interleave">
    <attribute name="source_field_type">
      <value>tensor</value>
    </attribute>
  </define>
  <define name="component_source_field">
    <ref name="source_field"/>
  </define>
  <define name="component_source_field" combine="interleave">
    <attribute name="source_field_type">
      <value>component</value>
    </attribute>
    <optional>
      <element name="source_field_component">
        <a:documentation>If enabled, uses the component of a vector field as a source field.
Otherwise, uses a scalar field as a source field.</a:documentation>
        <ref name="integer"/>
      </element>
    </optional>
  </define>
  <define name="source_field_1">
    <attribute name="source_field_1_name">
      <data type="string"/>
    </attribute>
  </define>
  <define name="source_field_2">
    <attribute name="source_field_2_name">
      <data type="string"/>
    </attribute>
  </define>
  <define name="scalar_source_field_1">
    <ref name="source_field_1"/>
  </define>
  <define name="scalar_source_field_1" combine="interleave">
    <attribute name="source_field_1_type">
      <value>scalar</value>
    </attribute>
  </define>
  <define name="scalar_source_field_2">
    <ref name="source_field_2"/>
  </define>
  <define name="scalar_source_field_2" combine="interleave">
    <attribute name="source_field_2_type">
      <value>scalar</value>
    </attribute>
  </define>
  <define name="vector_source_field_1">
    <ref name="source_field_1"/>
  </define>
  <define name="vector_source_field_1" combine="interleave">
    <attribute name="source_field_1_type">
      <value>vector</value>
    </attribute>
  </define>
  <define name="vector_source_field_2">
    <ref name="source_field_2"/>
  </define>
  <define name="vector_source_field_2" combine="interleave">
    <attribute name="source_field_2_type">
      <value>vector</value>
    </attribute>
  </define>
  <define name="tensor_source_field_1">
    <ref name="source_field_1"/>
  </define>
  <define name="tensor_source_field_1" combine="interleave">
    <attribute name="source_field_1_type">
      <value>tensor</value>
    </attribute>
  </define>
  <define name="tensor_source_field_2">
    <ref name="source_field_2"/>
  </define>
  <define name="tensor_source_field_2" combine="interleave">
    <attribute name="source_field_2_type">
      <value>tensor</value>
    </attribute>
  </define>
  <define name="component_source_field_1">
    <ref name="source_field_1"/>
  </define>
  <define name="component_source_field_1" combine="interleave">
    <attribute name="source_field_1_type">
      <value>component</value>
    </attribute>
    <optional>
      <element name="source_field_1_component">
        <a:documentation>If enabled, uses the component of a vector field as a source field.
Otherwise, uses a scalar field as a source field.</a:documentation>
        <ref name="integer"/>
      </element>
    </optional>
  </define>
  <define name="component_source_field_2">
    <ref name="source_field_2"/>
  </define>
  <define name="component_source_field_2" combine="interleave">
    <attribute name="source_field_2_type">
      <value>component</value>
    </attribute>
    <optional>
      <element name="source_field_2_component">
        <a:documentation>If enabled, uses the component of a vector field as a source field.
Otherwise, uses a scalar field as a source field.</a:documentation>
        <ref name="integer"/>
      </element>
    </optional>
  </define>
  <define name="internal_algorithm">
    <choice>
      <element name="algorithm">
        <a:documentation>This diagnostic is internal - i.e. it is calculated somewhere within
the main code, and is not wrapped by the automatic diagnostics
wrappers.</a:documentation>
        <attribute name="name">
          <value>Internal</value>
        </attribute>
        <attribute name="material_phase_support">
          <value>multiple</value>
        </attribute>
      </element>
      <element name="algorithm">
        <a:documentation>This diagnostic is derived from particle attributes, it is calculated
within the Particle_Diagnostics.F90 routine, and set via the ratio method.</a:documentation>
        <attribute name="name">
          <value>from_particles</value>
        </attribute>
        <attribute name="material_phase_support">
          <value>multiple</value>
        </attribute>
        <group>
          <element name="particle_group">
            <a:documentation>Particle group used for calculation of diagnostic field.</a:documentation>
            <attribute name="name">
              <data type="string"/>
            </attribute>
            <choice>
              <element name="particle_attribute">
                <a:documentation>Particle attribute used for calculation of diagnostic field.</a:documentation>
                <attribute name="name">
                  <data type="string"/>
                </attribute>
              </element>
              <element name="particle_attribute_array">
                <a:documentation>Particle attribute_array used for calculation of diagnostic field.</a:documentation>
                <attribute name="name">
                  <data type="string"/>
                </attribute>
                <element name="attribute_index">
                  <a:documentation>Integer value corresponding to attribute position in array (starts from 1).</a:documentation>
                  <ref name="integer"/>
                </element>
              </element>
            </choice>
          </element>
          <element name="interpolation">
            <a:documentation>Function used to interpolate particle values onto nodes.</a:documentation>
            <choice>
              <element name="weighted_distance">
                <a:documentation>Weighted distribution of particle values between all nodes of the current particle element.</a:documentation>
                <empty/>
              </element>
              <element name="nearest_neighbour">
                <a:documentation>Transfers particle values only to the closest node.</a:documentation>
                <empty/>
              </element>
            </choice>
          </element>
        </group>
      </element>
      <element name="algorithm">
        <a:documentation>This diagnostic is calculated from the number of particles present per
control volume, set within the Particle_Diagnostics.F90 routine.</a:documentation>
        <attribute name="name">
          <value>number_of_particles</value>
        </attribute>
        <attribute name="material_phase_support">
          <value>multiple</value>
        </attribute>
        <element name="particle_group">
          <a:documentation>Particle group used for calculation of diagnostic.</a:documentation>
          <attribute name="name">
            <data type="string"/>
          </attribute>
        </element>
      </element>
    </choice>
  </define>
  <define name="legacy_internal_algorithm">
    <element name="algorithm">
      <a:documentation>This diagnostic is deprecated - i.e. it has been replaced by an
equivalent diagnostic algorithm.</a:documentation>
      <attribute name="name">
        <value>Internal</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>multiple</value>
      </attribute>
      <attribute name="legacy">
        <value>true</value>
      </attribute>
    </element>
  </define>
  <define name="internal_velocity_source_algorithm">
    <element name="algorithm">
      <a:documentation>Some code paths
use their own internal diagnostic source field. Select
this option to these these internal algorithms.</a:documentation>
      <attribute name="name">
        <value>Internal</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>multiple</value>
      </attribute>
    </element>
  </define>
  <define name="internal_velocity_absorption_algorithm">
    <element name="algorithm">
      <a:documentation>Some code paths
use their own internal diagnostic absorption field. Select
this option to these these internal algorithms.</a:documentation>
      <attribute name="name">
        <value>Internal</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>multiple</value>
      </attribute>
    </element>
  </define>
  <!-- Simple equality algorithms -->
  <define name="scalar_copy_algorithm">
    <element name="algorithm">
      <a:documentation>Copies the source field. This is intended for testing purposes
&lt;b&gt;only&lt;/b&gt;.</a:documentation>
      <attribute name="name">
        <value>scalar_copy</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="scalar_source_field"/>
      <optional>
        <element name="allow_higher_lower_continuous_remap">
          <a:documentation>When copying the field allow remapping between higher order and lower order continuous meshes.</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="allow_unperiodic_periodic_remap">
          <a:documentation>When copying the field allow remapping between unperiodic and periodic meshes.</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="allow_discontinuous_continuous_remap">
          <a:documentation>When copying the field allow remapping between discontinuous and continuous meshes.</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="allow_bubble_lagrange_remap">
          <a:documentation>When copying the field allow remapping between bubble and lagrange meshes.</a:documentation>
          <empty/>
        </element>
      </optional>
    </element>
  </define>
  <define name="extract_scalar_component_algorithm">
    <element name="algorithm">
      <a:documentation>Extract a component from a vector field as a scalar</a:documentation>
      <attribute name="name">
        <value>extract_scalar_component</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="component_source_field"/>
    </element>
  </define>
  <define name="vector_copy_algorithm">
    <element name="algorithm">
      <a:documentation>Copies the source field. This is intended for testing purposes
&lt;b&gt;only&lt;/b&gt;.</a:documentation>
      <attribute name="name">
        <value>vector_copy</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="vector_source_field"/>
      <optional>
        <element name="allow_higher_lower_continuous_remap">
          <a:documentation>When copying the field allow remapping between higher order and lower order continuous meshes.</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="allow_unperiodic_periodic_remap">
          <a:documentation>When copying the field allow remapping between unperiodic and periodic meshes.</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="allow_discontinuous_continuous_remap">
          <a:documentation>When copying the field allow remapping between discontinuous and continuous meshes.</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="allow_bubble_lagrange_remap">
          <a:documentation>When copying the field allow remapping between bubble and lagrange meshes.</a:documentation>
          <empty/>
        </element>
      </optional>
    </element>
  </define>
  <define name="tensor_copy_algorithm">
    <element name="algorithm">
      <a:documentation>Copies the source field. This is intended for testing purposes
&lt;b&gt;only&lt;/b&gt;.</a:documentation>
      <attribute name="name">
        <value>tensor_copy</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="tensor_source_field"/>
      <optional>
        <element name="allow_higher_lower_continuous_remap">
          <a:documentation>When copying the field allow remapping between higher order and lower order continuous meshes.</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="allow_unperiodic_periodic_remap">
          <a:documentation>When copying the field allow remapping between unperiodic and periodic meshes.</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="allow_discontinuous_continuous_remap">
          <a:documentation>When copying the field allow remapping between discontinuous and continuous meshes.</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="allow_bubble_lagrange_remap">
          <a:documentation>When copying the field allow remapping between bubble and lagrange meshes.</a:documentation>
          <empty/>
        </element>
      </optional>
    </element>
  </define>
  <define name="scalar_galerkin_projection_algorithm">
    <element name="algorithm">
      <a:documentation>Galerkin projects the source field.</a:documentation>
      <attribute name="name">
        <value>scalar_galerkin_projection</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="scalar_source_field"/>
      <optional>
        <element name="solver">
          <a:documentation>Solver options. Required if projecting onto a continuous mesh.</a:documentation>
          <ref name="linear_solver_options_sym"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="vector_galerkin_projection_algorithm">
    <element name="algorithm">
      <a:documentation>Galerkin projects the source field.</a:documentation>
      <attribute name="name">
        <value>vector_galerkin_projection</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="vector_source_field"/>
      <optional>
        <element name="solver">
          <a:documentation>Solver options. Required if projecting onto a continuous mesh.</a:documentation>
          <ref name="linear_solver_options_sym"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="helmholtz_smoothed_scalar_algorithm">
    <element name="algorithm">
      <a:documentation>Smooth a scalar field by inverting a Helmholtz operator based on a scalar lengthscale.
Dirichlet boundary conditions from the source field are applied to the filtered field.</a:documentation>
      <attribute name="name">
        <value>helmholtz_smoothed_scalar</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="component_source_field"/>
      <element name="smoothing_scale_factor">
        <a:documentation>The characteristic scale factor alpha used by the smoother.
The length scale is alpha*local element width (a scalar)
2 is recommended.</a:documentation>
        <ref name="real"/>
      </element>
      <element name="solver">
        <a:documentation>Solver options.</a:documentation>
        <ref name="linear_solver_options_sym"/>
      </element>
    </element>
  </define>
  <define name="helmholtz_smoothed_vector_algorithm">
    <element name="algorithm">
      <a:documentation>Smooth a vector field by inverting a Helmholtz operator based on a scalar lengthscale.
Dirichlet boundary conditions from the source field are applied to the filtered field.</a:documentation>
      <attribute name="name">
        <value>helmholtz_smoothed_vector</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="vector_source_field"/>
      <element name="smoothing_scale_factor">
        <a:documentation>The characteristic scale factor alpha used by the smoother.
The length scale is alpha*local element width (a scalar)
2 is recommended.</a:documentation>
        <ref name="real"/>
      </element>
      <element name="solver">
        <a:documentation>Solver options.</a:documentation>
        <ref name="linear_solver_options_sym"/>
      </element>
    </element>
  </define>
  <define name="helmholtz_smoothed_tensor_algorithm">
    <element name="algorithm">
      <a:documentation>Smooth a tensor field by inverting a Helmholtz operator based on a scalar lengthscale.
Dirichlet boundary conditions are not applied to the filtered field.</a:documentation>
      <attribute name="name">
        <value>helmholtz_smoothed_tensor</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="tensor_source_field"/>
      <element name="smoothing_scale_factor">
        <a:documentation>The characteristic scale factor alpha used by the smoother.
The length scale is alpha*local element width (a scalar)
2 is recommended.</a:documentation>
        <ref name="real"/>
      </element>
      <element name="solver">
        <a:documentation>Solver options.</a:documentation>
        <ref name="linear_solver_options_sym"/>
      </element>
    </element>
  </define>
  <define name="helmholtz_anisotropic_smoothed_scalar_algorithm">
    <element name="algorithm">
      <a:documentation>Smooth a scalar field by inverting a Helmholtz operator based on a tensor lengthscale.
Dirichlet boundary conditions from the source field are applied to the filtered field.</a:documentation>
      <attribute name="name">
        <value>helmholtz_anisotropic_smoothed_scalar</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="scalar_source_field"/>
      <element name="smoothing_scale_factor">
        <a:documentation>The characteristic scale factor alpha used by the smoother.
The length scale is alpha*local element size (a tensor).
2 is recommended.</a:documentation>
        <ref name="real"/>
      </element>
      <element name="solver">
        <a:documentation>Solver options.</a:documentation>
        <ref name="linear_solver_options_sym"/>
      </element>
    </element>
  </define>
  <define name="helmholtz_anisotropic_smoothed_vector_algorithm">
    <element name="algorithm">
      <a:documentation>Smooth a vector field by inverting a Helmholtz operator based on a tensor lengthscale.
Dirichlet boundary conditions from the source field are applied to the filtered field.</a:documentation>
      <attribute name="name">
        <value>helmholtz_anisotropic_smoothed_vector</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="vector_source_field"/>
      <element name="smoothing_scale_factor">
        <a:documentation>The characteristic scale factor alpha used by the smoother.
The length scale is alpha*local element size (a tensor).
2 is recommended.</a:documentation>
        <ref name="real"/>
      </element>
      <element name="solver">
        <a:documentation>Solver options.</a:documentation>
        <ref name="linear_solver_options_sym"/>
      </element>
    </element>
  </define>
  <define name="helmholtz_anisotropic_smoothed_tensor_algorithm">
    <element name="algorithm">
      <a:documentation>Smooth a tensor field by inverting a Helmholtz operator based on a tensor lengthscale.
Dirichlet boundary conditions are not applied to the filtered field.</a:documentation>
      <attribute name="name">
        <value>helmholtz_anisotropic_smoothed_tensor</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="tensor_source_field"/>
      <element name="smoothing_scale_factor">
        <a:documentation>The characteristic scale factor alpha used by the smoother.
The length scale is alpha*local element size (a tensor).
2 is recommended.</a:documentation>
        <ref name="real"/>
      </element>
      <element name="solver">
        <a:documentation>Solver options.</a:documentation>
        <ref name="linear_solver_options_sym"/>
      </element>
    </element>
  </define>
  <define name="lumped_mass_smoothed_scalar_algorithm">
    <element name="algorithm">
      <a:documentation>Smooth a scalar field by inverting the lumped mass: ML {S_smooth}=M {S} .</a:documentation>
      <attribute name="name">
        <value>lumped_mass_smoothed_scalar</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="scalar_source_field"/>
    </element>
  </define>
  <define name="lumped_mass_smoothed_vector_algorithm">
    <element name="algorithm">
      <a:documentation>Smooth a vector field by inverting the lumped mass: ML {V_smooth}=M {V}.</a:documentation>
      <attribute name="name">
        <value>lumped_mass_smoothed_vector</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="vector_source_field"/>
    </element>
  </define>
  <!-- Binary operators -->
  <define name="scalar_sum_algorithm">
    <element name="algorithm">
      <a:documentation>Sum of two scalar fields</a:documentation>
      <attribute name="name">
        <value>scalar_sum</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="scalar_source_field_1"/>
      <ref name="scalar_source_field_2"/>
    </element>
  </define>
  <define name="scalar_difference_algorithm">
    <element name="algorithm">
      <a:documentation>Difference between two scalar fields, field 1 - field 2</a:documentation>
      <attribute name="name">
        <value>scalar_difference</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="scalar_source_field_1"/>
      <ref name="scalar_source_field_2"/>
      <optional>
        <element name="absolute_difference">
          <a:documentation>If enabled, the absolute value of the difference is taken</a:documentation>
          <ref name="comment"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="vector_sum_algorithm">
    <element name="algorithm">
      <a:documentation>Sum of two vector fields</a:documentation>
      <attribute name="name">
        <value>vector_sum</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="vector_source_field_1"/>
      <ref name="vector_source_field_2"/>
    </element>
  </define>
  <define name="vector_difference_algorithm">
    <element name="algorithm">
      <a:documentation>Difference between two vector fields, field 1 - field 2</a:documentation>
      <attribute name="name">
        <value>vector_difference</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="vector_source_field_1"/>
      <ref name="vector_source_field_2"/>
      <optional>
        <element name="absolute_difference">
          <a:documentation>If enabled, the absolute value of the difference is taken</a:documentation>
          <ref name="comment"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="tensor_difference_algorithm">
    <element name="algorithm">
      <a:documentation>Difference between two tensor fields, field 1 - field 2</a:documentation>
      <attribute name="name">
        <value>tensor_difference</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="tensor_source_field_1"/>
      <ref name="tensor_source_field_2"/>
      <optional>
        <element name="absolute_difference">
          <a:documentation>If enabled, the absolute value of the difference is taken</a:documentation>
          <ref name="comment"/>
        </element>
      </optional>
    </element>
  </define>
  <!-- Time aggregated diagnostics -->
  <!-- Temporal maximum diagnostic algorithm for scalar fields. -->
  <define name="scalar_temporalmax_algorithm">
    <element name="algorithm">
      <a:documentation>temporalmax (scalar source field). Calculates the nodewise maximum over time. Note: Does not work with adaptive meshes!</a:documentation>
      <attribute name="name">
        <value>temporalmax_scalar</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <attribute name="persistent">
        <value>true</value>
      </attribute>
      <ref name="scalar_source_field"/>
      <optional>
        <element name="spin_up_time">
          <a:documentation>This sets a spinning up time.</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
      <optional>
        <element name="initial_condition">
          <a:documentation>Do not set an initial condition until you know what you are doing. Initial condition is mainly needed for checkpointing. </a:documentation>
          <attribute name="name">
            <value>WholeMesh</value>
          </attribute>
          <ref name="input_choice_initial_condition_real"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="vector_temporalmax_algorithm">
    <element name="algorithm">
      <a:documentation>temporalmax (vector source field). Calculates the nodewise maximum over time. Note: Does not work with adaptive meshes!</a:documentation>
      <attribute name="name">
        <value>temporalmax_vector</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <attribute name="persistent">
        <value>true</value>
      </attribute>
      <ref name="vector_source_field"/>
      <optional>
        <element name="spin_up_time">
          <a:documentation>This sets a spinning up time.</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
      <optional>
        <element name="initial_condition">
          <a:documentation>Do not set an initial condition until you know what you are doing. Initial condition is mainly needed for checkpointing. </a:documentation>
          <attribute name="name">
            <value>WholeMesh</value>
          </attribute>
          <ref name="input_choice_initial_condition_real"/>
        </element>
      </optional>
    </element>
  </define>
  <!-- Temporal minimum diagnostic algorithm -->
  <define name="temporalmin_algorithm">
    <element name="algorithm">
      <a:documentation>temporalmin (source field). Calculates the nodewise minimum over time. Note: Does not work with adaptive meshes!</a:documentation>
      <attribute name="name">
        <value>temporalmin</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <attribute name="persistent">
        <value>true</value>
      </attribute>
      <ref name="scalar_source_field"/>
      <optional>
        <element name="spin_up_time">
          <a:documentation>This sets a spinning up time.</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
      <optional>
        <element name="initial_condition">
          <a:documentation>Do not set an initial condition until you know what you are doing. Initial condition is mainly needed for checkpointing. </a:documentation>
          <attribute name="name">
            <value>WholeMesh</value>
          </attribute>
          <ref name="input_choice_initial_condition_real"/>
        </element>
      </optional>
    </element>
  </define>
  <!-- Differential operator diagnostic algorithms -->
  <define name="div_algorithm">
    <element name="algorithm">
      <a:documentation>div (source field)</a:documentation>
      <attribute name="name">
        <value>div</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="vector_source_field"/>
    </element>
  </define>
  <define name="finite_element_divergence_algorithm">
    <element name="algorithm">
      <a:documentation>div (source field)
Divergence of the velocity field where
the divergence operator is defined using
the finite element C^T matrix.</a:documentation>
      <attribute name="name">
        <value>finite_element_divergence</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="vector_source_field"/>
      <optional>
        <element name="integrate_divergence_by_parts">
          <a:documentation>Integrate the divergence operator by parts</a:documentation>
          <ref name="comment"/>
        </element>
      </optional>
      <choice>
        <element name="solver">
          <a:documentation>Consistent mass Galerkin projection of divergence. Requires
solver options.</a:documentation>
          <ref name="linear_solver_options_sym"/>
        </element>
        <element name="lump_mass">
          <a:documentation>Lumped mass Galerkin projection of divergence</a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <define name="finite_element_divergence_transpose_algorithm">
    <element name="algorithm">
      <a:documentation>Gradient of a scalar field evaluated using the transpose
of the C^T divergence matrix constructed using finite
elements.</a:documentation>
      <attribute name="name">
        <value>finite_element_divergence_transpose</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="vector_source_field"/>
      <optional>
        <element name="bc_field">
          <a:documentation>Use boundary conditions from this vector field</a:documentation>
          <attribute name="name">
            <data type="string"/>
          </attribute>
          <ref name="comment"/>
        </element>
      </optional>
      <optional>
        <element name="integrate_divergence_by_parts">
          <a:documentation>Integrate the divergence operator by parts</a:documentation>
          <ref name="comment"/>
        </element>
      </optional>
      <ref name="comment"/>
    </element>
  </define>
  <define name="grad_algorithm">
    <element name="algorithm">
      <a:documentation>grad (source field)</a:documentation>
      <attribute name="name">
        <value>grad</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="scalar_source_field"/>
    </element>
  </define>
  <define name="perp_algorithm">
    <element name="algorithm">
      <a:documentation>[curl (z_hat source field). Valid in 2D only.</a:documentation>
      <attribute name="name">
        <value>perp</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="scalar_source_field"/>
      <optional>
        <ref name="galerkin_projection_mass_options"/>
      </optional>
      <ref name="comment"/>
    </element>
  </define>
  <define name="curl_2d_algorithm">
    <element name="algorithm">
      <a:documentation>[curl (source field)]_z. Valid in 2D only.</a:documentation>
      <attribute name="name">
        <value>curl_2d</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="vector_source_field"/>
      <optional>
        <ref name="galerkin_projection_mass_options"/>
      </optional>
      <ref name="comment"/>
    </element>
  </define>
  <define name="vorticity_2d_algorithm">
    <element name="algorithm">
      <a:documentation>[curl (source field)]_z. Valid in 2D only.</a:documentation>
      <attribute name="name">
        <value>curl_2d</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <attribute name="source_field_name">
        <value>Velocity</value>
      </attribute>
      <optional>
        <ref name="galerkin_projection_mass_options"/>
      </optional>
      <ref name="comment"/>
    </element>
  </define>
  <define name="curl_algorithm">
    <element name="algorithm">
      <a:documentation>curl (source field). Valid in 3D only.</a:documentation>
      <attribute name="name">
        <value>curl</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="vector_source_field"/>
      <optional>
        <ref name="galerkin_projection_mass_options"/>
      </optional>
      <ref name="comment"/>
    </element>
  </define>
  <define name="vorticity_algorithm">
    <element name="algorithm">
      <a:documentation>curl (source field). Valid in 3D only.</a:documentation>
      <attribute name="name">
        <value>curl</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <attribute name="source_field_name">
        <value>Velocity</value>
      </attribute>
      <optional>
        <ref name="galerkin_projection_mass_options"/>
      </optional>
      <ref name="comment"/>
    </element>
  </define>
  <define name="scalar_advection_algorithm">
    <element name="algorithm">
      <a:documentation>u dot nabla (source field)</a:documentation>
      <attribute name="name">
        <value>scalar_advection</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="scalar_source_field"/>
    </element>
  </define>
  <define name="vector_advection_algorithm">
    <element name="algorithm">
      <a:documentation>u dot nabla (source field)</a:documentation>
      <attribute name="name">
        <value>vector_advection</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="vector_source_field"/>
    </element>
  </define>
  <define name="scalar_laplacian_algorithm">
    <element name="algorithm">
      <a:documentation>nabla^2 (source field). Applies natural boundary conditions on all
boundaries.</a:documentation>
      <attribute name="name">
        <value>scalar_laplacian</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="scalar_source_field"/>
    </element>
  </define>
  <define name="vector_laplacian_algorithm">
    <element name="algorithm">
      <a:documentation>nabla^2 (source field). Applies natural boundary conditions on all
boundaries.</a:documentation>
      <attribute name="name">
        <value>vector_laplacian</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="vector_source_field"/>
    </element>
  </define>
  <define name="grad_vector_algorithm">
    <element name="algorithm">
      <a:documentation>algorithm for the full tensor gradient of a vector field</a:documentation>
      <attribute name="name">
        <value>grad_vector</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single </value>
      </attribute>
      <ref name="vector_source_field"/>
    </element>
  </define>
  <define name="strain_rate_algorithm">
    <element name="algorithm">
      <a:documentation>algorithm for the strain rate of a vector field</a:documentation>
      <attribute name="name">
        <value>strain_rate</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single </value>
      </attribute>
      <ref name="vector_source_field"/>
    </element>
  </define>
  <define name="tensor_second_invariant_algorithm">
    <element name="algorithm">
      <a:documentation>algorithm for the second invariant of a tensor field</a:documentation>
      <attribute name="name">
        <value>tensor_second_invariant</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single </value>
      </attribute>
      <ref name="tensor_source_field"/>
    </element>
  </define>
  <define name="strain_rate_second_invariant_algorithm">
    <element name="algorithm">
      <a:documentation>Algorithm for the second invariant of the strain_rate tensor field.
Note that the strain rate tensor is calculated automatically as a part
of this algorithm and, hence, a separate tensor field is not required.</a:documentation>
      <attribute name="name">
        <value>strain_rate_second_invariant</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single </value>
      </attribute>
    </element>
  </define>
  <define name="hessian_algorithm">
    <element name="algorithm">
      <a:documentation>algorithm for the Hessian (2nd derivative) of a scalar field</a:documentation>
      <attribute name="name">
        <value>hessian</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single </value>
      </attribute>
      <ref name="scalar_source_field"/>
    </element>
  </define>
  <!-- Surface diagnostics -->
  <define name="grad_normal_algorithm">
    <element name="algorithm">
      <a:documentation> /
 | grad (source field) dot dn
 /

The output is P0 on the surface. Errors will occur at domain edges -
this is a limitation of current output formats.</a:documentation>
      <attribute name="name">
        <value>grad_normal</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="scalar_source_field"/>
      <optional>
        <element name="surface_ids">
          <a:documentation>Surface IDs defining the surface over which to compute the
diagnostic. If disabled, computes over the whole surface.</a:documentation>
          <ref name="integer_vector"/>
        </element>
      </optional>
    </element>
  </define>
  <!-- Momentum diagnostics -->
  <define name="buoyancy_algorithm">
    <element name="algorithm">
      <a:documentation>Computes the buoyancy term. Must be on the VelocityBuoyancyDensity mesh.</a:documentation>
      <attribute name="name">
        <value>buoyancy</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
    </element>
  </define>
  <define name="coriolis_algorithm">
    <element name="algorithm">
      <a:documentation>Interpolates the Coriolis term onto the mesh of this diagnostic field</a:documentation>
      <attribute name="name">
        <value>coriolis</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <attribute name="depends">
        <value>Velocity</value>
      </attribute>
      <choice>
        <element name="consistent_interpolation">
          <a:documentation>Consistently interpolate Coriolis onto this mesh</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="galerkin_projection">
          <a:documentation>Galerkin project Coriolis onto this mesh</a:documentation>
          <ref name="galerkin_projection_mass_options"/>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <define name="scalar_potential_algorithm">
    <element name="algorithm">
      <a:documentation>Compute the scalar potential phi where:
  F = nabla phi + nabla x A + H
with a Neumann boundary condition of nabla phi dot n = F dot n on
all boundaries.</a:documentation>
      <attribute name="name">
        <value>scalar_potential</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="vector_source_field"/>
      <optional>
        <element name="reference_node">
          <a:documentation>Solver reference node</a:documentation>
          <ref name="integer"/>
        </element>
      </optional>
      <element name="solver">
        <a:documentation>Linear solver options.</a:documentation>
        <ref name="linear_solver_options_sym"/>
      </element>
    </element>
  </define>
  <define name="projection_scalar_potential_algorithm">
    <element name="algorithm">
      <a:documentation>Compute the scalar potential phi where:
  F = nabla phi + nabla x A + H
using a pressure projection method</a:documentation>
      <attribute name="name">
        <value>projection_scalar_potential</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="vector_source_field_1"/>
      <optional>
        <element name="source_field_2_name">
          <a:documentation>If enabled, applies geopressure preconditioning using this field</a:documentation>
          <attribute name="source_field_2_type">
            <value>scalar</value>
          </attribute>
          <ref name="anystring"/>
        </element>
      </optional>
      <optional>
        <element name="bc_field">
          <a:documentation>Use boundary conditions from this vector field, instead of the
source field.</a:documentation>
          <attribute name="name">
            <data type="string"/>
          </attribute>
          <ref name="comment"/>
        </element>
      </optional>
      <element name="spatial_discretisation">
        <a:documentation>Spatial discretisation options</a:documentation>
        <element name="mass">
          <a:documentation>Options relating to the mass matrix</a:documentation>
          <optional>
            <element name="lump_mass">
              <a:documentation>Lump the mass matrix. Required for continuous fields.</a:documentation>
              <ref name="comment"/>
            </element>
          </optional>
        </element>
        <element name="continuous_galerkin">
          <a:documentation>Use a continuous Galerkin discretisation</a:documentation>
          <optional>
            <element name="integrate_divergence_by_parts">
              <a:documentation>Integrate the divergence operator by parts</a:documentation>
              <ref name="comment"/>
            </element>
          </optional>
          <optional>
            <element name="remove_stabilisation_term">
              <a:documentation>Remove the stabilisation term from the projection operator.

Automatic when not using P1P1.</a:documentation>
              <ref name="comment"/>
            </element>
          </optional>
          <ref name="comment"/>
        </element>
      </element>
      <optional>
        <element name="reference_node">
          <a:documentation>Solver reference node</a:documentation>
          <ref name="integer"/>
        </element>
      </optional>
      <element name="solver">
        <a:documentation>Linear solver options.</a:documentation>
        <ref name="linear_solver_options_sym"/>
      </element>
    </element>
  </define>
  <define name="geostrophic_velocity_algorithm">
    <element name="algorithm">
      <a:documentation>Compute the velocity in geostrophic balance with a pressure field</a:documentation>
      <attribute name="name">
        <value>geostrophic_velocity</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <attribute name="depends">
        <value>Velocity</value>
      </attribute>
      <ref name="scalar_source_field"/>
      <element name="mass">
        <a:documentation>Options relating to the mass matrix</a:documentation>
        <optional>
          <ref name="galerkin_projection_mass_options"/>
        </optional>
      </element>
      <optional>
        <element name="integrate_divergence_by_parts">
          <a:documentation>Integrate the divergence operator by parts</a:documentation>
          <ref name="comment"/>
        </element>
      </optional>
      <optional>
        <element name="scale_factor">
          <a:documentation>Scale the computed geostrophic velocity by some factor. This is
useful if the pressure field is divided by some reference value
e.g., in a shallow water with gravity magnitude g, this should
take the value g.</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="bulk_viscosity_algorithm">
    <element name="algorithm">
      <a:documentation>The average (or bulk) viscosity formed from the MaterialViscosity for
each material_phase, weighted according to the MaterialVolumeFraction
from each material_phase.</a:documentation>
      <attribute name="name">
        <value>bulk_viscosity</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>multiple</value>
      </attribute>
      <attribute name="depends">
        <value>MaterialViscosity</value>
      </attribute>
      <choice>
        <element name="mean">
          <a:documentation>Use an arithmetic mean (default):

  \bar\nu = \alpha^i\nu^i
 
where \bar\nu is the bulk viscosity, \alpha^i is the volume fraction
for material i and \nu^i is the viscosity of material i.</a:documentation>
          <attribute name="name">
            <value>arithmetic</value>
          </attribute>
          <empty/>
        </element>
        <element name="mean">
          <a:documentation>Use a harmonic mean:

  1./\bar\nu = \alpha^i/\nu^i
 
where \bar\nu is the bulk viscosity, \alpha^i is the volume fraction
for material i and \nu^i is the viscosity of material i.</a:documentation>
          <attribute name="name">
            <value>harmonic</value>
          </attribute>
          <empty/>
        </element>
        <element name="mean">
          <a:documentation>Use a geometric mean:

  \bar\nu = (\nu^i)^(\alpha^i)
 
where \bar\nu is the bulk viscosity, \alpha^i is the volume fraction
for material i and \nu^i is the viscosity of material i.</a:documentation>
          <attribute name="name">
            <value>geometric</value>
          </attribute>
          <empty/>
        </element>
      </choice>
    </element>
  </define>
  <define name="sediment_concentration_dependent_viscosity_algorithm">
    <element name="algorithm">
      <a:documentation>Effective viscosity is affected by sediment concentration. This 
algorithm computes the viscosity based upon the combined concentrations
of the sediment fields and the zero concentration viscosity

  \nu = \nu_0(1-c/0.65)^{-1.625}
</a:documentation>
      <attribute name="name">
        <value>sediment_concentration_dependent_viscosity</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
    </element>
  </define>
  <define name="imposed_material_velocity_source_algorithm">
    <element name="algorithm">
      <attribute name="name">
        <value>imposed_material_velocity_source</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>multiple </value>
      </attribute>
      <attribute name="depends">
        <value>VelocityAbsorption</value>
      </attribute>
    </element>
  </define>
  <define name="imposed_material_velocity_absorption_algorithm">
    <element name="algorithm">
      <attribute name="name">
        <value>imposed_material_velocity_absorption</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>multiple </value>
      </attribute>
      <optional>
        <element name="relaxation_factor">
          <a:documentation>Time relaxation factor, defaults to 1 if not selected.</a:documentation>
          <ref name="real_dim_vector"/>
        </element>
      </optional>
    </element>
  </define>
  <!-- Parallel diagnostics -->
  <define name="node_halo_diagnostic_algorithm">
    <element name="algorithm">
      <a:documentation>Paints the node halo.</a:documentation>
      <attribute name="name">
        <value>node_halo</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
    </element>
  </define>
  <define name="universal_numbering_diagnostic_algorithm">
    <element name="algorithm">
      <a:documentation>The nodal universal numbering.</a:documentation>
      <attribute name="name">
        <value>universal_numbering</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
    </element>
  </define>
  <define name="element_halo_diagnostic_algorithm">
    <element name="algorithm">
      <a:documentation>Paints the element halo. Requires a degree 0 mesh.</a:documentation>
      <attribute name="name">
        <value>element_halo</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
    </element>
  </define>
  <define name="element_ownership_algorithm">
    <element name="algorithm">
      <a:documentation>The element halo ownership. Requires a degree 0 mesh.</a:documentation>
      <attribute name="name">
        <value>element_ownership</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
    </element>
  </define>
  <define name="element_universal_numbering_algorithm">
    <element name="algorithm">
      <a:documentation>The element halo universal numbering. Requires a degree 0 mesh.</a:documentation>
      <attribute name="name">
        <value>element_universal_numbering</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
    </element>
  </define>
  <!-- Python diagnostics -->
  <define name="scalar_python_diagnostic_algorithm">
    <element name="algorithm">
      <a:documentation>Algorithm for the diagnostic value coded in Python. 
The object 'state' has the attributes 'scalar_fields', 'vector_fields'
and 'tensor_fields';
'field' is the diagnostic field to be set.
'time' and 'dt' are the current time and timestep.</a:documentation>
      <attribute name="name">
        <value>scalar_python_diagnostic</value>
      </attribute>
      <attribute name="material_phase_support">
        <choice>
          <value>single</value>
          <value>multiple</value>
        </choice>
      </attribute>
      <ref name="python_code"/>
      <optional>
        <element name="depends">
          <a:documentation>Enable to specify dependencies manually. Any field specified here
will be calculated before this python diagnostic field.

Fields should be a comma delimited list.
If fields from other material_phases are required, use the :: operator.
For example, if the other material_phase's name is Water, and the
field name is Velocity, then use:

Water::Velocity</a:documentation>
          <ref name="anystring"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="vector_python_diagnostic_algorithm">
    <element name="algorithm">
      <a:documentation>Algorithm for the diagnostic value coded in Python. 
The object 'state' has the attributes 'scalar_fields', 'vector_fields'
and 'tensor_fields';
'field' is the diagnostic field to be set.
'time' and 'dt' are the current time and timestep.</a:documentation>
      <attribute name="name">
        <value>vector_python_diagnostic</value>
      </attribute>
      <attribute name="material_phase_support">
        <choice>
          <value>single</value>
          <value>multiple</value>
        </choice>
      </attribute>
      <ref name="python_code"/>
      <optional>
        <element name="depends">
          <a:documentation>Enable to specify dependencies manually. Any field specified here
will be calculated before this python diagnostic field.

Fields should be a comma delimited list.
If fields from other material_phases are required, use the :: operator.
For example, if the other material_phase's name is Water, and the
field name is Velocity, then use:

Water::Velocity</a:documentation>
          <ref name="anystring"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="tensor_python_diagnostic_algorithm">
    <element name="algorithm">
      <a:documentation>Algorithm for the diagnostic value coded in Python. 
The object 'state' has the attributes 'scalar_fields', 'vector_fields'
and 'tensor_fields';
'field' is the diagnostic field to be set.
'time' and 'dt' are the current time and timestep.</a:documentation>
      <attribute name="name">
        <value>tensor_python_diagnostic</value>
      </attribute>
      <attribute name="material_phase_support">
        <choice>
          <value>single</value>
          <value>multiple</value>
        </choice>
      </attribute>
      <ref name="python_code"/>
      <optional>
        <element name="depends">
          <a:documentation>Enable to specify dependencies manually. Any field specified here
will be calculated before this python diagnostic field.

Fields should be a comma delimited list.
If fields from other material_phases are required, use the :: operator.
For example, if the other material_phase's name is Water, and the
field name is Velocity, then use:

Water::Velocity</a:documentation>
          <ref name="anystring"/>
        </element>
      </optional>
    </element>
  </define>
  <!-- Adaptivity diagnostics -->
  <define name="scalar_edge_lengths_algorithm">
    <element name="algorithm">
      <a:documentation>Computes the edge lengths of the Coordinate mesh</a:documentation>
      <attribute name="name">
        <value>scalar_edge_lengths</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
    </element>
  </define>
  <define name="field_tolerance_algorithm">
    <element name="algorithm">
      <a:documentation>From a field on a mesh, diagnose the anisotropic
interpolation weight that would give the mesh back.
It is computed as:
\Eps = M^-1 |H|</a:documentation>
      <attribute name="name">
        <value>field_tolerance</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="component_source_field"/>
      <optional>
        <element name="p_norm">
          <a:documentation>Scale the Hessian to return the L_p norm tolerance, rather than the
default L_inf norm tolerance. See
Chen Sun and Zu, Mathematics of Computation, Volume 76,
Number 257, January 2007, pp. 179-204.</a:documentation>
          <ref name="integer"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="eigenvalues_symmetric_algorithm">
    <element name="algorithm">
      <a:documentation>Computes the eigenvalues of a given symmetric tensor field. The output
eigenvalues are sorted from lowest to highest.</a:documentation>
      <attribute name="name">
        <value>eigenvalues_symmetric</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="tensor_source_field"/>
    </element>
  </define>
  <!-- Tidal Harmonic Analysis algorithms -->
  <define name="free_surface_history_algorithm">
    <element name="algorithm">
      <a:documentation>Needed for the tidal harmonic algorithm.
Implemented as a queue data structure.</a:documentation>
      <attribute name="name">
        <value>free_surface_history</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <attribute name="depends">
        <value>FreeSurface</value>
      </attribute>
      <optional>
        <element name="levels">
          <a:documentation>levels: Number of levels which should be saved in the history. Default value: 50</a:documentation>
          <ref name="integer"/>
        </element>
      </optional>
      <optional>
        <element name="stride">
          <a:documentation>stride: number of timelvel skips before saving the next free surface field in the history. Default value: 5</a:documentation>
          <ref name="integer"/>
        </element>
      </optional>
      <optional>
        <element name="spin_up_time">
          <a:documentation>spin_up time: Default value: 0</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
      <optional>
        <element name="calculation_period">
          <a:documentation>How often to calculate the harmonics. Default is just before output dumps. You can set this
variable to calculate the diagnostics more often if required. 0 would calculate every timestep
Note: harmonic calaulations are quite expensive. The value below applies to all tidal harmonics
in the simulation</a:documentation>
          <ref name="integer"/>
        </element>
      </optional>
      <optional>
        <element name="saved_snapshots_times">
          <a:documentation>Internal use only</a:documentation>
          <ref name="real_vector"/>
        </element>
      </optional>
      <optional>
        <element name="timestep_counter">
          <a:documentation>Internal use only</a:documentation>
          <ref name="integer"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="tidal_harmonic_algorithm">
    <element name="algorithm">
      <a:documentation>Calculates the (tidal) harmonics of the FreeSurface field. Note that "ocean boundaries" have to be set and the FreeSurface and FreeSurfaceHistory diagnostic field have to be switched on in order to calculate the harmonics successfully. 

By setting averageFSLevel to ForceToZero, C0 is set to zero. Recommended is "Calculate"</a:documentation>
      <attribute name="name">
        <value>tidal_harmonics</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <attribute name="depends">
        <value>FreeSurfaceHistory</value>
      </attribute>
      <attribute name="target">
        <choice>
          <value>Amplitude</value>
          <value>Phase</value>
        </choice>
      </attribute>
      <attribute name="averageFSLevel">
        <choice>
          <value>ForceToZero</value>
          <value>Calculate</value>
        </choice>
      </attribute>
      <choice>
        <element name="constituent">
          <a:documentation>Constant free surface offset (i.e. sigma=0). This can be forced to 0 by setting SetC0toZero to True. </a:documentation>
          <attribute name="name">
            <value>C0</value>
          </attribute>
          <element name="real_value">
            <attribute name="rank">
              <value>0</value>
            </attribute>
            <attribute name="shape">
              <value>1</value>
            </attribute>
            <value>0.0</value>
          </element>
          <ref name="comment"/>
        </element>
        <element name="constituent">
          <a:documentation>M2 constituent.
Taken from E.W. Schwiderski - Rev. Geophys. Space Phys. Vol. 18
No. 1 pp. 243--268, 1980</a:documentation>
          <attribute name="name">
            <value>M2</value>
          </attribute>
          <element name="real_value">
            <attribute name="rank">
              <value>0</value>
            </attribute>
            <attribute name="shape">
              <value>1</value>
            </attribute>
            <value>2.23642934E-05</value>
          </element>
          <ref name="comment"/>
        </element>
        <element name="constituent">
          <a:documentation>S2 constituent.
Taken from E.W. Schwiderski - Rev. Geophys. Space Phys. Vol. 18
No. 1 pp. 243--268, 1980</a:documentation>
          <attribute name="name">
            <value>S2</value>
          </attribute>
          <element name="real_value">
            <attribute name="rank">
              <value>0</value>
            </attribute>
            <attribute name="shape">
              <value>1</value>
            </attribute>
            <value>2.31481315E-05</value>
          </element>
          <ref name="comment"/>
        </element>
        <element name="constituent">
          <a:documentation>N2 constituent.
Taken from E.W. Schwiderski - Rev. Geophys. Space Phys. Vol. 18
No. 1 pp. 243--268, 1980</a:documentation>
          <attribute name="name">
            <value>N2</value>
          </attribute>
          <element name="real_value">
            <attribute name="rank">
              <value>0</value>
            </attribute>
            <attribute name="shape">
              <value>1</value>
            </attribute>
            <value>2.19442836E-05</value>
          </element>
          <ref name="comment"/>
        </element>
        <element name="constituent">
          <a:documentation>K2 constituent.
Taken from E.W. Schwiderski - Rev. Geophys. Space Phys. Vol. 18
No. 1 pp. 243--268, 1980</a:documentation>
          <attribute name="name">
            <value>K2</value>
          </attribute>
          <element name="real_value">
            <attribute name="rank">
              <value>0</value>
            </attribute>
            <attribute name="shape">
              <value>1</value>
            </attribute>
            <value>2.32114752E-05</value>
          </element>
          <ref name="comment"/>
        </element>
        <element name="constituent">
          <a:documentation>K1 constituent.
Taken from E.W. Schwiderski - Rev. Geophys. Space Phys. Vol. 18
No. 1 pp. 243--268, 1980</a:documentation>
          <attribute name="name">
            <value>K1</value>
          </attribute>
          <element name="real_value">
            <attribute name="rank">
              <value>0</value>
            </attribute>
            <attribute name="shape">
              <value>1</value>
            </attribute>
            <value>1.16057376E-05</value>
          </element>
          <ref name="comment"/>
        </element>
        <element name="constituent">
          <a:documentation>O1 constituent.
Taken from E.W. Schwiderski - Rev. Geophys. Space Phys. Vol. 18
No. 1 pp. 243--268, 1980</a:documentation>
          <attribute name="name">
            <value>O1</value>
          </attribute>
          <element name="real_value">
            <attribute name="rank">
              <value>0</value>
            </attribute>
            <attribute name="shape">
              <value>1</value>
            </attribute>
            <value>1.07585558E-05</value>
          </element>
          <ref name="comment"/>
        </element>
        <element name="constituent">
          <a:documentation>P1 constituent.
Taken from E.W. Schwiderski - Rev. Geophys. Space Phys. Vol. 18
No. 1 pp. 243--268, 1980</a:documentation>
          <attribute name="name">
            <value>P1</value>
          </attribute>
          <element name="real_value">
            <attribute name="rank">
              <value>0</value>
            </attribute>
            <attribute name="shape">
              <value>1</value>
            </attribute>
            <value>1.15423939E-05</value>
          </element>
          <ref name="comment"/>
        </element>
        <element name="constituent">
          <a:documentation>Q1 constituent.
Taken from E.W. Schwiderski - Rev. Geophys. Space Phys. Vol. 18
No. 1 pp. 243--268, 1980</a:documentation>
          <attribute name="name">
            <value>Q1</value>
          </attribute>
          <element name="real_value">
            <attribute name="rank">
              <value>0</value>
            </attribute>
            <attribute name="shape">
              <value>1</value>
            </attribute>
            <value>1.03385459E-05</value>
          </element>
          <ref name="comment"/>
        </element>
        <element name="constituent">
          <a:documentation>Mf constituent.
Taken from E.W. Schwiderski - Rev. Geophys. Space Phys. Vol. 18
No. 1 pp. 243--268, 1980</a:documentation>
          <attribute name="name">
            <value>Mf</value>
          </attribute>
          <element name="real_value">
            <attribute name="rank">
              <value>0</value>
            </attribute>
            <attribute name="shape">
              <value>1</value>
            </attribute>
            <value>8.47245424E-07</value>
          </element>
          <ref name="comment"/>
        </element>
        <element name="constituent">
          <a:documentation>Mm constituent.
Taken from E.W. Schwiderski - Rev. Geophys. Space Phys. Vol. 18
No. 1 pp. 243--268, 1980</a:documentation>
          <attribute name="name">
            <value>Mm</value>
          </attribute>
          <element name="real_value">
            <attribute name="rank">
              <value>0</value>
            </attribute>
            <attribute name="shape">
              <value>1</value>
            </attribute>
            <value>4.20041726E-07</value>
          </element>
          <ref name="comment"/>
        </element>
        <element name="constituent">
          <a:documentation>Ssa constituent.
Taken from E.W. Schwiderski - Rev. Geophys. Space Phys. Vol. 18
No. 1 pp. 243--268, 1980</a:documentation>
          <attribute name="name">
            <value>Ssa</value>
          </attribute>
          <element name="real_value">
            <attribute name="rank">
              <value>0</value>
            </attribute>
            <attribute name="shape">
              <value>1</value>
            </attribute>
            <value>6.33754983E-08</value>
          </element>
          <ref name="comment"/>
        </element>
        <element name="constituent">
          <a:documentation>The constituent Residual calculates the residual free surface amplitude after substracting the calculated constituents. The target must be set to Amplitude.</a:documentation>
          <attribute name="name">
            <value>Residual</value>
          </attribute>
          <ref name="comment"/>
        </element>
        <element name="constituent">
          <a:documentation>Custom defined frequencies (in 1/s).</a:documentation>
          <attribute name="name">
            <value>custom</value>
          </attribute>
          <ref name="real"/>
        </element>
      </choice>
    </element>
  </define>
  <!-- Multiphase diagnostic algorithms -->
  <define name="particle_reynolds_number_algorithm">
    <element name="algorithm">
      <a:documentation>Diagnostic algorithm used in multiphase simulations.
Calculates the particle Reynolds number, (vfrac_f*density_f * |u_f - u_p| * d)/viscosity_f
where the subscripts _f and _p denote the fluid (i.e. continuous) and particle (i.e. dispersed)
phases respectively, and d is the particle diameter.</a:documentation>
      <attribute name="name">
        <value>particle_reynolds_number</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>multiple</value>
      </attribute>
      <element name="depends">
        <a:documentation>The particle Reynolds number depends on the Velocity field of both the continuous and dispersed phases,
and also the Density, PhaseVolumeFraction and Viscosity fields of the continuous phase.</a:documentation>
        <ref name="anystring"/>
      </element>
      <choice>
        <a:documentation>The particle diameter</a:documentation>
        <element name="particle_diameter">
          <ref name="real"/>
        </element>
        <element name="particle_diameter_use_scalar_field">
          <ref name="anystring"/>
        </element>
      </choice>
      <element name="continuous_phase_name">
        <a:documentation>The name of the state representing the continuous phase</a:documentation>
        <data type="string" datatypeLibrary=""/>
      </element>
    </element>
  </define>
  <define name="apparent_density_algorithm">
    <element name="algorithm">
      <a:documentation>Diagnostic algorithm used in multiphase flow simulations.
Calculates the apparent density of the material_phase,
i.e. Density multiplied by the PhaseVolumeFraction field.</a:documentation>
      <attribute name="name">
        <value>apparent_density</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>multiple</value>
      </attribute>
    </element>
  </define>
  <!-- Misc -->
  <!-- l2norm diagnostic algorithm -->
  <define name="l2norm_algorithm">
    <element name="algorithm">
      <a:documentation>l2norm (source field). Calculates the nodewise l2norm of a vector field.</a:documentation>
      <attribute name="name">
        <value>l2norm</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="vector_source_field"/>
    </element>
  </define>
  <!-- Mesh -->
  <define name="region_id_algorithm">
    <element name="algorithm">
      <a:documentation>Convert the region_ids to a field. This field must be on a P0 mesh
(i.e. degree 0 and discontinuous) as these are element-wise values.</a:documentation>
      <attribute name="name">
        <value>region_ids</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
    </element>
  </define>
  <define name="column_id_algorithm">
    <element name="algorithm">
      <a:documentation>Convert the column_ids to a field.

The mesh must be directly extruded.</a:documentation>
      <attribute name="name">
        <value>column_ids</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
    </element>
  </define>
  <define name="universal_column_id_algorithm">
    <element name="algorithm">
      <a:documentation>Convert the universal column_ids to a field.

The mesh must be directly extruded.</a:documentation>
      <attribute name="name">
        <value>universal_column_ids</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
    </element>
  </define>
  <define name="mesh_quality_algorithm">
    <element name="algorithm">
      <a:documentation>Mesh Quality function. Basics taken from VTK. See the documentation
there for further details of specific function choices.

The output mesh for this field must be discontinous P0 and the
underlying CoordinateMesh must consist of linear triangles
 or tetrahedra only.</a:documentation>
      <attribute name="name">
        <value>mesh_quality</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <choice>
        <element name="quality_function">
          <attribute name="name">
            <value>radius_ratio</value>
          </attribute>
        </element>
        <element name="quality_function">
          <attribute name="name">
            <value>aspect_ratio</value>
          </attribute>
        </element>
        <element name="quality_function">
          <attribute name="name">
            <value>aspect_frobenius</value>
          </attribute>
        </element>
        <element name="quality_function">
          <attribute name="name">
            <value>edge_ratio</value>
          </attribute>
        </element>
        <element name="quality_function">
          <attribute name="name">
            <value>condition</value>
          </attribute>
        </element>
        <element name="quality_function">
          <attribute name="name">
            <value>min_angle</value>
          </attribute>
        </element>
        <element name="quality_function">
          <attribute name="name">
            <value>max_angle</value>
          </attribute>
        </element>
        <element name="quality_function">
          <attribute name="name">
            <value>shape</value>
          </attribute>
        </element>
        <element name="quality_function">
          <attribute name="name">
            <value>shape_and_size</value>
          </attribute>
        </element>
        <element name="quality_function">
          <attribute name="name">
            <value>area_or_volume</value>
          </attribute>
        </element>
      </choice>
    </element>
  </define>
  <define name="viscous_dissipation_algorithm">
    <element name="algorithm">
      <a:documentation>algorithm for calculating the viscous dissipation.</a:documentation>
      <attribute name="name">
        <value>viscous_dissipation</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single </value>
      </attribute>
    </element>
  </define>
  <!-- Mass matrix -->
  <define name="finite_element_lumped_mass_matrix">
    <element name="algorithm">
      <a:documentation>The finite element lumped mass matrix.</a:documentation>
      <attribute name="name">
        <value>finite_element_lumped_mass_matrix</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
    </element>
  </define>
  <define name="control_volume_mass_matrix">
    <element name="algorithm">
      <a:documentation>The control volume mass matrix.</a:documentation>
      <attribute name="name">
        <value>control_volume_mass_matrix</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
    </element>
  </define>
  <!-- Time averaged fields -->
  <define name="scalar_time_averaged_algorithm">
    <element name="algorithm">
      <a:documentation>Algorithm for time averaging scalar fields.
This field needs to be interpolated between adapts.</a:documentation>
      <attribute name="name">
        <value>time_averaged_scalar</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="scalar_source_field"/>
      <optional>
        <element name="spin_up_time">
          <a:documentation>When to start sampling? Defaults to simulation start time.</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
      <optional>
        <element name="absolute_values">
          <a:documentation>If enabled, the average of the absolute value is taken</a:documentation>
          <ref name="comment"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="scalar_period_averaged_algorithm">
    <element name="algorithm">
      <a:documentation>Algorithm for calulating an average of a scalar field over 
a set period, e.g. daily
Note that we assume the simulation starts at zero for the
averaging period,
This field needs to be interpolated between adapts.</a:documentation>
      <attribute name="name">
        <value>period_averaged_scalar</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="scalar_source_field"/>
      <element name="averaging_period">
        <a:documentation>Over what time period to average over?</a:documentation>
        <ref name="real"/>
      </element>
    </element>
  </define>
  <define name="scalar_squared_time_averaged_algorithm">
    <element name="algorithm">
      <a:documentation>Algorithm for time averaging squared scalar fields.
This field needs to be interpolated between adapts.</a:documentation>
      <attribute name="name">
        <value>time_averaged_scalar_squared</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="scalar_source_field"/>
      <optional>
        <element name="spin_up_time">
          <a:documentation>When to start sampling? Defaults to simulation start time.</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="vector_time_averaged_algorithm">
    <element name="algorithm">
      <a:documentation>Algorithm for time averaging vector fields.
This field needs to be interpolated between adapts.</a:documentation>
      <attribute name="name">
        <value>time_averaged_vector</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="vector_source_field"/>
      <optional>
        <element name="spin_up_time">
          <a:documentation>When to start sampling?  Defaults to simulation start time.</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
      <optional>
        <element name="absolute_values">
          <a:documentation>If enabled, the average of the absolute value is taken</a:documentation>
          <ref name="comment"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="vector_scalar_time_averaged_algorithm">
    <element name="algorithm">
      <a:documentation>Algorithm for time averaging vector times scalar fields.
This field needs to be interpolated between adapts.</a:documentation>
      <attribute name="name">
        <value>time_averaged_vector_times_scalar</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="vector_source_field_1"/>
      <ref name="scalar_source_field_2"/>
      <optional>
        <element name="spin_up_time">
          <a:documentation>When to start sampling?  Defaults to simulation start time.</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
    </element>
  </define>
  <!-- surface algorithm -->
  <define name="surface_horizontal_divergence_algorithm">
    <element name="algorithm">
      <a:documentation>Algorithm calculates the horizontally restricted divergence of
a horizontal vector living on the specified surface.</a:documentation>
      <attribute name="name">
        <value>surface_horizontal_divergence</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="vector_source_field"/>
      <element name="surface_ids">
        <ref name="integer_vector"/>
      </element>
    </element>
  </define>
  <define name="subtract_average_algorithm">
    <element name="algorithm">
      <a:documentation>Algorithm that subtracts the average from a scalar field. The integral
of the resulting diagnostic field is therefore zero.

This is useful for fields that are only defined up to a constant. During
their solve it is typically best to remove this freedom by using the 
"remove_null_space" option (which effectively introduces a mesh dependent 
constraint on the sum of the nodal values). For diagnostic purposes however,
it may be useful to impose the more natural constraint that the integrated
average is zero.</a:documentation>
      <attribute name="name">
        <value>subtract_average</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="scalar_source_field"/>
    </element>
  </define>
  <define name="subtract_point_value_algorithm">
    <element name="algorithm">
      <a:documentation>Algorithm that subtracts the scalar field value in a certain point 
from that same field. The resulting diagnostic field will therefore be zero in that point.

This is useful for fields that are only defined up to a constant. It is similar
to pinning using a reference node during the solve, except it is only imposed afterwards.
This can be useful because during the solve it is typically better to pin the 
arbitrary constant with the "remove_null_space" option instead.</a:documentation>
      <attribute name="name">
        <value>subtract_point_value</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="scalar_source_field"/>
      <element name="coordinates">
        <ref name="real_dim_vector">
          <a:documentation>coordinates of the point whose value should be subtracted</a:documentation>
        </ref>
      </element>
    </element>
  </define>
  <define name="subtract_surface_average_algorithm">
    <element name="algorithm">
      <a:documentation>Algorithm that subtracts the surface average from a scalar field. The 
surface integral of the resulting diagnostic field is therefore zero.

This is useful for fields that are only defined up to a constant. During
their solve it is typically best to remove this freedom by using the 
"remove_null_space" option (which effectively introduces a mesh dependent 
constraint on the sum of the nodal values). For diagnostic purposes however,
it may be useful to impose a more natural constraint such as the surface 
integral being zero.</a:documentation>
      <attribute name="name">
        <value>subtract_surface_average</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="scalar_source_field"/>
      <element name="surface_ids">
        <ref name="integer_vector"/>
      </element>
    </element>
  </define>
  <define name="scalar_diagnostic_algorithms">
    <ref name="universal_numbering_diagnostic_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="viscous_dissipation_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="universal_column_id_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="tidal_harmonic_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="tensor_second_invariant_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="strain_rate_second_invariant_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="temporalmin_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="surface_horizontal_divergence_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="scalar_temporalmax_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="scalar_time_averaged_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="scalar_period_averaged_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="scalar_sum_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="scalar_squared_time_averaged_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="scalar_potential_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="scalar_laplacian_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="subtract_surface_average_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="subtract_point_value_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="subtract_average_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="scalar_galerkin_projection_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="scalar_difference_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="scalar_copy_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="scalar_advection_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="scalar_edge_lengths_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="projection_scalar_potential_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="particle_reynolds_number_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="apparent_density_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="node_halo_diagnostic_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="mesh_quality_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="lumped_mass_smoothed_scalar_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="l2norm_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="helmholtz_smoothed_scalar_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="helmholtz_anisotropic_smoothed_scalar_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="grad_normal_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="finite_element_divergence_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="extract_scalar_component_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="element_universal_numbering_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="element_ownership_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="element_halo_diagnostic_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="div_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="curl_2d_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="region_id_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="column_id_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="finite_element_lumped_mass_matrix"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="control_volume_mass_matrix"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="scalar_python_diagnostic_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="internal_algorithm"/>
  </define>
  <define name="vector_diagnostic_algorithms">
    <ref name="vector_time_averaged_algorithm"/>
  </define>
  <define name="vector_diagnostic_algorithms" combine="choice">
    <ref name="vector_temporalmax_algorithm"/>
  </define>
  <define name="vector_diagnostic_algorithms" combine="choice">
    <ref name="vector_sum_algorithm"/>
  </define>
  <define name="vector_diagnostic_algorithms" combine="choice">
    <ref name="vector_scalar_time_averaged_algorithm"/>
  </define>
  <define name="vector_diagnostic_algorithms" combine="choice">
    <ref name="vector_laplacian_algorithm"/>
  </define>
  <define name="vector_diagnostic_algorithms" combine="choice">
    <ref name="vector_galerkin_projection_algorithm"/>
  </define>
  <define name="vector_diagnostic_algorithms" combine="choice">
    <ref name="vector_difference_algorithm"/>
  </define>
  <define name="vector_diagnostic_algorithms" combine="choice">
    <ref name="vector_copy_algorithm"/>
  </define>
  <define name="vector_diagnostic_algorithms" combine="choice">
    <ref name="vector_advection_algorithm"/>
  </define>
  <define name="vector_diagnostic_algorithms" combine="choice">
    <ref name="perp_algorithm"/>
  </define>
  <define name="vector_diagnostic_algorithms" combine="choice">
    <ref name="lumped_mass_smoothed_vector_algorithm"/>
  </define>
  <define name="vector_diagnostic_algorithms" combine="choice">
    <ref name="helmholtz_smoothed_vector_algorithm"/>
  </define>
  <define name="vector_diagnostic_algorithms" combine="choice">
    <ref name="helmholtz_anisotropic_smoothed_vector_algorithm"/>
  </define>
  <define name="vector_diagnostic_algorithms" combine="choice">
    <ref name="grad_algorithm"/>
  </define>
  <define name="vector_diagnostic_algorithms" combine="choice">
    <ref name="geostrophic_velocity_algorithm"/>
  </define>
  <define name="vector_diagnostic_algorithms" combine="choice">
    <ref name="finite_element_divergence_transpose_algorithm"/>
  </define>
  <define name="vector_diagnostic_algorithms" combine="choice">
    <ref name="eigenvalues_symmetric_algorithm"/>
  </define>
  <define name="vector_diagnostic_algorithms" combine="choice">
    <ref name="curl_algorithm"/>
  </define>
  <define name="vector_diagnostic_algorithms" combine="choice">
    <ref name="vector_python_diagnostic_algorithm"/>
  </define>
  <define name="tensor_diagnostic_algorithms">
    <ref name="tensor_copy_algorithm"/>
  </define>
  <define name="tensor_diagnostic_algorithms" combine="choice">
    <ref name="grad_vector_algorithm"/>
  </define>
  <define name="tensor_diagnostic_algorithms" combine="choice">
    <ref name="strain_rate_algorithm"/>
  </define>
  <define name="tensor_diagnostic_algorithms" combine="choice">
    <ref name="hessian_algorithm"/>
  </define>
  <define name="tensor_diagnostic_algorithms" combine="choice">
    <ref name="helmholtz_smoothed_tensor_algorithm"/>
  </define>
  <define name="tensor_diagnostic_algorithms" combine="choice">
    <ref name="helmholtz_anisotropic_smoothed_tensor_algorithm"/>
  </define>
  <define name="tensor_diagnostic_algorithms" combine="choice">
    <ref name="field_tolerance_algorithm"/>
  </define>
  <define name="tensor_diagnostic_algorithms" combine="choice">
    <ref name="tensor_python_diagnostic_algorithm"/>
  </define>
  <define name="tensor_diagnostic_algorithms" combine="choice">
    <ref name="tensor_difference_algorithm"/>
  </define>
</grammar>
