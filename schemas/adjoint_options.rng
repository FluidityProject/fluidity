<?xml version="1.0" encoding="UTF-8"?>
<grammar xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0" xmlns="http://relaxng.org/ns/structure/1.0" datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes">
  <include href="spud_base.rng"/>
  <define name="adjoint_options">
    <element name="adjoint">
      <a:documentation>Turn on the solution of the adjoint problem.
To compute the adjoint you must specify code for the functional
derivative. If the functional is also specified, then it will be
output in the .stat file.</a:documentation>
      <optional>
        <element name="replay_forward_run">
          <a:documentation>Rerun the forward equation using libadjoint. 
This is a debugging option to check if the libadjoint callbacks are implemented correctly.</a:documentation>
          <empty/>
        </element>
      </optional>
      <oneOrMore>
        <element name="functional">
          <a:documentation>A functional to be computed.
If the functional_value is supplied by the user, then the functional gets
evaluated and printed in the .stat files.

If the functional_derivative is supplied by the user, then that is always used.
for the right-hand side of the adjoint computation.
If no functional_derivative is supplied, then automatic differentiation is applied
to compute it from the functional_value.

In short, you must supply at least one of functional_value or functional_derivative,
and you may supply both.</a:documentation>
          <attribute name="name">
            <data type="string"/>
          </attribute>
          <optional>
            <element name="functional_value">
              <a:documentation>The value of the functional to be computed.</a:documentation>
              <element name="algorithm">
                <a:documentation>Python code for the functional. This code is given the following variables:
 n, the current timestep number
 time, the start of the timestep
 dt, the current size of the timestep
 states, which represents the states through time, and may be accessed like
  states[0]["MaterialPhase"].vector_fields["Coordinate"], or
  states[n-1]["MyOtherMaterialPhase"].scalar_fields["Pressure"], etc.
 states will only contain those fields that have been specified in the functional_dependencies element.

 This code must compute a real number J, which is the value of the functional associated with this particular
 timestep.
 
 Here is a simple example for a tracking functional, measuring the L2-norm of the error between the
 solution TracerField and a given field TracerObservations:
 &lt;span font_desc="monospace 10" foreground="blue"&gt;
 import numpy
 observ = states[n]["Fluid"].scalar_fields["TracerObservations"]
 soln   = states[n]["Fluid"].scalar_fields["TracerField"]
 coord  = states[n]["Fluid"].vector_fields["Coordinate"]
 J = 0.0
  
 for ele in range(coord.ele_count):
   t = Transform(coord, ele) # transform to physical
   shape = soln.ele_shape(ele)
   mass = t.shape_shape(shape, shape) # the local mass matrix for this element
   ele_error = observ.ele_val(ele) - soln.ele_val(ele)
   J = J + 0.5 * numpy.dot(ele_error, numpy.dot(mass, ele_error))
 &lt;/span&gt;

 This applies for a steady-state simulation; for a time-dependent simulation
 one should either evaluate the fields at a particular time, or integrate
 through time.
 &lt;span weight="bold"&gt;
 If you intend to use automatic differentiation, and want to use
 primitives such as sin, cos, exp, etc., you must use those
 found in the uncertainties.unumpy package, not those
 found in the numpy or math packages.
 &lt;/span&gt;</a:documentation>
                <attribute name="name">
                  <value>functional_value</value>
                </attribute>
                <ref name="python_code"/>
              </element>
              <element name="reduction">
                <a:documentation>The functional does not exist at any particular point in time; however, the code above is called at every timestep.
This is to allow for temporal localisation. Suppose you wished to compute an integral in time: this allows you to perform
the integral over each element of your time domain separately, and then they must be combined to compute the full value of
the functional. In this example, the relevant reduction would be a sum.</a:documentation>
                <element name="sum">
                  <a:documentation>Sum all of the functional components associated with each timestep to compute the functional</a:documentation>
                  <empty/>
                </element>
              </element>
            </element>
          </optional>
          <optional>
            <element name="functional_derivative">
              <a:documentation>The derivative of the functional at each time level.</a:documentation>
              <element name="algorithm">
                <a:documentation>Python code for the functional derivative. This code is given the following variables:
 n, the timelevel of the field to differentiate with respect to
 times, an array containing the value of time for each timelevel
 states, which represents the states through time, and may be accessed like
  states[0]["MaterialPhase"].vector_fields["Coordinate"], or
  states[n]["MyOtherMaterialPhase"].scalar_fields["Pressure"], etc.
 states will only contain those fields that have been specified in the functional_dependencies element.
 derivative, which is a scalar/vector/tensor field associated with the derivative to be computed.

 This code must set the entries of derivative.val. The code should check which variable we are differentiating
 with respect to by inspecting derivative.name.
 
 Here is a simple example for a tracking functional, measuring the L2-norm of the error between the
 solution TracerField and a given field TracerObservations at each timestep:
 &lt;span font_desc="monospace 10" foreground="blue"&gt;
 import numpy
 observ = states[n]["Fluid"].scalar_fields["TracerObservations"]
 soln   = states[n]["Fluid"].scalar_fields["TracerField"]
 coord  = states[n]["Fluid"].vector_fields["Coordinate"]
 derivative.val[:] = 0.0
  
 if derivative.name == "TracerField": # the functional only depends on this
   for ele in range(coord.ele_count):
     t = Transform(coord, ele) # transform to physical
     shape = soln.ele_shape(ele)
     mass = t.shape_shape(shape, shape) # the local mass matrix for this element
     ele_error = observ.ele_val(ele) - soln.ele_val(ele)
     derivative.addto(derivative.ele_nodes(ele), numpy.dot(mass, ele_error))
 &lt;/span&gt;

 This applies for a steady-state simulation; for a time-dependent simulation
 one should either evaluate the fields at a particular time, or integrate
 through time.</a:documentation>
                <attribute name="name">
                  <value>functional_derivative</value>
                </attribute>
                <ref name="python_code"/>
              </element>
            </element>
          </optional>
          <element name="functional_dependencies">
            <a:documentation>The dependencies of the functional at each time level.</a:documentation>
            <element name="algorithm">
              <a:documentation> Python code for the functional dependencies.
 This code defines a function that informs the model what variables at which time levels
 will be necessary for the functional computation at this point.

 Here is a simple example for a tracking functional, measuring the L2-norm of the error between the
 solution TracerField and a given field TracerObservations at each timestep:
 &lt;span font_desc="monospace 10" foreground="blue"&gt;
 def dependencies(times, timestep):
   return {"Fluid::TracerObservations": [timestep],
                "Fluid::TracerField": [timestep],
                "Fluid::Coordinate": [timestep]}
 &lt;/span&gt;
</a:documentation>
              <attribute name="name">
                <value>functional_dependencies</value>
              </attribute>
              <ref name="python_code"/>
            </element>
          </element>
        </element>
      </oneOrMore>
    </element>
  </define>
  <define name="adjoint_storage">
    <element name="adjoint_storage">
      <a:documentation>Informs the model whether the field should be computed only in the
forward model, the adjoint model, or in both.
If /adjoint is not enabled, this has no effect whatsoever.</a:documentation>
      <choice>
        <element name="exists_in_forward">
          <a:documentation>Include the field only in the forward state.</a:documentation>
          <empty/>
        </element>
        <element name="exists_in_both">
          <a:documentation>Include the field in both the forward and adjoint states.</a:documentation>
          <empty/>
        </element>
        <element name="exists_in_adjoint">
          <a:documentation>Include the field only in the adjoint state.</a:documentation>
          <empty/>
        </element>
      </choice>
    </element>
  </define>
</grammar>
