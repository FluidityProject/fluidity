<?xml version="1.0" encoding="UTF-8"?>
<grammar xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0" xmlns="http://relaxng.org/ns/structure/1.0" datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes">
  <include href="spud_base.rng"/>
  <include href="adaptivity_options.rng"/>
  <include href="diagnostic_algorithms.rng"/>
  <include href="input_output.rng"/>
  <include href="solvers.rng"/>
  <include href="stabilisation.rng"/>
  <include href="reduced_model.rng"/>
  <include href="mesh_options.rng"/>
  <include href="physical_parameters.rng"/>
  <include href="prognostic_field_options.rng"/>
  <include href="prescribed_field_options.rng"/>
  <include href="spatial_discretisation.rng"/>
  <include href="temporal_discretisation.rng"/>
  <include href="embedded_models.rng"/>
  <include href="flredecomp.rng"/>
  <include href="porous_media.rng"/>
  <include href="multiphase_interaction.rng"/>
  <include href="equation_of_state.rng"/>
  <start>
    <element name="fluidity_options">
      <a:documentation>The root node of the options dictionary.</a:documentation>
      <ref name="comment"/>
      <element name="simulation_name">
        <a:documentation>Model output files are named according to the simulation
name, e.g. [simulation_name]_0.vtu. Non-standard
characters in the simulation name should be avoided.</a:documentation>
        <ref name="anystring"/>
      </element>
      <element name="problem_type">
        <a:documentation>Option problem_type does not change the tree.  It is just used for options checking.</a:documentation>
        <element name="string_value">
          <!--
            Lines is a hint to the gui about the size of the text box.
            It is not an enforced limit on string length.
          -->
          <attribute name="lines">
            <value>1</value>
          </attribute>
          <choice>
            <value>fluids</value>
            <value>oceans</value>
            <value>multimaterial</value>
            <value>stokes</value>
            <value>large_scale_ocean_options</value>
            <value>foams</value>
            <value>multiphase</value>
          </choice>
        </element>
        <ref name="comment"/>
      </element>
      <ref name="geometry"/>
      <element name="io">
        <a:documentation>Input/output options</a:documentation>
        <element name="dump_format">
          <a:documentation>Format for dump files. Only vtk for now.</a:documentation>
          <element name="string_value">
            <value>vtk</value>
          </element>
        </element>
        <choice>
          <element name="dump_period">
            <a:documentation>Period between dumps in time units.

Specifies the period between each dump of the solution to disk.
A value of 0.0 indicates that there would be a dump at every timestep.</a:documentation>
            <choice>
              <element name="constant">
                <ref name="real"/>
              </element>
              <element name="python">
                <a:documentation>Python function prescribing real input. Functions should be of the form:

 def val(t):
    # Function code
    return # Return value

</a:documentation>
                <ref name="python_code"/>
              </element>
            </choice>
          </element>
          <element name="dump_period_in_timesteps">
            <a:documentation>Dump period, in timesteps.

Specifies the number of timesteps between each dump of the solution to disk.
A value of 0 indicates a dump at every timestep.</a:documentation>
            <choice>
              <element name="constant">
                <ref name="integer"/>
              </element>
              <element name="python">
                <a:documentation>Python function prescribing integer input. Functions should be of the form:

 def val(t):
    # Function code
    return # Return value

</a:documentation>
                <ref name="python_code"/>
              </element>
            </choice>
          </element>
        </choice>
        <optional>
          <element name="disable_dump_at_start">
            <a:documentation>Disable dump at simulation start</a:documentation>
            <ref name="comment"/>
          </element>
        </optional>
        <optional>
          <element name="disable_dump_at_end">
            <a:documentation>Disable dump at simulation end</a:documentation>
            <ref name="comment"/>
          </element>
        </optional>
        <optional>
          <!-- every CPUDUM seconds write results to disc. -->
          <element name="cpu_dump_period">
            <a:documentation>This is usually disabled.</a:documentation>
            <ref name="real"/>
          </element>
        </optional>
        <optional>
          <element name="wall_time_dump_period">
            <a:documentation>The period between dumps in walltime seconds. This is usually disabled.</a:documentation>
            <ref name="real"/>
          </element>
        </optional>
        <optional>
          <element name="max_dump_file_count">
            <a:documentation>Number of dumps before we overwrite previous dumps.</a:documentation>
            <ref name="integer"/>
          </element>
        </optional>
        <choice>
          <element name="output_mesh">
            <a:documentation>The mesh on to which all the fields will be
interpolated for VTK output.</a:documentation>
            <attribute name="name">
              <value>VelocityMesh</value>
            </attribute>
          </element>
          <element name="output_mesh">
            <a:documentation>The mesh on to which all the fields will be
interpolated for VTK output.</a:documentation>
            <attribute name="name">
              <value>PressureMesh</value>
            </attribute>
          </element>
          <element name="output_mesh">
            <a:documentation>The mesh on to which all the fields will be
interpolated for VTK output.</a:documentation>
            <attribute name="name">
              <value>CoordinateMesh</value>
            </attribute>
          </element>
          <element name="output_mesh">
            <a:documentation>The mesh on to which all the fields will be
interpolated for VTK output.</a:documentation>
            <attribute name="name">
              <data type="string"/>
            </attribute>
          </element>
        </choice>
        <optional>
          <element name="convergence">
            <a:documentation>Options for convergence analysis.</a:documentation>
            <optional>
              <element name="convergence_file">
                <a:documentation>Whether to enable the creation of a convergence
file, giving details of the convergence of each
field over the global nonlinear iteration loop.
The .convergence file is in the same format as the .stat file.</a:documentation>
                <ref name="comment"/>
              </element>
            </optional>
            <optional>
              <element name="convergence_vtus">
                <a:documentation>Write state to a vtu on every iteration.

This is a useful debugging tool if things are not converging.
To prevent an excessive number of files being accumulated previous
timestep files will be overwritten hence it is best to use
in conjunction with /timestepping/nonlinear_iterations/terminate_if_not_converged</a:documentation>
                <ref name="comment"/>
              </element>
            </optional>
          </element>
        </optional>
        <optional>
          <element name="checkpointing">
            <a:documentation>Whether to enable dumping of checkpointing output.

See http://amcg.ese.ic.ac.uk/index.php?title=Local:Checkpointing_from_new_options</a:documentation>
            <element name="checkpoint_period_in_dumps">
              <a:documentation>Checkpointing period, in dumps. Non-negative value
required. A value of zero indicates that checkpoints
should be created at every dump. If
/io/max_dumpfile_count is exceeded then earlier
checkpoints may be overwritten.</a:documentation>
              <ref name="integer"/>
            </element>
            <optional>
              <element name="checkpoint_at_start">
                <a:documentation>Enable to checkpoint at simulation start.</a:documentation>
                <ref name="comment"/>
              </element>
            </optional>
            <optional>
              <element name="checkpoint_at_end">
                <a:documentation>Enable to force a checkpoint at simulation end.</a:documentation>
                <ref name="comment"/>
              </element>
            </optional>
            <ref name="comment"/>
          </element>
        </optional>
        <element name="stat">
          <a:documentation>Diagnostic output (.stat file) options</a:documentation>
          <optional>
            <element name="output_at_start">
              <a:documentation>Enable to write diagnostic output at simulation start</a:documentation>
              <ref name="comment"/>
            </element>
          </optional>
          <optional>
            <element name="output_before_adapts">
              <a:documentation>Enable to write diagnostic output immediately before mesh adapts</a:documentation>
              <ref name="comment"/>
            </element>
          </optional>
          <optional>
            <element name="output_after_adapts">
              <a:documentation>Enable to write diagnostic output immediately after mesh adapts</a:documentation>
              <ref name="comment"/>
            </element>
          </optional>
          <ref name="comment"/>
        </element>
        <optional>
          <element name="detectors">
            <a:documentation>Specification of detectors. Note that when running in parallel the detector output is in binary format even if binary_output is not enabled. When running in serial, although the output is in principle still generated in ascii format if binary_output is not enabled, it is not certain that it is working well. Hence, it is recommended to enable binary_output and work with binary files. </a:documentation>
            <zeroOrMore>
              <choice>
                <element name="static_detector">
                  <a:documentation>A single static detector</a:documentation>
                  <attribute name="name">
                    <data type="string"/>
                  </attribute>
                  <choice>
                    <element name="location">
                      <ref name="real_dim_vector"/>
                    </element>
                    <element name="from_checkpoint_file">
                      <a:documentation>File containing the detectors positions in binary form</a:documentation>
                      <attribute name="file_name">
                        <data type="string"/>
                      </attribute>
                      <element name="format">
                        <a:documentation>The format of the input file containing field data.</a:documentation>
                        <element name="string_value">
                          <value>binary</value>
                        </element>
                      </element>
                    </element>
                  </choice>
                </element>
                <element name="lagrangian_detector">
                  <a:documentation>A single lagrangian detector</a:documentation>
                  <attribute name="name">
                    <data type="string"/>
                  </attribute>
                  <choice>
                    <element name="location">
                      <a:documentation>This is the initial location of a detector that moves with the fluid velocity.</a:documentation>
                      <ref name="real_dim_vector"/>
                    </element>
                    <element name="from_checkpoint_file">
                      <a:documentation>File containing the detectors positions in binary form</a:documentation>
                      <attribute name="file_name">
                        <data type="string"/>
                      </attribute>
                      <element name="format">
                        <a:documentation>The format of the input file containing field data.</a:documentation>
                        <element name="string_value">
                          <value>binary</value>
                        </element>
                      </element>
                    </element>
                  </choice>
                </element>
                <element name="detector_array">
                  <a:documentation>Detectors with their locations specified via a python function or from a file. Allows detector arrays to be added.</a:documentation>
                  <attribute name="name">
                    <data type="string"/>
                  </attribute>
                  <element name="number_of_detectors">
                    <a:documentation>The number of detectors prescribed by the python function.</a:documentation>
                    <ref name="integer"/>
                  </element>
                  <choice>
                    <element name="static">
                      <a:documentation>Create fixed detectors.</a:documentation>
                      <empty/>
                    </element>
                    <element name="lagrangian">
                      <a:documentation>Create detectors which move with the fluid velocity.</a:documentation>
                      <empty/>
                    </element>
                  </choice>
                  <choice>
                    <element name="python">
                      <a:documentation>Python function prescribing dimensional vector input. Functions should be of the form:

 def val(t):
    # Function code
    return # Return value

The return value must have length number_of_detectors.

*** IMPORTANT NOTE ***

The t argument is for future use only - currently detector locations are only set at simulation start.</a:documentation>
                      <ref name="python_code"/>
                    </element>
                    <element name="from_file">
                      <a:documentation>File containing the detectors positions in binary form</a:documentation>
                      <attribute name="file_name">
                        <data type="string"/>
                      </attribute>
                      <element name="format">
                        <a:documentation>The format of the input file containing field data.</a:documentation>
                        <element name="string_value">
                          <value>binary</value>
                        </element>
                      </element>
                    </element>
                    <element name="from_checkpoint_file">
                      <a:documentation>File containing the detectors positions in binary form</a:documentation>
                      <attribute name="file_name">
                        <data type="string"/>
                      </attribute>
                      <element name="format">
                        <a:documentation>The format of the input file containing field data.</a:documentation>
                        <element name="string_value">
                          <value>binary</value>
                        </element>
                      </element>
                    </element>
                  </choice>
                </element>
              </choice>
            </zeroOrMore>
            <choice>
              <element name="fail_outside_domain">
                <a:documentation>By default Fluidity will fail if a detector has left the domain.</a:documentation>
                <empty/>
              </element>
              <element name="write_nan_outside_domain">
                <a:documentation>Enable to write NaN values to detector output if a detector has left the domain.</a:documentation>
                <empty/>
              </element>
            </choice>
            <optional>
              <element name="binary_output">
                <a:documentation>Enable to write detector output in binary format</a:documentation>
                <ref name="comment"/>
              </element>
            </optional>
            <optional>
              <element name="move_with_mesh">
                <a:documentation>Enable to let detectors move with the domain if mesh_movement is enabled.</a:documentation>
                <empty/>
              </element>
            </optional>
            <optional>
              <ref name="lagrangian_timestepping"/>
            </optional>
          </element>
        </optional>
        <optional>
          <element name="log_output">
            <a:documentation>Options to create even more output in the logs:

Note that the main option to control the log output is given on the command line:

-v0  only output error and warnings

-v1  also give "navigational information", to indicate where in the code we currently are

-v2  also give any additional information (mins and maxes of fields, etc.)
</a:documentation>
            <optional>
              <element name="memory_diagnostics">
                <a:documentation>Log all allocates and deallocates done for meshes, fields, sparsities and matrices.

NOTE: Requires -v2</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
        </optional>
      </element>
      <element name="timestepping">
        <a:documentation>Options dealing with time discretisation</a:documentation>
        <element name="current_time">
          <a:documentation>Current simulation time. At the start of the simulation this
is the start time.</a:documentation>
          <ref name="real"/>
          <optional>
            <element name="time_units">
              <a:documentation>The following excerpt from the Udunits
documentation explains the time unit encoding by
example:

The specification:

seconds since 1992-10-8 15:15:42.5 -6:00

indicates seconds since October 8th, 1992 at 3
hours, 15 minutes and 42.5 seconds in the afternoon
in the time zone which is six hours to the west of
Coordinated Universal Time (i.e.  Mountain Daylight
Time). The time zone specification can also be
written without a colon using one or two-digits
(indicating hours) or three or four digits
(indicating hours and minutes).

Time units are particularly required in situations
where the problem (time-varying) boundary conditions
and/ initial conditions are a function of time as
defined by a calendar.  Examples include atmospheric
forcing and climatology. The current time, specified
above, is zero at the reference data/time.</a:documentation>
              <attribute name="date">
                <data type="string"/>
              </attribute>
            </element>
          </optional>
        </element>
        <element name="timestep">
          <a:documentation>The time step size. If adaptive time stepping is used
then this is the initial time step size.</a:documentation>
          <ref name="real"/>
        </element>
        <element name="finish_time">
          <a:documentation>Simulation time at which the simulation should end.</a:documentation>
          <ref name="real"/>
        </element>
        <optional>
          <element name="final_timestep">
            <a:documentation>Timestep after which the simulation should end.</a:documentation>
            <ref name="integer"/>
          </element>
        </optional>
        <optional>
          <element name="cpu_time_limit">
            <a:documentation>Maximum CPU time (in seconds) before the simulation terminates</a:documentation>
            <ref name="real"/>
          </element>
        </optional>
        <optional>
          <element name="wall_time_limit">
            <a:documentation>Maximum wall time (secs) taken up before
simulation terminates writing results to disc.

This is usually disabled.</a:documentation>
            <ref name="real"/>
          </element>
        </optional>
        <optional>
          <element name="nonlinear_iterations">
            <a:documentation>maximum number of non-linear iterations.

Manual suggests 2</a:documentation>
            <ref name="integer"/>
            <optional>
              <element name="tolerance">
                <a:documentation>tolerance for non-linear iteration.
Manual suggests 1.0E-12</a:documentation>
                <ref name="real"/>
                <choice>
                  <element name="infinity_norm">
                    <a:documentation>Select the norm with which you want the tolerance to be tested.

The infinity norm.</a:documentation>
                    <empty/>
                  </element>
                  <element name="l2_norm">
                    <a:documentation>Select the norm with which you want the tolerance to be tested.

The l2 norm.</a:documentation>
                    <empty/>
                  </element>
                  <element name="cv_l2_norm">
                    <a:documentation>Select the norm with which you want the tolerance to be tested.

The l2 norm evaluated on a control volume mesh.</a:documentation>
                    <empty/>
                  </element>
                </choice>
              </element>
            </optional>
            <optional>
              <element name="terminate_if_not_converged">
                <a:documentation>Terminate the simulation if the number of
nonlinear_iterations is reached
and the tolerance criterion is not met.
This is mostly useful as a debugging option if you
suspect the solution is not converging.</a:documentation>
                <empty/>
              </element>
            </optional>
            <optional>
              <element name="nonlinear_iterations_at_adapt">
                <a:documentation>Number of non-linear iterations for the first time step after adapting the mesh.
This option will work only if the mesh_adaptivity is switched on.</a:documentation>
                <ref name="integer"/>
              </element>
            </optional>
          </element>
        </optional>
        <optional>
          <element name="adaptive_timestep">
            <a:documentation>Vary the timestep according to the courant number.</a:documentation>
            <element name="requested_cfl">
              <a:documentation>The timestep will be adjusted (within the tolerance
and bounds specified) to target this courant
number. Timestep adapts occur at the end of each
timestep and after a mesh adapt.</a:documentation>
              <ref name="real"/>
            </element>
            <ref name="timestep_cfl_number_options"/>
            <optional>
              <element name="minimum_timestep">
                <a:documentation>Minimum time step size.
Manual suggests 0.0</a:documentation>
                <optional>
                  <element name="terminate_if_reached">
                    <a:documentation>If enabled, signals model termination if a timestep less
than or equal to the minimum_timestep is requested. The
model will stop at the end of the timestep in order to
allow for the latest output to be written. </a:documentation>
                    <ref name="comment"/>
                  </element>
                </optional>
                <ref name="real"/>
              </element>
            </optional>
            <optional>
              <element name="maximum_timestep">
                <a:documentation>Maximum time step size.
Manual suggests 1.E+10</a:documentation>
                <ref name="real"/>
              </element>
            </optional>
            <optional>
              <element name="increase_tolerance">
                <a:documentation>The maximum ratio by which the timestep is allowed
to increase in a timestep adapt. e.g., a value of
1.1 indicates that the timestep may be increased by
at most 10%.</a:documentation>
                <ref name="real"/>
              </element>
            </optional>
            <optional>
              <element name="at_first_timestep">
                <a:documentation>Specify whether you want to calculate a new timestep
at the first timestep or not.</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
        </optional>
        <optional>
          <!-- Preprocessor legacy: STEDER = 0. is equivalent to inactive. -->
          <element name="steady_state">
            <a:documentation>Activate if you want to terminate the simulation once a
steady state is reached.

Enable/disable fields in this check under each field in
steady_state options.</a:documentation>
            <element name="tolerance">
              <a:documentation>Enter the tolerance to which you want a steady state to be judged.</a:documentation>
              <ref name="real"/>
              <choice>
                <element name="infinity_norm">
                  <a:documentation>Select the norm with which you want the tolerance to be tested.

The infinity norm.</a:documentation>
                  <empty/>
                </element>
                <element name="l2_norm">
                  <a:documentation>Select the norm with which you want the tolerance to be tested.

The l2 norm.</a:documentation>
                  <empty/>
                </element>
                <element name="cv_l2_norm">
                  <a:documentation>Select the norm with which you want the tolerance to be tested.

The l2 norm evaluated on a control volume mesh.</a:documentation>
                  <empty/>
                </element>
              </choice>
            </element>
            <optional>
              <element name="acceleration_form">
                <a:documentation>If activated compare the above tolerance to the rate
of change of the fields. Otherwise compare it
directly to the change in the field.</a:documentation>
                <empty/>
              </element>
            </optional>
            <optional>
              <element name="steady_state_file">
                <a:documentation>Write out the changes in the tested fields to a .steady_state
file.</a:documentation>
                <choice>
                  <element name="binary_output">
                    <a:documentation>Write steady state output in binary format</a:documentation>
                    <ref name="comment"/>
                  </element>
                  <element name="plain_text_output">
                    <a:documentation>Write steady state output in plain text format</a:documentation>
                    <ref name="comment"/>
                  </element>
                </choice>
                <ref name="comment"/>
              </element>
            </optional>
          </element>
        </optional>
      </element>
      <optional>
        <ref name="physical_parameter_options"/>
      </optional>
      <oneOrMore>
        <element name="material_phase">
          <a:documentation>The material or phase options</a:documentation>
          <attribute name="name">
            <data type="string"/>
          </attribute>
          <optional>
            <ref name="equation_of_state_options"/>
          </optional>
          <optional>
            <element name="subgridscale_parameterisations">
              <a:documentation>Subgridscale parameterisations</a:documentation>
              <optional>
                <element name="LANS">
                  <a:documentation>Lagrangian-averaged Navier-Stokes equations </a:documentation>
                  <choice>
                    <element name="alpha_isotropic_homogeneous">
                      <a:documentation>smoothing length specified as isotropic homogeneous</a:documentation>
                      <ref name="real"/>
                    </element>
                    <element name="alpha_anisotropic_homogeneous_cartesian">
                      <ref name="real_dim_symmetric_tensor"/>
                    </element>
                  </choice>
                  <!--
                                  (
                                     element leray {
                                        empty
                                     }|
                                     element LANS_momentum_form {
                                        empty
                                     }|
                                     element LANS_stress_form {
                                        empty
                                     }
                                  )
                  -->
                </element>
              </optional>
              <optional>
                <element name="GLS">
                  <a:documentation>This is the generic length scale (vertical turbulence mixed layer) model, 
based here on Warner et al 2005, Ocean Modelling 8:81-113,
which is itself based on the works of Umlauf and Burchard 2003.

The GLS model encodes four individual turbulence closure models which can be chosen via 'option' below.

You will need to make sure that DistanceToTop and DistanceToBottom fields (under geometry/ocean_boundaries) 
are switched on, as well as PerturbationDensity.</a:documentation>
                  <element name="option">
                    <a:documentation>The base GLS option:
1. k-kl which is a variant of Mellor-Yamada 2.5
2. k-epsilon
3. k-omega
4. 'gen' from Warner et al 2005

k-epsilon is recommended.</a:documentation>
                    <element name="string_value">
                      <choice>
                        <value>k-kl</value>
                        <value>k-epsilon</value>
                        <value>k-omega</value>
                        <value>gen</value>
                      </choice>
                    </element>
                  </element>
                  <element name="stability_function">
                    <a:documentation>The stability function choice:
1. KanthaClayson-94 which corresponds to Kantha and Clayson 1994
2. Galperin-88 which corresponds to Galperin et al 1988
3. Canuto-01-A which corresponds to choice A from Canuto et al 2001
4. Canuto-01-B which corresponds to choice B from Canuto et al 2001

Canuto A or B are recommended.</a:documentation>
                    <element name="string_value">
                      <choice>
                        <value>KanthaClayson-94</value>
                        <value>GibsonLaunder-78</value>
                        <value>Canuto-01-A</value>
                        <value>Canuto-01-B</value>
                      </choice>
                    </element>
                  </element>
                  <optional>
                    <element name="wall_function">
                      <a:documentation>The wall function choice:
1. None - pick this unless you're using k-kl
2. Mellor and Yamada (1980) - parabolic shape
3. Burchard (1998) - symmetric linear shape
4. Burchard (2001) - Used for infinitely deep basins
5. Blumberg et al (1992) - open channel flow

See manual for equations.</a:documentation>
                      <element name="string_value">
                        <choice>
                          <value>none</value>
                          <value>MellorYamda</value>
                          <value>Burchard98</value>
                          <value>Burchard01</value>
                          <value>Blumberg</value>
                        </choice>
                      </element>
                    </element>
                  </optional>
                  <optional>
                    <element name="smooth_buoyancy">
                      <a:documentation>Smooth buoyancy frequency before using it?</a:documentation>
                      <empty/>
                    </element>
                  </optional>
                  <optional>
                    <element name="smooth_shear">
                      <a:documentation>Smooth velocity shear before using it?</a:documentation>
                      <empty/>
                    </element>
                  </optional>
                  <optional>
                    <element name="calculate_boundaries">
                      <a:documentation>Do you want the boundary conditions to be set automatically?
Make sure the ocean geometry settings are enabled for this option</a:documentation>
                      <element name="string_value">
                        <choice>
                          <value>neumann</value>
                          <value>dirichlet</value>
                        </choice>
                      </element>
                      <element name="top_surface_ids">
                        <ref name="integer_vector"/>
                      </element>
                      <element name="bottom_surface_ids">
                        <ref name="integer_vector"/>
                      </element>
                    </element>
                  </optional>
                  <optional>
                    <element name="relax_diffusivity">
                      <a:documentation>Perform relaxation of the diffusivity and viscosity in the GLS model.
Value should be &gt;=0 and &lt; 1. 0 is no relaxation (i.e. always use the
most up-to-date value) and 0.9 would represent making the current value
be 0.9*old_value + 0.1*new_value. Default is 0.0
If being used with adaptivity, ensure you switch on interpolation of the 
GLSVerticalDiffusivity and GLSVerticalViscosity fields. You will seg fault
otherwise.</a:documentation>
                      <ref name="real"/>
                    </element>
                  </optional>
                  <optional>
                    <element name="ocean_parameterisation">
                      <a:documentation>Add extra parameterisation for internal wave breaking at base of MLD. This
is based on the same parameterisation in NEMO and smooths the TKE down 
the water column based on an exponential function
Set the two parameters: % of TKE to smooth down and length scale to do this over</a:documentation>
                      <element name="lengthscale">
                        <ref name="real"/>
                      </element>
                      <element name="percentage">
                        <ref name="real"/>
                      </element>
                    </element>
                  </optional>
                  <element name="scalar_field">
                    <a:documentation>Turbulent kinetic energy. Make sure that the Diffusivity tensor field in here is set to diagnostic/internal.</a:documentation>
                    <attribute name="rank">
                      <value>0</value>
                    </attribute>
                    <attribute name="name">
                      <value>GLSTurbulentKineticEnergy</value>
                    </attribute>
                    <choice>
                      <element name="prognostic">
                        <ref name="velocity_mesh_choice"/>
                        <ref name="prognostic_scalar_field"/>
                        <element name="minimum_value">
                          <a:documentation>Minimum value of TKE in m2s2. A typical value will be around 1e-6</a:documentation>
                          <ref name="real"/>
                        </element>
                      </element>
                      <element name="aliased">
                        <ref name="generic_aliased_field"/>
                      </element>
                    </choice>
                  </element>
                  <element name="scalar_field">
                    <a:documentation>Generic second equation used in GLS. 
Make sure that the Diffusivity tensor field in here is set to diagnostic/internal.</a:documentation>
                    <attribute name="rank">
                      <value>0</value>
                    </attribute>
                    <attribute name="name">
                      <value>GLSGenericSecondQuantity</value>
                    </attribute>
                    <choice>
                      <element name="prognostic">
                        <ref name="velocity_mesh_choice"/>
                        <ref name="prognostic_scalar_field"/>
                      </element>
                      <element name="aliased">
                        <ref name="generic_aliased_field"/>
                      </element>
                    </choice>
                  </element>
                  <element name="tensor_field">
                    <a:documentation>Background viscosity</a:documentation>
                    <attribute name="rank">
                      <value>2</value>
                    </attribute>
                    <attribute name="name">
                      <value>GLSBackgroundViscosity</value>
                    </attribute>
                    <choice>
                      <element name="prescribed">
                        <ref name="mesh_choice"/>
                        <ref name="prescribed_tensor_field"/>
                      </element>
                      <element name="diagnostic">
                        <ref name="mesh_choice"/>
                        <ref name="sediment_concentration_dependent_viscosity_algorithm"/>
                        <ref name="diagnostic_tensor_field"/>
                      </element>
                    </choice>
                  </element>
                  <element name="tensor_field">
                    <a:documentation>Background diffusivity</a:documentation>
                    <attribute name="rank">
                      <value>2</value>
                    </attribute>
                    <attribute name="name">
                      <value>GLSBackgroundDiffusivity</value>
                    </attribute>
                    <element name="prescribed">
                      <ref name="mesh_choice"/>
                      <ref name="prescribed_tensor_field"/>
                    </element>
                  </element>
                  <element name="tensor_field">
                    <a:documentation>Eddy viscosity K_M</a:documentation>
                    <attribute name="rank">
                      <value>2</value>
                    </attribute>
                    <attribute name="name">
                      <value>GLSEddyViscosityKM</value>
                    </attribute>
                    <choice>
                      <element name="diagnostic">
                        <ref name="internal_algorithm"/>
                        <ref name="velocity_mesh_choice"/>
                        <ref name="diagnostic_scalar_field"/>
                      </element>
                      <element name="aliased">
                        <ref name="generic_aliased_field"/>
                      </element>
                    </choice>
                  </element>
                  <element name="tensor_field">
                    <a:documentation>Eddy diffusivity K_H</a:documentation>
                    <attribute name="rank">
                      <value>2</value>
                    </attribute>
                    <attribute name="name">
                      <value>GLSEddyDiffusivityKH</value>
                    </attribute>
                    <choice>
                      <element name="diagnostic">
                        <ref name="internal_algorithm"/>
                        <ref name="velocity_mesh_choice"/>
                        <ref name="diagnostic_scalar_field"/>
                      </element>
                      <element name="aliased">
                        <ref name="generic_aliased_field"/>
                      </element>
                    </choice>
                  </element>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Length scale (a diagnostic with GLS)</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>GLSLengthScale</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Unedited TKE. The TKE filed has the upper and lower surfaces
altered with Dirichlet conditions for ouput. This is the
unedited surface.</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>GLSTurbulentKineticEnergyOriginal</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Buoyancy frequency</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>GLSBuoyancyFrequency</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Velocity shear</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>GLSVelocityShear</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Shear production P</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>GLSShearProduction</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Buoyancy production B</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>GLSBuoyancyProduction</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Dissipation epsilon</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>GLSDissipationEpsilon</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Stability function S_M</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>GLSStabilityFunctionSM</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Stability function S_H</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>GLSStabilityFunctionSH</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Source1 - TKE source term</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>GLSSource1</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Source2 - Second Quantity source term</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>GLSSource2</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Absorption1 - TKE absorption term</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>GLSAbsorption1</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Absorption2 - Second Quantity absorption term</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>GLSAbsorption2</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>GLS Wall function</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>GLSWallFunction</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Vertical eddy viscosity</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>GLSVerticalViscosity</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Vertical eddy diffusivity</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>GLSVerticalDiffusivity</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                </element>
              </optional>
              <optional>
                <element name="Mellor_Yamada">
                  <element name="scalar_field">
                    <a:documentation>Kinetic Energy</a:documentation>
                    <attribute name="rank">
                      <value>0</value>
                    </attribute>
                    <attribute name="name">
                      <value>KineticEnergy</value>
                    </attribute>
                    <choice>
                      <element name="prognostic">
                        <ref name="velocity_mesh_choice"/>
                        <ref name="prognostic_scalar_field"/>
                      </element>
                      <element name="aliased">
                        <ref name="generic_aliased_field"/>
                      </element>
                    </choice>
                  </element>
                  <element name="scalar_field">
                    <a:documentation>Turbulent Length Scale x Kinetic Energy</a:documentation>
                    <attribute name="rank">
                      <value>0</value>
                    </attribute>
                    <attribute name="name">
                      <value>TurbulentLengthScalexKineticEnergy</value>
                    </attribute>
                    <choice>
                      <element name="prognostic">
                        <ref name="velocity_mesh_choice"/>
                        <ref name="prognostic_scalar_field"/>
                      </element>
                      <element name="aliased">
                        <ref name="generic_aliased_field"/>
                      </element>
                    </choice>
                  </element>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Vertical Viscosity</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>VerticalViscosity</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Vertical Diffusivity of Temperature</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>VerticalDiffusivity</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                </element>
              </optional>
              <optional>
                <element name="prescribed_diffusivity">
                  <a:documentation>Trivial case in which the user supplies the diffusivity.</a:documentation>
                  <element name="tensor_field">
                    <attribute name="rank">
                      <value>2</value>
                    </attribute>
                    <attribute name="name">
                      <value>PrescribedDiffusivity</value>
                    </attribute>
                    <element name="prescribed">
                      <ref name="mesh_choice"/>
                      <ref name="prescribed_tensor_field_no_adapt"/>
                    </element>
                  </element>
                </element>
              </optional>
              <optional>
                <element name="k-epsilon">
                  <a:documentation>Standard k-epsilon turbulence model (see e.g. Ferziger and Peric(2002) p.295).
Solves 2 additional equations for TurbulentDissipation (epsilon) and TurbulentKineticEnergy (k),
in order to close momentum equations.
Generates an isotropic 'eddy viscosity', added to molecular viscosity field, that
carries the influence of turbulence onto the velocity field. See the manual for details.</a:documentation>
                  <element name="scalar_field">
                    <a:documentation>Turbulent kinetic energy (k).
1. 'k_esilon'-type boundary conditions are recommended for this field.
2. Turn on diffusivity, source and absorption diagnostic fields.
3. Use the same mesh as Velocity.</a:documentation>
                    <attribute name="rank">
                      <value>0</value>
                    </attribute>
                    <attribute name="name">
                      <value>TurbulentKineticEnergy</value>
                    </attribute>
                    <choice>
                      <element name="prognostic">
                        <ref name="velocity_mesh_choice"/>
                        <ref name="prognostic_scalar_field"/>
                      </element>
                      <element name="prescribed">
                        <ref name="velocity_mesh_choice"/>
                        <ref name="prescribed_scalar_field"/>
                      </element>
                    </choice>
                  </element>
                  <element name="scalar_field">
                    <a:documentation>TurbulentDissipation (epsilon).
1. 'k_epsilon'-type boundary conditions are recommended for this field.
2. Turn on diffusivity, source and absorption diagnostic fields.
3. Use the same mesh as Velocity.</a:documentation>
                    <attribute name="rank">
                      <value>0</value>
                    </attribute>
                    <attribute name="name">
                      <value>TurbulentDissipation</value>
                    </attribute>
                    <choice>
                      <element name="prognostic">
                        <ref name="velocity_mesh_choice"/>
                        <ref name="prognostic_scalar_field"/>
                      </element>
                      <element name="prescribed">
                        <ref name="velocity_mesh_choice"/>
                        <ref name="prescribed_scalar_field"/>
                      </element>
                    </choice>
                  </element>
                  <element name="tensor_field">
                    <a:documentation>Set the value of the background (laminar) viscosity field here.
Make it small to see the influence of the eddy viscosity.
IMPORTANT: make velocity/viscosity diagnostic.</a:documentation>
                    <attribute name="rank">
                      <value>2</value>
                    </attribute>
                    <attribute name="name">
                      <value>BackgroundViscosity</value>
                    </attribute>
                    <choice>
                      <element name="prescribed">
                        <ref name="velocity_mesh_choice"/>
                        <ref name="prescribed_tensor_field"/>
                      </element>
                      <element name="diagnostic">
                        <ref name="velocity_mesh_choice"/>
                        <ref name="sediment_concentration_dependent_viscosity_algorithm"/>
                        <ref name="diagnostic_tensor_field"/>
                      </element>
                    </choice>
                  </element>
                  <optional>
                    <element name="tensor_field">
                      <a:documentation>Set the value of the background (laminar) diffusivity field here.
This is used to calculate scalar field diffusivities.</a:documentation>
                      <attribute name="rank">
                        <value>2</value>
                      </attribute>
                      <attribute name="name">
                        <value>BackgroundDiffusivity</value>
                      </attribute>
                      <element name="prescribed">
                        <ref name="velocity_mesh_choice"/>
                        <ref name="prescribed_tensor_field"/>
                      </element>
                    </element>
                  </optional>
                  <element name="tensor_field">
                    <a:documentation>Eddy viscosity (turbulent diffusion of velocity).
This is a fictitious isotropic viscosity, added to normal viscosity field, that
carries the influence of turbulence onto the velocity field.</a:documentation>
                    <attribute name="rank">
                      <value>2</value>
                    </attribute>
                    <attribute name="name">
                      <value>EddyViscosity</value>
                    </attribute>
                    <element name="diagnostic">
                      <ref name="internal_algorithm"/>
                      <ref name="velocity_mesh_choice"/>
                      <ref name="diagnostic_tensor_field"/>
                    </element>
                  </element>
                  <element name="scalar_field">
                    <a:documentation>Scalar component of the eddy viscosity tensor.
This will appear in the stat file.</a:documentation>
                    <attribute name="rank">
                      <value>0</value>
                    </attribute>
                    <attribute name="name">
                      <value>ScalarEddyViscosity</value>
                    </attribute>
                    <choice>
                      <element name="diagnostic">
                        <ref name="internal_algorithm"/>
                        <ref name="velocity_mesh_choice"/>
                        <ref name="diagnostic_scalar_field"/>
                      </element>
                      <element name="prescribed">
                        <ref name="velocity_mesh_choice"/>
                        <ref name="prescribed_scalar_field"/>
                      </element>
                    </choice>
                  </element>
                  <element name="scalar_field">
                    <a:documentation>Integral length scale of the turbulence (diagnostic).</a:documentation>
                    <attribute name="rank">
                      <value>0</value>
                    </attribute>
                    <attribute name="name">
                      <value>LengthScale</value>
                    </attribute>
                    <element name="diagnostic">
                      <ref name="internal_algorithm"/>
                      <ref name="velocity_mesh_choice"/>
                      <ref name="diagnostic_scalar_field"/>
                    </element>
                  </element>
                  <element name="scalar_field">
                    <a:documentation>f_1 damping coefficient for low_Re k-epsilon model
Required for low_Re boundaries. If no low_Re boundaries are present
this will be set to 1.0 throughout the domain and will not
affect the result</a:documentation>
                    <attribute name="rank">
                      <value>0</value>
                    </attribute>
                    <attribute name="name">
                      <value>f_1</value>
                    </attribute>
                    <element name="diagnostic">
                      <ref name="internal_algorithm"/>
                      <ref name="velocity_mesh_choice"/>
                      <ref name="diagnostic_scalar_field"/>
                    </element>
                  </element>
                  <element name="scalar_field">
                    <a:documentation>f_2 damping coefficient for low_Re k-epsilon model
Required for low_Re boundaries. If no low_Re boundaries are present
this will be set to 1.0 throughout the domain and will not
affect the result</a:documentation>
                    <attribute name="rank">
                      <value>0</value>
                    </attribute>
                    <attribute name="name">
                      <value>f_2</value>
                    </attribute>
                    <element name="diagnostic">
                      <ref name="internal_algorithm"/>
                      <ref name="velocity_mesh_choice"/>
                      <ref name="diagnostic_scalar_field"/>
                    </element>
                  </element>
                  <element name="scalar_field">
                    <a:documentation>f_mu damping coefficient for low_Re k-epsilon model
Required for low_Re boundaries. If no low_Re boundaries are present
this will be set to 1.0 throughout the domain and will not
affect the result</a:documentation>
                    <attribute name="rank">
                      <value>0</value>
                    </attribute>
                    <attribute name="name">
                      <value>f_mu</value>
                    </attribute>
                    <element name="diagnostic">
                      <ref name="internal_algorithm"/>
                      <ref name="velocity_mesh_choice"/>
                      <ref name="diagnostic_scalar_field"/>
                    </element>
                  </element>
                  <element name="max_damping_value">
                    <a:documentation>Limit the maximum value of damping function values. This helps stability when using low_Re number
boundary conditions. If not using low_Re boundaries this will have no effect. 
Recommended value (default): 10.0</a:documentation>
                    <ref name="real"/>
                  </element>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Describes distance to nearest solid wall.
Required for low_Re boundaries.
For simple geometries the simplest method of providing this information is to use a python function.
For complex geometries where this is not possible precursive Eikonal equation or Poisson equation
simulations must be run using Fluidity to determine the values for this field.
Details of how this is done can be found in:
Tucker, P 2011: "Hybrid Hamilton/Jacobi/Poisson wall distance function model"
Elias et al 2007: "Simple finite element-based computation of distance functions in unstructured grids"</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>DistanceToWall</value>
                      </attribute>
                      <element name="prescribed">
                        <ref name="velocity_mesh_choice"/>
                        <ref name="prescribed_scalar_field"/>
                      </element>
                    </element>
                  </optional>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>VLES Filter function (diagnostic).
Run a VLES by switching this option on.
If so then filtering is applied to the eddy viscosity.</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>VLESFilter</value>
                      </attribute>
                      <element name="diagnostic">
                        <ref name="internal_algorithm"/>
                        <ref name="velocity_mesh_choice"/>
                        <ref name="diagnostic_scalar_field"/>
                      </element>
                    </element>
                  </optional>
                  <element name="C_mu">
                    <a:documentation>Eddy-viscosity coefficient: nu_T = density * C_mu * k**2 / epsilon.
Recommended value (default): 0.09.</a:documentation>
                    <ref name="real"/>
                  </element>
                  <element name="C_eps_1">
                    <a:documentation>TurbulentDissipation production coefficient.
Recommended value (default): 1.44.</a:documentation>
                    <ref name="real"/>
                  </element>
                  <element name="C_eps_2">
                    <a:documentation>TurbulentDissipation destruction coefficient.
Recommended value (default): 1.92.</a:documentation>
                    <ref name="real"/>
                  </element>
                  <element name="sigma_k">
                    <a:documentation>Turbulent Schmidt number (eddy viscosity coefficient from k equation).
This is also the ratio of eddy viscosity to eddy diffusivity for use in other scalar fields.
Recommended value (default): 1.0.</a:documentation>
                    <ref name="real"/>
                  </element>
                  <element name="sigma_eps">
                    <a:documentation>Turbulent Schmidt number (eddy-viscosity coefficient from epsilon equation).
Recommended value (default): 1.3.</a:documentation>
                    <ref name="real"/>
                  </element>
                  <element name="sigma_p">
                    <a:documentation>The Schmidt number (ratio of viscous diffusion rate to momentum diffusion rate) for 
massive scalar fields, or Prandtl number (ratio of viscous diffusion rate to thermal diffusion rate) 
for thermal fields. This is used to calculate the turbulent buoyancy term.
Recommended value (default): 1.0.</a:documentation>
                    <ref name="real"/>
                  </element>
                  <element name="time_discretisation">
                    <a:documentation>Time discretisation of the source terms in the k and epsilon equations and also
of the eddy viscosity</a:documentation>
                    <element name="theta">
                      <a:documentation>Implicit/explicit control (THETA) of source terms and eddy viscosity in
the k-epsilon model
 = 0.  -- explicit
 = 0.5 -- Crank-Nicolson
 = 1.  -- implicit</a:documentation>
                      <ref name="real"/>
                    </element>
                    <element name="source_term_implementation">
                      <a:documentation>Each term in the k and epsilon equations can be implemented as either a 
source or as an absorbtion term. See the manual under 
'Parameterisations/Turbulent flow modelling and simulation/Reynolds Averaged Navier Stokes (RANS) Modelling/Standard k   Turbulence Model/Time Discretisation and Coupling' 
for more information.</a:documentation>
                      <element name="production_term">
                        <choice>
                          <value>source</value>
                          <value>absorbtion</value>
                        </choice>
                      </element>
                      <element name="destruction_term">
                        <choice>
                          <value>source</value>
                          <value>absorbtion</value>
                        </choice>
                      </element>
                      <element name="buoyancy_term">
                        <choice>
                          <value>source</value>
                          <value>absorbtion</value>
                        </choice>
                      </element>
                    </element>
                  </element>
                  <element name="mass_terms">
                    <a:documentation>The source terms in the k-epsilon model are calculated before the field is 
solved. The process requires inversion of a mass matrix. This element contains
options for defining how this is done. For P1 meshes mass lumping can be used,
for other discretisations the mass matrix can not be easily inverted and so a 
solve must be carried out, with solver options specified.</a:documentation>
                    <choice>
                      <element name="lump_mass">
                        <empty/>
                      </element>
                      <element name="use_consistent_mass_matrix">
                        <element name="solver">
                          <ref name="linear_solver_options_asym_scalar"/>
                        </element>
                      </element>
                    </choice>
                  </element>
                  <optional>
                    <element name="debugging_options">
                      <a:documentation>produce vtu output of individual kk and eps source terms and set prescribed 
source terms for k and epsilon fields (for mms tests)</a:documentation>
                      <element name="source_term_output_fields">
                        <a:documentation>output fields for each of the source terms in the k-epsilon model</a:documentation>
                        <optional>
                          <element name="scalar_field">
                            <attribute name="rank">
                              <value>0</value>
                            </attribute>
                            <attribute name="name">
                              <value>TurbulentKineticEnergy_production_term</value>
                            </attribute>
                            <element name="diagnostic">
                              <ref name="internal_algorithm"/>
                              <ref name="velocity_mesh_choice"/>
                              <ref name="diagnostic_scalar_field"/>
                            </element>
                          </element>
                        </optional>
                        <optional>
                          <element name="scalar_field">
                            <attribute name="rank">
                              <value>0</value>
                            </attribute>
                            <attribute name="name">
                              <value>TurbulentKineticEnergy_destruction_term</value>
                            </attribute>
                            <element name="diagnostic">
                              <ref name="internal_algorithm"/>
                              <ref name="velocity_mesh_choice"/>
                              <ref name="diagnostic_scalar_field"/>
                            </element>
                          </element>
                        </optional>
                        <optional>
                          <element name="scalar_field">
                            <attribute name="rank">
                              <value>0</value>
                            </attribute>
                            <attribute name="name">
                              <value>TurbulentKineticEnergy_buoyancy_term</value>
                            </attribute>
                            <element name="diagnostic">
                              <ref name="internal_algorithm"/>
                              <ref name="velocity_mesh_choice"/>
                              <ref name="diagnostic_scalar_field"/>
                            </element>
                          </element>
                        </optional>
                        <optional>
                          <element name="scalar_field">
                            <attribute name="rank">
                              <value>0</value>
                            </attribute>
                            <attribute name="name">
                              <value>TurbulentDissipation_production_term</value>
                            </attribute>
                            <element name="diagnostic">
                              <ref name="internal_algorithm"/>
                              <ref name="velocity_mesh_choice"/>
                              <ref name="diagnostic_scalar_field"/>
                            </element>
                          </element>
                        </optional>
                        <optional>
                          <element name="scalar_field">
                            <attribute name="rank">
                              <value>0</value>
                            </attribute>
                            <attribute name="name">
                              <value>TurbulentDissipation_destruction_term</value>
                            </attribute>
                            <element name="diagnostic">
                              <ref name="internal_algorithm"/>
                              <ref name="velocity_mesh_choice"/>
                              <ref name="diagnostic_scalar_field"/>
                            </element>
                          </element>
                        </optional>
                        <optional>
                          <element name="scalar_field">
                            <attribute name="rank">
                              <value>0</value>
                            </attribute>
                            <attribute name="name">
                              <value>TurbulentDissipation_buoyancy_term</value>
                            </attribute>
                            <element name="diagnostic">
                              <ref name="internal_algorithm"/>
                              <ref name="velocity_mesh_choice"/>
                              <ref name="diagnostic_scalar_field"/>
                            </element>
                          </element>
                        </optional>
                      </element>
                      <element name="prescribed_source_terms">
                        <a:documentation>Enable to apply prescribed source terms into the k and epsilon equations.
This is useful for MMS tests</a:documentation>
                        <optional>
                          <element name="scalar_field">
                            <attribute name="rank">
                              <value>0</value>
                            </attribute>
                            <attribute name="name">
                              <value>TurbulentKineticEnergyPrescribedSource</value>
                            </attribute>
                            <element name="prescribed">
                              <ref name="velocity_mesh_choice"/>
                              <ref name="prescribed_scalar_field"/>
                            </element>
                          </element>
                        </optional>
                        <optional>
                          <element name="scalar_field">
                            <attribute name="rank">
                              <value>0</value>
                            </attribute>
                            <attribute name="name">
                              <value>TurbulentDissipationPrescribedSource</value>
                            </attribute>
                            <element name="prescribed">
                              <ref name="velocity_mesh_choice"/>
                              <ref name="prescribed_scalar_field"/>
                            </element>
                          </element>
                        </optional>
                      </element>
                      <optional>
                        <element name="disable_production_term">
                          <a:documentation>enabling this option disables the production term in the k and epsilon equations</a:documentation>
                          <empty/>
                        </element>
                      </optional>
                      <optional>
                        <element name="disable_destruction_term">
                          <a:documentation>enabling this option disables the destruction term in the k and epsilon equation</a:documentation>
                          <empty/>
                        </element>
                      </optional>
                      <optional>
                        <element name="disable_buoyancy_term">
                          <a:documentation>enabling this option disables the bouyancy term in the k and epsilon equation</a:documentation>
                          <empty/>
                        </element>
                      </optional>
                      <optional>
                        <element name="enable_lowRe_damping">
                          <a:documentation>enabling this option enables the low-Re number damping functions regardless of whether there is
a low-Re boundary condition</a:documentation>
                          <empty/>
                        </element>
                      </optional>
                      <optional>
                        <element name="zero_reynolds_stress_tensor">
                          <a:documentation>Enabling this option disables feedback from the k-epsilon model back into 
the rest of the model. Reynolds stress tensor is set to zero by zeroing 
EddyViscosity and the added source term, based on k, in the momentum equation.
Hence, Viscosity will always stay as the BackgroundViscosity,
diffusivities will remain at the relevant BackgroundDiffusivity, and the 
momentum equation will be as if there were no turbulence model present. 

ScalarEddyViscosity is still calculated as normal.</a:documentation>
                          <empty/>
                        </element>
                      </optional>
                    </element>
                  </optional>
                </element>
              </optional>
            </element>
          </optional>
          <optional>
            <element name="scalar_field">
              <a:documentation>Pressure</a:documentation>
              <attribute name="rank">
                <value>0</value>
              </attribute>
              <attribute name="name">
                <value>Pressure</value>
              </attribute>
              <choice>
                <a:documentation>Field type</a:documentation>
                <element name="prognostic">
                  <!-- mesh choice with PressureMesh as first option -->
                  <ref name="pressure_mesh_choice"/>
                  <ref name="prognostic_pressure_field"/>
                </element>
                <element name="prescribed">
                  <!-- mesh choice with PressureMesh as first option -->
                  <ref name="pressure_mesh_choice"/>
                  <ref name="prescribed_scalar_field"/>
                </element>
                <element name="diagnostic">
                  <a:documentation>Compute pressure from Density and InternalEnergy
via a compressible equation of state.</a:documentation>
                  <!-- mesh choice with PressureMesh as first option -->
                  <ref name="pressure_mesh_choice"/>
                  <ref name="internal_algorithm"/>
                  <ref name="diagnostic_scalar_field"/>
                </element>
                <element name="aliased">
                  <attribute name="material_phase_name">
                    <data type="string"/>
                  </attribute>
                  <attribute name="field_name">
                    <value>Pressure</value>
                  </attribute>
                </element>
              </choice>
            </element>
          </optional>
          <optional>
            <element name="scalar_field">
              <a:documentation>Density</a:documentation>
              <attribute name="rank">
                <value>0</value>
              </attribute>
              <attribute name="name">
                <value>Density</value>
              </attribute>
              <choice>
                <a:documentation>Field type</a:documentation>
                <element name="diagnostic">
                  <ref name="internal_algorithm"/>
                  <ref name="velocity_mesh_choice"/>
                  <ref name="diagnostic_scalar_field"/>
                </element>
                <element name="prognostic">
                  <ref name="pressure_mesh_choice"/>
                  <ref name="prognostic_density_field"/>
                </element>
                <element name="aliased">
                  <attribute name="material_phase_name">
                    <data type="string"/>
                  </attribute>
                  <attribute name="field_name">
                    <value>Density</value>
                  </attribute>
                </element>
              </choice>
            </element>
          </optional>
          <element name="vector_field">
            <a:documentation>Velocity vector and momentum options</a:documentation>
            <attribute name="rank">
              <value>1</value>
            </attribute>
            <attribute name="name">
              <value>Velocity</value>
            </attribute>
            <choice>
              <a:documentation>Field type</a:documentation>
              <element name="prognostic">
                <ref name="velocity_mesh_choice"/>
                <ref name="prognostic_velocity_field"/>
              </element>
              <element name="prescribed">
                <ref name="velocity_mesh_choice"/>
                <ref name="prescribed_vector_field"/>
              </element>
              <element name="diagnostic">
                <ref name="velocity_mesh_choice"/>
                <ref name="vector_python_diagnostic_algorithm"/>
                <ref name="diagnostic_vector_field"/>
              </element>
              <element name="aliased">
                <attribute name="material_phase_name">
                  <data type="string"/>
                </attribute>
                <attribute name="field_name">
                  <value>Velocity</value>
                </attribute>
              </element>
            </choice>
          </element>
          <zeroOrMore>
            <ref name="scalar_field_choice"/>
          </zeroOrMore>
          <zeroOrMore>
            <ref name="vector_field_choice"/>
          </zeroOrMore>
          <zeroOrMore>
            <ref name="tensor_field_choice"/>
          </zeroOrMore>
          <optional>
            <element name="electrical_properties">
              <a:documentation>Parameters required to model spontaneous electrical potentials in porous media.</a:documentation>
              <choice>
                <element name="conductivity">
                  <a:documentation>Specify electrical conductivity of fluid (S/m).
This assumes that salinity and temperature are not used.</a:documentation>
                  <ref name="real"/>
                </element>
                <element name="conductivity_from_salinity">
                  <a:documentation>Calculate conductivity from fluid salinity</a:documentation>
                  <empty/>
                </element>
                <element name="conductivity_from_salinity_and_temperature">
                  <a:documentation>Calculate conductivity from fluid salinity and temperature</a:documentation>
                  <empty/>
                </element>
              </choice>
              <element name="coupling_coefficients">
                <a:documentation>Various coupling coefficients associated with spontaneous potentials.</a:documentation>
                <optional>
                  <element name="scalar_field">
                    <a:documentation>Electrokinetic coupling coefficient (V/Pa).</a:documentation>
                    <attribute name="rank">
                      <value>0</value>
                    </attribute>
                    <attribute name="name">
                      <value>Electrokinetic</value>
                    </attribute>
                    <choice>
                      <element name="prescribed">
                        <ref name="velocity_mesh_choice"/>
                        <ref name="prescribed_scalar_field_no_adapt"/>
                      </element>
                      <element name="diagnostic">
                        <ref name="velocity_mesh_choice"/>
                        <ref name="scalar_python_diagnostic_algorithm"/>
                        <ref name="diagnostic_scalar_field_no_adapt"/>
                      </element>
                    </choice>
                  </element>
                </optional>
                <optional>
                  <element name="scalar_field">
                    <a:documentation>Thermoelectric coupling coefficient (V/K).</a:documentation>
                    <attribute name="rank">
                      <value>0</value>
                    </attribute>
                    <attribute name="name">
                      <value>Thermoelectric</value>
                    </attribute>
                    <choice>
                      <element name="prescribed">
                        <ref name="velocity_mesh_choice"/>
                        <ref name="prescribed_scalar_field_no_adapt"/>
                      </element>
                      <element name="diagnostic">
                        <ref name="velocity_mesh_choice"/>
                        <ref name="scalar_python_diagnostic_algorithm"/>
                        <ref name="diagnostic_scalar_field_no_adapt"/>
                      </element>
                    </choice>
                  </element>
                </optional>
                <optional>
                  <element name="scalar_field">
                    <a:documentation>Electrochemical coupling coefficient (V.L/mol).</a:documentation>
                    <attribute name="rank">
                      <value>0</value>
                    </attribute>
                    <attribute name="name">
                      <value>Electrochemical</value>
                    </attribute>
                    <choice>
                      <element name="prescribed">
                        <ref name="velocity_mesh_choice"/>
                        <ref name="prescribed_scalar_field_no_adapt"/>
                      </element>
                      <element name="diagnostic">
                        <ref name="velocity_mesh_choice"/>
                        <ref name="scalar_python_diagnostic_algorithm"/>
                        <ref name="diagnostic_scalar_field_no_adapt"/>
                      </element>
                    </choice>
                  </element>
                </optional>
              </element>
              <optional>
                <element name="Saturation_Distribution_Search">
                  <a:documentation>Option to do a saturation distribution search which looks for the
saturation distribution which gives the best fit of electrical potential
to measured data</a:documentation>
                  <choice>
                    <element name="search_criteria_horizontal_well">
                      <a:documentation>Here we specify the extents of the search space in x, y and z directions:</a:documentation>
                      <element name="x_min">
                        <a:documentation>The minimum x-coordinate of the test space</a:documentation>
                        <ref name="real"/>
                      </element>
                      <element name="x_max">
                        <a:documentation>The maximum x-coordinate of the test space</a:documentation>
                        <ref name="real"/>
                      </element>
                      <element name="width">
                        <a:documentation>The initial width of the segments, positioned symmetrically opposite the borehole</a:documentation>
                        <ref name="real"/>
                      </element>
                      <optional>
                        <element name="search_for_width">
                          <a:documentation>Option to search for the optimum width</a:documentation>
                          <ref name="comment"/>
                        </element>
                      </optional>
                      <element name="y_min">
                        <a:documentation>The minimum y-coordinate of the test space</a:documentation>
                        <ref name="real"/>
                      </element>
                      <element name="y_max">
                        <a:documentation>The maximum y-coordinate of the test space</a:documentation>
                        <ref name="real"/>
                      </element>
                      <element name="z_min">
                        <a:documentation>The minimum z-coordinate of the test space,
usually equal to the initial position of the water front</a:documentation>
                        <ref name="real"/>
                      </element>
                      <element name="borehole_x">
                        <a:documentation>x-coordinate of the borehole</a:documentation>
                        <ref name="real"/>
                      </element>
                      <element name="borehole_z">
                        <a:documentation>z-coordinate of the borehole</a:documentation>
                        <ref name="real"/>
                      </element>
                      <element name="z_max">
                        <a:documentation>The maximum z-coordinate of the test space,
probably equal to the location of the borehole</a:documentation>
                        <ref name="real"/>
                      </element>
                      <element name="sections">
                        <a:documentation>The number of sections into which to divide the space</a:documentation>
                        <ref name="integer"/>
                      </element>
                      <element name="initial_step_length">
                        <a:documentation>Initial step length for the Hooke and Jeeves search</a:documentation>
                        <ref name="real"/>
                      </element>
                      <optional>
                        <element name="initial_base_point">
                          <a:documentation>Set initial base_point, perhaps make this optional later.
Starts at the bottom for vertical well!!</a:documentation>
                          <ref name="real_vector"/>
                        </element>
                      </optional>
                      <element name="target_filename">
                        <a:documentation>filename for target file (real potential curve)</a:documentation>
                        <data type="string" datatypeLibrary=""/>
                      </element>
                    </element>
                    <element name="search_criteria_vertical_well">
                      <element name="x_min">
                        <a:documentation>The minimum x-coordinate of the test space</a:documentation>
                        <ref name="real"/>
                      </element>
                      <element name="x_max">
                        <a:documentation>The maximum x-coordinate of the test space</a:documentation>
                        <ref name="real"/>
                      </element>
                      <element name="width">
                        <a:documentation>The initial width of the segments, positioned symmetrically opposite the borehole</a:documentation>
                        <ref name="real"/>
                      </element>
                      <optional>
                        <element name="search_for_width">
                          <a:documentation>Option to search for the optimum width</a:documentation>
                          <ref name="comment"/>
                        </element>
                      </optional>
                      <element name="y_min">
                        <a:documentation>The minimum y-coordinate of the test space,
usually equal to the initial position of the water front</a:documentation>
                        <ref name="real"/>
                      </element>
                      <element name="y_max">
                        <a:documentation>The maximum y-coordinate of the test space,
probably equal to the location of the borehole</a:documentation>
                        <ref name="real"/>
                      </element>
                      <element name="z_min">
                        <a:documentation>The minimum z-coordinate of the test space</a:documentation>
                        <ref name="real"/>
                      </element>
                      <element name="z_max">
                        <a:documentation>The maximum z-coordinate of the test space</a:documentation>
                        <ref name="real"/>
                      </element>
                      <element name="borehole_x">
                        <a:documentation>x-coordinate of the borehole</a:documentation>
                        <ref name="real"/>
                      </element>
                      <element name="borehole_y">
                        <a:documentation>y-coordinate of the borehole</a:documentation>
                        <ref name="real"/>
                      </element>
                      <element name="sections">
                        <a:documentation>The number of sections into which to divide the space</a:documentation>
                        <ref name="integer"/>
                      </element>
                      <element name="initial_step_length">
                        <a:documentation>Initial step length for the Hooke and Jeeves search</a:documentation>
                        <ref name="real"/>
                      </element>
                      <optional>
                        <element name="initial_base_point">
                          <a:documentation>Set initial base_point, perhaps make this optional later</a:documentation>
                          <ref name="real_vector"/>
                        </element>
                      </optional>
                      <element name="target_filename">
                        <a:documentation>filename for target file (real potential curve)</a:documentation>
                        <data type="string" datatypeLibrary=""/>
                      </element>
                    </element>
                  </choice>
                </element>
              </optional>
            </element>
          </optional>
          <optional>
            <element name="multiphase_properties">
              <a:documentation>Phase interaction options for Fluidity's multiphase flow model</a:documentation>
              <ref name="comment"/>
              <optional>
                <element name="particle_diameter">
                  <ref name="real"/>
                </element>
              </optional>
              <optional>
                <element name="effective_conductivity">
                  <a:documentation>If this is the fluid phase, 
the effective conductivity is required 
for the inter-phase heat transfer term.</a:documentation>
                  <ref name="real"/>
                </element>
              </optional>
              <optional>
                <element name="specific_heat">
                  <a:documentation>The specific heat (at constant volume) is required 
for the inter-phase heat transfer term.</a:documentation>
                  <ref name="real"/>
                </element>
              </optional>
            </element>
          </optional>
          <optional>
            <ref name="sediment"/>
          </optional>
        </element>
      </oneOrMore>
      <optional>
        <ref name="mesh_adaptivity_options"/>
      </optional>
      <optional>
        <element name="imported_solids">
          <a:documentation>Information needed are a set of coordinates and 
radius for each particle.</a:documentation>
          <choice>
            <element name="solid_type">
              <attribute name="name">
                <value>cylinders</value>
              </attribute>
              <element name="cylinder_width">
                <ref name="real"/>
              </element>
            </element>
            <element name="solid_type">
              <attribute name="name">
                <value>spheres</value>
              </attribute>
            </element>
            <element name="solid_type">
              <attribute name="name">
                <value>small_spheres</value>
              </attribute>
            </element>
            <element name="solid_type">
              <attribute name="name">
                <value>external_2D_mesh</value>
              </attribute>
              <choice>
                <element name="mapping_type">
                  <attribute name="name">
                    <value>brute_force</value>
                  </attribute>
                  <empty/>
                </element>
                <element name="mapping_type">
                  <attribute name="name">
                    <value>fastest_n_to_n</value>
                  </attribute>
                  <element name="max_number_of_bins_x">
                    <a:documentation>As a rule of thumb, (Xmax-Xmin)/(number of bins_x) should be
greater than (at least twice) the maximum element size
of the fluid mesh (in the region where the particle is).
Same thing applies in Y and Z
directions. Note that in some cases,
choosing the maximum element size for the
whole fluid mesh
might prove to slow down the mapping a
bit.(bins might not have the
optimal size)</a:documentation>
                    <ref name="integer"/>
                  </element>
                  <element name="max_number_of_bins_y">
                    <ref name="integer"/>
                  </element>
                  <element name="max_number_of_bins_z">
                    <ref name="integer"/>
                  </element>
                  <element name="ntry">
                    <ref name="integer"/>
                  </element>
                </element>
              </choice>
              <element name="volume_checking_tol">
                <ref name="real"/>
              </element>
            </element>
            <element name="solid_type">
              <attribute name="name">
                <value>external_3D_mesh</value>
              </attribute>
              <choice>
                <element name="mapping_type">
                  <attribute name="name">
                    <value>brute_force</value>
                  </attribute>
                  <empty/>
                </element>
                <element name="mapping_type">
                  <attribute name="name">
                    <value>fastest_n_to_n</value>
                  </attribute>
                  <element name="max_number_of_bins_x">
                    <a:documentation>As a rule of thumb, (Xmax-Xmin)/(number of bins_x) should be
greater than (at least twice) the maximum element size
of the fluid mesh (in the region where the particle is).
Same thing applies in Y and Z
directions. Note that in some cases,
choosing the maximum element size for the whole fluid mesh 
might prove to slow down the mapping a
bit.(bins might not have the
optimal size)</a:documentation>
                    <ref name="integer"/>
                  </element>
                  <element name="max_number_of_bins_y">
                    <ref name="integer"/>
                  </element>
                  <element name="max_number_of_bins_z">
                    <ref name="integer"/>
                  </element>
                  <element name="ntry">
                    <ref name="integer"/>
                  </element>
                </element>
              </choice>
              <element name="volume_checking_tol">
                <ref name="real"/>
              </element>
            </element>
          </choice>
          <ref name="input_solid_dynamics_choice"/>
          <element name="number_of_particles">
            <ref name="integer"/>
          </element>
          <optional>
            <element name="position_script">
              <ref name="python_code"/>
            </element>
          </optional>
          <optional>
            <element name="radius_script">
              <ref name="python_code"/>
            </element>
          </optional>
          <optional>
            <element name="translation_velocity_script">
              <ref name="python_code"/>
            </element>
          </optional>
          <optional>
            <element name="angular_velocity_script">
              <ref name="python_code"/>
            </element>
          </optional>
          <optional>
            <element name="buoyancy">
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="oneway">
              <empty/>
            </element>
          </optional>
          <element name="solid_concentration_max">
            <ref name="real"/>
          </element>
          <element name="solid_absorption_factor">
            <ref name="real"/>
          </element>
          <element name="solid_density">
            <ref name="real"/>
          </element>
          <optional>
            <element name="use_multimaterials">
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="calculate_total_volume">
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="create_buffer">
              <element name="buffer">
                <ref name="real"/>
              </element>
              <element name="solid_concentration_min">
                <ref name="real"/>
              </element>
              <optional>
                <element name="include_in_drag">
                  <empty/>
                </element>
              </optional>
              <element name="profile1">
                <ref name="real"/>
              </element>
              <element name="profile2">
                <ref name="real"/>
              </element>
              <element name="profile3">
                <ref name="real"/>
                <element name="constant_profile">
                  <ref name="real"/>
                </element>
              </element>
            </element>
          </optional>
          <optional>
            <element name="visualize_solidfluid">
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="use_particle_cfl">
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="calculate_drag">
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="output_drag">
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="output_particle_vtus">
              <empty/>
            </element>
          </optional>
        </element>
      </optional>
      <optional>
        <element name="turbine_model">
          <a:documentation>turbine model</a:documentation>
          <zeroOrMore>
            <element name="turbine">
              <a:documentation>specifies a turbine</a:documentation>
              <attribute name="name">
                <data type="string"/>
              </attribute>
              <choice>
                <a:documentation>Model type</a:documentation>
                <element name="dirichlet">
                  <a:documentation>Enforces the turbine model by using the dirichlet condition.</a:documentation>
                  <element name="boundary_condition_name_1">
                    <a:documentation>Name of the upstream (weak or strong) dirichlet boundary condition where the turbine model shall be applied to.</a:documentation>
                    <attribute name="name">
                      <data type="string"/>
                    </attribute>
                  </element>
                  <element name="boundary_condition_name_2">
                    <a:documentation>Name of the downstream (weak or strong) dirichlet boundary condition where the turbine model shall be applied to.</a:documentation>
                    <attribute name="name">
                      <data type="string"/>
                    </attribute>
                  </element>
                  <element name="free_surface_point_1">
                    <a:documentation>These coordinates define the upstream point where the free surface will be evaluated in order to calculate the head.</a:documentation>
                    <ref name="real_dim_vector"/>
                  </element>
                  <element name="free_surface_point_2">
                    <a:documentation>These coordinate define the downstream point where the free surface will be evaluated in order to calculate the head.</a:documentation>
                    <ref name="real_dim_vector"/>
                  </element>
                  <element name="head_flux">
                    <a:documentation>Python function val(h) takes the head h (=free_surface_point_1-free_surface_point_2) and returns the total flux through turbine (in m^3/s). A return value 
of 0.0 will deactivate the turbine model which results in the dirichlet conditions prescribed at these boundaries.
A flux value will be outflow for boundary_condition_name_1 and inflow for boundary_condition_name_2 and therefore sign(h)==sign(val(h)) should be true to achieve stability.</a:documentation>
                    <ref name="python_code"/>
                  </element>
                </element>
                <element name="flux">
                  <a:documentation>Implements the turbine model by using the fluxes from the discontinues galerkin model. Works only if dg is used. </a:documentation>
                  <choice>
                    <a:documentation>Model type</a:documentation>
                    <element name="penalty">
                      <element name="factor">
                        <a:documentation>Python function val(h) takes the pressure jump h and returns the flux factor between 0 and 1. A return value 
of 0.0 will deactivate the turbine model which results in the dirichlet conditions prescribed at these boundaries 
while a factor of +INF represents a connected domain.</a:documentation>
                        <ref name="python_code"/>
                      </element>
                    </element>
                    <element name="dg">
                      <element name="factor">
                        <a:documentation>Python function val(h) takes the pressure jump h and returns the flux factor between 0 and 1. A return value 
of 0.0 will deactivate the turbine model which results in the dirichlet conditions prescribed at these boundaries 
while a factor of 1 represents a connected domain.</a:documentation>
                        <ref name="python_code"/>
                      </element>
                    </element>
                  </choice>
                  <element name="boundary_condition_name_1">
                    <a:documentation>Name of the upstream (weak or strong) dirichlet boundary condition where the turbine model shall be applied to.</a:documentation>
                    <attribute name="name">
                      <data type="string"/>
                    </attribute>
                  </element>
                  <element name="boundary_condition_name_2">
                    <a:documentation>Name of the downstream (weak or strong) dirichlet boundary condition where the turbine model shall be applied to.</a:documentation>
                    <attribute name="name">
                      <data type="string"/>
                    </attribute>
                  </element>
                  <choice>
                    <element name="always_on">
                      <a:documentation>The turbine is always running. This is mainly used for debugging purposes.</a:documentation>
                      <empty/>
                    </element>
                    <element name="always_off">
                      <a:documentation>The turbine is never running. This is mainly used for debugging purposes.</a:documentation>
                      <empty/>
                    </element>
                  </choice>
                </element>
              </choice>
            </element>
          </zeroOrMore>
        </element>
      </optional>
      <optional>
        <ref name="biology"/>
      </optional>
      <optional>
        <ref name="forcing"/>
      </optional>
      <optional>
        <ref name="reduced_model"/>
      </optional>
      <optional>
        <ref name="porous_media_model"/>
      </optional>
      <optional>
        <ref name="embedded_models"/>
      </optional>
      <optional>
        <ref name="flredecomp"/>
      </optional>
      <optional>
        <ref name="multiphase_interaction"/>
      </optional>
    </element>
  </start>
  <define name="sediment">
    <element name="sediment">
      <a:documentation>A sediment model. See the manual for details on how to use this model.</a:documentation>
      <zeroOrMore>
        <element name="scalar_field">
          <a:documentation>A single sediment field with discrete characteristics

Notes: 

- a sinking velocity is required for sediment fields, this can be set for each
sediment field under prognostic/SinkingVelocity

- continuity must be the same for all fields. i.e. use the same mesh for all fields

- rentrainment bc's can be used to allow sediment to be picked up from the bed
due to turbulence. This must be set on the same boundaries as the SedimentDepositon
field

- see the manual for more details on how to use this model </a:documentation>
          <attribute name="rank">
            <value>0</value>
          </attribute>
          <attribute name="name">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <element name="prognostic">
            <a:documentation>Field type</a:documentation>
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
            <element name="scalar_field">
              <a:documentation>Sediment bedload diagnostic which records the sediment 
deposited through the prescribed boundary.

The units are in unit distances as a depth of sediment.

- The equation type must be set to SedimentBedload

- Spatial discretisation should be as the parent sediment class

- Initial conditions can be set as normal

- Most other settings are irrelevant
    - No solver settings are required as the sediment model only works
      for p1 discretisations where the mass matrix can be easily inverted.
    - The bedload is always calculated completely explicitly
    - You cannot apply Source or Absorbtion terms to the bedload
    - There is no diffusion of the bedload</a:documentation>
              <attribute name="rank">
                <value>0</value>
              </attribute>
              <attribute name="name">
                <value>Bedload</value>
              </attribute>
              <group>
                <a:documentation>Field type</a:documentation>
                <element name="prognostic">
                  <element name="surface_ids">
                    <a:documentation>Surface ids over which to calculate the bedload:</a:documentation>
                    <ref name="integer_vector"/>
                  </element>
                  <ref name="prognostic_scalar_field"/>
                  <optional>
                    <element name="disable_calculation">
                      <a:documentation>Disables calculation of change to bedload due to 
erosion/deposition (generally only used for mms testing):</a:documentation>
                      <empty/>
                    </element>
                  </optional>
                </element>
              </group>
            </element>
            <element name="scalar_field">
              <a:documentation>Sediment bedload diagnostic which records the sediment 
deposited through the prescribed boundary.

The units are in unit distances/second.</a:documentation>
              <attribute name="rank">
                <value>0</value>
              </attribute>
              <attribute name="name">
                <value>BedloadVolumeFraction</value>
              </attribute>
              <element name="diagnostic">
                <a:documentation>Field type</a:documentation>
                <ref name="diagnostic_scalar_field"/>
              </element>
            </element>
            <optional>
              <element name="scalar_field">
                <a:documentation>Sediment bedload deposit rate diagnostic.

The units are in unit distances/second.</a:documentation>
                <attribute name="rank">
                  <value>0</value>
                </attribute>
                <attribute name="name">
                  <value>BedloadDepositRate</value>
                </attribute>
                <element name="diagnostic">
                  <a:documentation>Field type</a:documentation>
                  <ref name="diagnostic_scalar_field"/>
                </element>
              </element>
            </optional>
            <optional>
              <element name="scalar_field">
                <a:documentation>Sediment bedload erosion rate diagnostic.

The units are in unit distances as a depth of sediment.</a:documentation>
                <attribute name="rank">
                  <value>0</value>
                </attribute>
                <attribute name="name">
                  <value>BedloadErosionRate</value>
                </attribute>
                <element name="diagnostic">
                  <a:documentation>Field type</a:documentation>
                  <ref name="diagnostic_scalar_field"/>
                </element>
              </element>
            </optional>
            <optional>
              <element name="scalar_field">
                <a:documentation>This is the unhindered sinking velocity of the sediment particles. 

With the sinking velocity field set to diagnostic, this field is used, along with the sediment 
concentration, to calculate the hindered sinking velocity of sediment particles. 

This uses the equation developed by Richardson and Zaki [1954]. 

If the 'SinkingVelocity' is not set to diagnostic, this field will not be used.

As with the sinking velocity, this velocity is in the direction of gravity so if the substance
floats upwards, this field should be negative.

This should be on the same mesh as the associated SinkingVelocity field.</a:documentation>
                <attribute name="name">
                  <value>UnhinderedSinkingVelocity</value>
                </attribute>
                <attribute name="rank">
                  <value>0</value>
                </attribute>
                <element name="prescribed">
                  <ref name="velocity_mesh_choice"/>
                  <ref name="prescribed_scalar_field"/>
                </element>
              </element>
            </optional>
            <element name="submerged_specific_gravity">
              <a:documentation>This is the submerged specific gravity, R, of this sediment. 
It will be used with the sediment concentration in the equation
of state, as well as in erosion algorithms.

R = (rho_s - rho_a)/(rho_a)

Where: rho_s is the sediment density and rho_a is the ambient fluid density</a:documentation>
              <ref name="real"/>
            </element>
            <optional>
              <element name="diameter">
                <a:documentation>This is the diameter of the grain.
Diameter must be specified here or under each sediment class.</a:documentation>
                <ref name="real"/>
              </element>
            </optional>
            <optional>
              <element name="bed_porosity">
                <a:documentation>Set porosity to use. Default is 0.3. 1.0 is a sold material.</a:documentation>
                <ref name="real"/>
              </element>
            </optional>
            <optional>
              <element name="erodability">
                <a:documentation>Erodability of the sediment grain. A value of one means that only the
critical shear stress is used to determine if a grain can be put into 
suspension. A value of zero means these grains can never be resuspended.
Default is 1.</a:documentation>
                <ref name="real"/>
              </element>
            </optional>
            <optional>
              <element name="critical_shear_stress">
                <a:documentation>Critical shear stress of a grain. If not switched on a value
will be computed according to the particle Reynolds number and Shield's
criterion.</a:documentation>
                <ref name="real"/>
              </element>
            </optional>
          </element>
        </element>
      </zeroOrMore>
      <element name="scalar_field">
        <a:documentation>The median sediment diameter in the active layer of the bed. 
Required for some reentrainment algorithms.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>SedimentBedActiveLayerD50</value>
        </attribute>
        <element name="diagnostic">
          <element name="surface_ids">
            <a:documentation>Surface ids over which to calculate the bedload:</a:documentation>
            <ref name="integer_vector"/>
          </element>
          <ref name="internal_algorithm"/>
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>The standard deviation of sediment in the active layer of the
bed. Required for some reentrainment algorithms</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>SedimentBedActiveLayerSigma</value>
        </attribute>
        <element name="diagnostic">
          <element name="surface_ids">
            <a:documentation>Surface ids over which to calculate the bedload:</a:documentation>
            <ref name="integer_vector"/>
          </element>
          <ref name="internal_algorithm"/>
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <optional>
        <element name="tensor_field">
          <a:documentation>ZeroSedimentConcentrationViscosity field:

Field for the viscosity of this a fluid with zero 
concentration of sediment.
Required if using a diagnostic viscosity
in a sediment problem where sediment concentration
dependent viscosity is required.</a:documentation>
          <attribute name="rank">
            <value>2</value>
          </attribute>
          <attribute name="name">
            <value>ZeroSedimentConcentrationViscosity</value>
          </attribute>
          <choice>
            <element name="prescribed">
              <ref name="velocity_mesh_choice"/>
              <ref name="prescribed_tensor_field"/>
            </element>
            <element name="aliased">
              <ref name="generic_aliased_field"/>
            </element>
          </choice>
        </element>
      </optional>
    </element>
  </define>
  <define name="prognostic_density_field">
    <optional>
      <ref name="scalar_equation_choice"/>
    </optional>
    <element name="spatial_discretisation">
      <a:documentation>Spatial discretisation options</a:documentation>
      <choice>
        <element name="continuous_galerkin">
          <a:documentation>Continuous Galerkin formulation.</a:documentation>
          <ref name="advection_stabilisation_options"/>
          <element name="advection_terms">
            <a:documentation>Discretisation options for the advection terms.</a:documentation>
            <optional>
              <element name="integrate_advection_by_parts">
                <a:documentation>Integrate the advection terms of the momentum equation by
parts.</a:documentation>
                <ref name="comment"/>
              </element>
            </optional>
          </element>
          <element name="mass_terms">
            <a:documentation>Discretisation options for the mass terms.</a:documentation>
            <optional>
              <element name="lump_mass_matrix">
                <a:documentation>Lump the mass matrix</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
          <ref name="comment"/>
        </element>
        <ref name="discontinuous_galerkin_options">
          <a:documentation>Discontinuous galerkin formulation</a:documentation>
        </ref>
        <element name="control_volumes">
          <a:documentation>Use a control volume discretisation.</a:documentation>
          <ref name="spatial_control_volume_options"/>
        </element>
      </choice>
      <element name="conservative_advection">
        <a:documentation>Conservative discretisation of field advection equation
 TBETA=1. -- conservative (divergence form)
 TBETA=0. -- non-conservative
 0. &lt; TBETA &lt; 1.</a:documentation>
        <ref name="real"/>
      </element>
    </element>
    <element name="temporal_discretisation">
      <element name="theta">
        <a:documentation>Implicit/explicit control (TTHETA)
 =0.  -- explicit
 =0.5 -- Crank-Nicholson
 =1.  -- implicit</a:documentation>
        <ref name="real"/>
      </element>
      <optional>
        <ref name="temporal_control_volume_options"/>
      </optional>
    </element>
    <optional>
      <choice>
        <element name="solver">
          <a:documentation>Solver</a:documentation>
          <ref name="linear_solver_options_asym_scalar"/>
        </element>
        <element name="explicit">
          <a:documentation>Assume this field is being solved explicitly and skip the solver.

ONLY AVAILABLE FOR PURE CONTROL VOLUME SPATIAL DISCRETISATIONS.

Assumes lhs matrix only has diagonal lumped mass (times
density if appropriate for equation)
and divides the rhs by this.</a:documentation>
          <empty/>
        </element>
      </choice>
    </optional>
    <oneOrMore>
      <choice>
        <element name="initial_condition">
          <a:documentation>Initial condition for WholeMesh

Only specify one condition if not using mesh regions.
Otherwise select other initial_condition option, specify region_ids
and distinct names.  Then add extra intial conditions for other regions.</a:documentation>
          <attribute name="name">
            <value>WholeMesh</value>
          </attribute>
          <ref name="input_choice_initial_condition_real"/>
        </element>
        <element name="initial_condition">
          <a:documentation>Multiple initial_conditions are allowed if specifying
different values in different
regions of the mesh (defined by region_ids).  In this case
each initial_condition
requires a distinct name for the options dictionary.</a:documentation>
          <attribute name="name">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <optional>
            <ref name="region_ids"/>
          </optional>
          <ref name="input_choice_initial_condition_real"/>
        </element>
      </choice>
    </oneOrMore>
    <zeroOrMore>
      <element name="boundary_conditions">
        <a:documentation>Boundary conditions</a:documentation>
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
        <element name="surface_ids">
          <a:documentation>Surface id:</a:documentation>
          <ref name="integer_vector"/>
        </element>
        <group>
          <a:documentation>Type</a:documentation>
          <element name="type">
            <attribute name="name">
              <value>dirichlet</value>
            </attribute>
            <optional>
              <element name="apply_weakly">
                <a:documentation>Apply the dirichlet bc weakly.  Available
automatically with discontinuous_galerkin,
and control_volume spatial_discretisations.
If not selected boundary conditions are applied strongly.</a:documentation>
                <optional>
                  <element name="boundary_overwrites_initial_condition">
                    <a:documentation>If the initial condition and boundary conditions
differ, setting this option will cause the initial
condition on the boundary to be overwritten with
the boundary condition. Since you are applying the
boundary condition weakly, you probably do *not*
want this.</a:documentation>
                    <empty/>
                  </element>
                </optional>
              </element>
            </optional>
            <ref name="input_choice_real"/>
          </element>
        </group>
      </element>
    </zeroOrMore>
    <optional>
      <element name="scalar_field">
        <a:documentation>source term</a:documentation>
        <attribute name="name">
          <value>Source</value>
        </attribute>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="prescribed_scalar_field_no_adapt"/>
            <optional>
              <ref name="recalculation_options"/>
            </optional>
          </element>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="diagnostic_scalar_field_no_adapt"/>
          </element>
        </choice>
      </element>
    </optional>
    <optional>
      <element name="scalar_field">
        <a:documentation>Absorption term</a:documentation>
        <attribute name="name">
          <value>Absorption</value>
        </attribute>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <element name="prescribed">
          <ref name="prescribed_scalar_field_no_adapt"/>
        </element>
      </element>
    </optional>
    <ref name="prognostic_scalar_output_options"/>
    <ref name="prognostic_scalar_stat_options"/>
    <ref name="scalar_convergence_options"/>
    <ref name="prognostic_detector_options"/>
    <ref name="scalar_steady_state_options"/>
    <ref name="adaptivity_options_prognostic_scalar_field"/>
    <ref name="interpolation_algorithm_scalar"/>
    <optional>
      <ref name="discrete_properties_algorithm_scalar"/>
    </optional>
    <optional>
      <element name="priority">
        <a:documentation>Set the priority of this field
This determines the order in which scalar_fields are solved for:
 - higher numbers have the highest priority
 - lower numbers (including negative) have the lowest priority
 - default if not set is 0</a:documentation>
        <ref name="integer"/>
      </element>
    </optional>
  </define>
  <define name="geometry">
    <element name="geometry">
      <a:documentation>Options dealing with the specification of geometry</a:documentation>
      <element name="dimension">
        <a:documentation>Dimension of the problem.
&lt;b&gt;This can only be set once&lt;/b&gt;</a:documentation>
        <element name="integer_value">
          <attribute name="rank">
            <value>0</value>
          </attribute>
          <choice>
            <value>3</value>
            <value>2</value>
            <value>1</value>
          </choice>
        </element>
      </element>
      <element name="mesh">
        <a:documentation>The position mesh</a:documentation>
        <attribute name="name">
          <value>CoordinateMesh</value>
        </attribute>
        <ref name="mesh_info"/>
      </element>
      <optional>
        <element name="mesh">
          <a:documentation>The velocity mesh</a:documentation>
          <attribute name="name">
            <value>VelocityMesh</value>
          </attribute>
          <ref name="mesh_info"/>
        </element>
      </optional>
      <optional>
        <element name="mesh">
          <a:documentation>The pressure mesh</a:documentation>
          <attribute name="name">
            <value>PressureMesh</value>
          </attribute>
          <ref name="mesh_info"/>
        </element>
      </optional>
      <zeroOrMore>
        <element name="mesh">
          <attribute name="name">
            <data type="string"/>
          </attribute>
          <ref name="mesh_info"/>
          <optional>
            <element name="exclude_from_mesh_adaptivity">
              <empty/>
            </element>
          </optional>
        </element>
      </zeroOrMore>
      <element name="quadrature">
        <a:documentation>Quadrature</a:documentation>
        <element name="degree">
          <a:documentation>Quadrature degree

note: this specifies the degree of quadrature,
not the number of gauss points</a:documentation>
          <ref name="integer"/>
        </element>
        <optional>
          <element name="surface_degree">
            <a:documentation>Surface quadrature degree

note: this specifies the degree of surface
quadrature not the number of surface gauss points</a:documentation>
            <ref name="integer"/>
          </element>
        </optional>
        <optional>
          <element name="controlvolume_surface_degree">
            <a:documentation>Sets the degree of quadrature on each quadrilateral
face of the control volume. 

Defaults to 1 if
unselected which is the same as pre-new options
behaviour.</a:documentation>
            <ref name="integer"/>
          </element>
        </optional>
        <optional>
          <element name="quadrature_family">
            <a:documentation>Select which family of quadrature rules to use.
The default is family_cools.
family_wandzura allows for degree up to 30
on triangular meshes.
family_grundmann_moeller allows for degree up to
29 on simplicial meshes in arbitrary dimension.</a:documentation>
            <element name="string_value">
              <choice>
                <value>family_cools</value>
                <value>family_grundmann_moeller</value>
                <value>family_wandzura</value>
              </choice>
            </element>
          </element>
        </optional>
      </element>
      <optional>
        <element name="disable_geometric_data_cache">
          <a:documentation>This causes the change of variables associated with each element in 
the mesh to be stored rather than calculated every time it is used. 
This should speed up computations at a cost of some memory. 

The cache is automatically regenerated after mesh movement or 
adaptivity and is automatically disabled for non-linear positions fields.</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="spherical_earth">
          <a:documentation>Options specifying that the problem is on the surface of the n-sphere.</a:documentation>
          <optional>
            <element name="superparametric_mapping">
              <a:documentation>Enabling this option approximates the curvature of the Earth as an
nth degree polynomial, where n is the polynomial degree of the coordinate mesh.</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="analytical_mapping">
              <a:documentation>The simplicial elements (as defined by the CoordinateMesh) are bent on the n-sphere
using an analytical expression (as opposed to superparametric where it's approximated
by a higher order polynomial), the derivatives are calculated by taking the analytical
derivative on the gauss points.</a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
      </optional>
      <optional>
        <element name="ocean_boundaries">
          <a:documentation>Options specifying the top surface and bottom of the domain
used in various ocean calculations.</a:documentation>
          <element name="top_surface_ids">
            <a:documentation>Specify the surface ids that make up the top of the domain,
i.e. the free surface or rigid lid.</a:documentation>
            <ref name="integer_vector"/>
          </element>
          <element name="bottom_surface_ids">
            <a:documentation>Specify the surface ids that make up the bottom.</a:documentation>
            <ref name="integer_vector"/>
          </element>
          <element name="scalar_field">
            <a:documentation>Diagnostic field giving the distance to the top surface.</a:documentation>
            <attribute name="rank">
              <value>0</value>
            </attribute>
            <attribute name="name">
              <value>DistanceToTop</value>
            </attribute>
            <element name="diagnostic">
              <ref name="internal_algorithm"/>
              <element name="mesh">
                <attribute name="name">
                  <value>CoordinateMesh</value>
                </attribute>
              </element>
              <ref name="diagnostic_scalar_field"/>
            </element>
          </element>
          <element name="scalar_field">
            <a:documentation>Diagnostic field giving the distance to ocean bottom.</a:documentation>
            <attribute name="rank">
              <value>0</value>
            </attribute>
            <attribute name="name">
              <value>DistanceToBottom</value>
            </attribute>
            <element name="diagnostic">
              <ref name="internal_algorithm"/>
              <element name="mesh">
                <attribute name="name">
                  <value>CoordinateMesh</value>
                </attribute>
              </element>
              <ref name="diagnostic_scalar_field"/>
            </element>
          </element>
        </element>
      </optional>
    </element>
  </define>
  <define name="lagrangian_timestepping">
    <element name="lagrangian_timestepping">
      <element name="subcycles">
        <a:documentation>Number of subdivisions of the timestep
increase this if you are not happy with your 
detector trajectory accuracy, or if particles
are jumping out of the domain a lot</a:documentation>
        <ref name="integer"/>
      </element>
      <element name="search_tolerance">
        <a:documentation>Tolerance for deciding if detector is in a given
element. Recommended value 1.0e-10.</a:documentation>
        <ref name="real"/>
      </element>
      <choice>
        <element name="explicit_runge_kutta_guided_search">
          <a:documentation>Use explicit runge kutta method with
guided search particle tracking</a:documentation>
          <element name="n_stages">
            <a:documentation>Number of RK stages
For the RK4 method, it should be 4.</a:documentation>
            <ref name="integer"/>
          </element>
          <element name="stage_weights">
            <a:documentation>ERK stage array. This is an array
containing the lower-triangular
part of the Butcher weight matrix
A that explains how to compute the
RK stages.  See
http://en.wikipedia.org/wiki/RungeKutta_methods#Explicit_Runge.E2.80.93Kutta_methods
for notation.  The array is stored
in the following order:
[a_{21},a_{31},a_{32},...,a_{s1},a_{s2},a_{s(s-1)}]
and so the array has size s(s-1)/2
where s is the number of stages.
For the RK4 method, it should be
[0.5,0,0.5,0,0,1]</a:documentation>
            <ref name="real_vector"/>
          </element>
          <element name="timestep_weights">
            <a:documentation>ERK timestep weights. This is the
b vector that explains how to
compute the timestep from the RK
stages.  See
http://en.wikipedia.org/wiki/RungeKutta_methods#Explicit_Runge.E2.80.93Kutta_methods
for notation.  It should have size
s where s is the number of stages.
For the RK4 method, it should be
[1/6,1/3,1/3,1/6]</a:documentation>
            <ref name="real_vector"/>
          </element>
        </element>
        <element name="forward_euler_guided_search">
          <a:documentation>Use explicit Forward Euler method with
guided search particle tracking</a:documentation>
          <empty/>
        </element>
        <element name="rk4_guided_search">
          <a:documentation>Use classical Runge-Kutta method with
guided search particle tracking</a:documentation>
          <empty/>
        </element>
      </choice>
    </element>
  </define>
  <!-- Default child of diagnostic scalar field -->
  <define name="diagnostic_scalar_field">
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_scalar_stat_options"/>
    <ref name="scalar_convergence_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="scalar_steady_state_options"/>
    <ref name="adaptivity_options_scalar_field"/>
    <optional>
      <ref name="recalculation_options"/>
    </optional>
    <optional>
      <ref name="interpolation_algorithm_scalar"/>
    </optional>
  </define>
  <!-- Default child of diagnostic scalar field without adaptivity options -->
  <define name="diagnostic_scalar_field_no_adapt">
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_scalar_stat_options"/>
    <ref name="diagnostic_detector_options"/>
  </define>
  <!-- Default child of diagnostic scalar field -->
  <define name="diagnostic_scalar_field_tidal_range">
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_scalar_stat_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="adaptivity_options_scalar_field"/>
    <element name="spin_up_time">
      <ref name="real"/>
    </element>
  </define>
  <!--
    Default child of diagnostic vector field
    Currently, this is empty, but in future this might include
    options that are general to all diagnostic vector fields
  -->
  <define name="diagnostic_vector_field">
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_vector_stat_options"/>
    <ref name="vector_convergence_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="vector_steady_state_options"/>
    <ref name="adaptivity_options_vector_field"/>
    <optional>
      <ref name="recalculation_options"/>
    </optional>
    <optional>
      <ref name="interpolation_algorithm_vector"/>
    </optional>
  </define>
  <define name="diagnostic_vector_field_bed_shear_stress">
    <element name="density">
      <ref name="real"/>
    </element>
    <element name="calculation_method">
      <a:documentation>Three options for calculation of bed shear stress are available:</a:documentation>
      <choice>
        <element name="drag_coefficient">
          <a:documentation>density*drag_coeff*|u|*u 
This is calculated at all boundaries</a:documentation>
          <ref name="real"/>
        </element>
        <element name="velocity_gradient">
          <a:documentation>nu * (grad(u) + grad(u).T)
This uses the velocity gradient at the boundaries to calculate the 
bed shear stress. Valid for non parameterised velocity boundaries.</a:documentation>
          <empty/>
        </element>
      </choice>
    </element>
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_vector_stat_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="adaptivity_options_vector_field"/>
  </define>
  <!--
    Default child of diagnostic tensor field
    Currently, this is empty, but in future this might include
    options that are general to all diagnostic tensor fields
  -->
  <define name="diagnostic_tensor_field">
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_tensor_stat_options"/>
    <ref name="adaptivity_options_tensor_field"/>
    <optional>
      <ref name="interpolation_algorithm_vector"/>
    </optional>
  </define>
  <!--
    Richardson number field. This is a normal diagnostic scalar field, but with
    Richardson number metric options added
  -->
  <define name="adaptivity_options_richardson_number_field.adaptivity_options">
    <element name="no_interpolation_measure">
      <a:documentation>Do not use an interpolation error driven metric for this field</a:documentation>
      <ref name="comment"/>
    </element>
  </define>
  <define name="adaptivity_options_richardson_number_field.adaptivity_options" combine="choice">
    <ref name="adaptivity_options_scalar_field.adaptivity_options"/>
  </define>
  <define name="adaptivity_options_richardson_number_field">
    <optional>
      <element name="adaptivity_options">
        <ref name="adaptivity_options_richardson_number_field.adaptivity_options"/>
        <optional>
          <element name="richardson_number_metric">
            <a:documentation>An isotropic metric formulation based on the Richardson number. Uses
the logic that wherever the Richardson number is small, we expect
to need resolution. Generates edge lengths using:

  Edge length = min_edge_length if Ri &lt;= min_ri
                max_edge_length if Ri &gt;= max_ri
                a linear fit between min_edge_length and max_edge_length otherwise</a:documentation>
            <optional>
              <element name="min_ri">
                <a:documentation>Richardson number at which we have minimum edge length (default 0.0)</a:documentation>
                <ref name="real"/>
              </element>
            </optional>
            <element name="max_ri">
              <a:documentation>Richardson number at which we have maximum edge length</a:documentation>
              <ref name="real"/>
            </element>
            <element name="min_edge_length">
              <a:documentation>Minimum edge length that can be requested by the Richardson number
metric</a:documentation>
              <ref name="real"/>
            </element>
            <element name="max_edge_length">
              <a:documentation>Maximum edge length that can be requested by the Richardson number
metric</a:documentation>
              <ref name="real"/>
            </element>
            <optional>
              <element name="anisotropy_preserving_merge">
                <a:documentation>Enable to preserve anisotropy when merging with other metric
formulations</a:documentation>
                <ref name="comment"/>
              </element>
            </optional>
            <ref name="comment"/>
          </element>
        </optional>
        <ref name="adaptivity_preprocessing"/>
      </element>
    </optional>
  </define>
  <define name="diagnostic_richardson_number_field">
    <ref name="diagnostic_scalar_field_no_adapt"/>
  </define>
  <define name="diagnostic_richardson_number_field" combine="interleave">
    <ref name="adaptivity_options_richardson_number_field"/>
  </define>
  <define name="diagnostic_cv_gradient_vector_field">
    <optional>
      <element name="lump_mass_matrix">
        <a:documentation>Choose whether the mass matrix is lumped or not</a:documentation>
        <empty/>
      </element>
    </optional>
    <optional>
      <element name="solver">
        <a:documentation>Solver options are necessary if you're not lumping your mass or if you're field isn't dg</a:documentation>
        <ref name="linear_solver_options_sym"/>
      </element>
    </optional>
    <optional>
      <element name="normalise">
        <a:documentation>Normalise the gradient by its magnitude</a:documentation>
        <empty/>
      </element>
    </optional>
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_vector_stat_options"/>
    <ref name="vector_convergence_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="vector_steady_state_options"/>
    <ref name="adaptivity_options_vector_field"/>
    <optional>
      <ref name="recalculation_options"/>
    </optional>
  </define>
  <define name="diagnostic_gradient_vector_field">
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options_sym"/>
    </element>
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_vector_stat_options"/>
    <ref name="vector_convergence_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="vector_steady_state_options"/>
    <ref name="adaptivity_options_vector_field"/>
    <optional>
      <ref name="recalculation_options"/>
    </optional>
  </define>
  <define name="diagnostic_cv_divergence_scalar_field">
    <!-- No solver options because it can be solved directly! -->
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_scalar_stat_options"/>
    <ref name="scalar_convergence_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="scalar_steady_state_options"/>
    <ref name="adaptivity_options_scalar_field"/>
    <optional>
      <ref name="recalculation_options"/>
    </optional>
  </define>
  <define name="diagnostic_fe_divergence_scalar_field">
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options_sym"/>
    </element>
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_scalar_stat_options"/>
    <ref name="scalar_convergence_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="scalar_steady_state_options"/>
    <ref name="adaptivity_options_scalar_field"/>
    <optional>
      <ref name="recalculation_options"/>
    </optional>
  </define>
  <!-- three optional input vectors for user-specified rotation matrix -->
  <define name="rotation_matrix_components">
    <optional>
      <element name="normal_direction">
        <a:documentation>Select if you want to specify the unit normal direction
of the rotation matrix.
If off then fluidity computes the normal.  </a:documentation>
        <ref name="input_choice_real_dim_vector"/>
      </element>
    </optional>
    <optional>
      <element name="tangent_direction_1">
        <a:documentation>Select if you want to specify the first unit tangent direction
of the rotation matrix (in dim &gt; 1 simulations).
If off then fluidity computes the tangent.  </a:documentation>
        <ref name="input_choice_real_dim_vector"/>
      </element>
    </optional>
    <optional>
      <element name="tangent_direction_2">
        <a:documentation>Select if you want to specify the second unit tangent direction
of the rotation matrix (in dim &gt; 2 simulations).
If off then fluidity computes the tangent.  </a:documentation>
        <ref name="input_choice_real_dim_vector"/>
      </element>
    </optional>
  </define>
  <define name="velocity_components_choice">
    <choice>
      <element name="align_bc_with_cartesian">
        <optional>
          <element name="x_component">
            <ref name="input_choice_real_bc_component"/>
          </element>
        </optional>
        <optional>
          <element name="y_component">
            <ref name="input_choice_real_bc_component"/>
          </element>
        </optional>
        <optional>
          <element name="z_component">
            <ref name="input_choice_real_bc_component"/>
          </element>
        </optional>
      </element>
      <element name="align_bc_with_surface">
        <optional>
          <element name="normal_component">
            <ref name="input_choice_real_plus_field"/>
          </element>
        </optional>
        <optional>
          <element name="tangent_component_1">
            <ref name="input_choice_real_plus_field"/>
          </element>
        </optional>
        <optional>
          <element name="tangent_component_2">
            <ref name="input_choice_real_plus_field"/>
          </element>
        </optional>
        <ref name="rotation_matrix_components"/>
        <optional>
          <element name="debugging_mode">
            <a:documentation>this will calculate the determinant of the
rotation matrix for every boundary node
and dump a vtu with the node 
normals and tangenials 1/2</a:documentation>
            <empty/>
          </element>
        </optional>
      </element>
    </choice>
  </define>
  <!-- Mainly tidal harmonic diagnostics -->
  <define name="free_surface_diagnostic_options">
    <optional>
      <ref name="free_surface_history_algorithm">
        <a:documentation>Activate this for tidal harmonic analysis </a:documentation>
      </ref>
    </optional>
    <optional>
      <ref name="tidal_harmonic_algorithm">
        <a:documentation>Activate this for tidal harmonic analysis </a:documentation>
      </ref>
    </optional>
  </define>
  <define name="velocity_boundary_conditions">
    <choice>
      <element name="type">
        <attribute name="name">
          <value>dirichlet</value>
        </attribute>
        <optional>
          <element name="apply_weakly">
            <a:documentation>Apply the dirichlet bc weakly.  Available automatically
with a discontinuous_galerkin Velocity
spatial_discretisation.  Available if you
integrate_continuity_by_parts with a
continuous_galerkin Pressure or use a control_volume
Pressure spatial_discretisation and/or
integrate_advection_by_parts under Velocity
spatial_discretisation with continuous_galerkin.

If not selected boundary conditions are applied strongly.</a:documentation>
            <optional>
              <element name="boundary_overwrites_initial_condition">
                <a:documentation>If the initial condition and boundary conditions
differ, setting this option will cause the initial
condition on the boundary to be overwritten with
the boundary condition. Since you are applying the
boundary condition weakly, you probably do *not*
want this.</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
        </optional>
        <ref name="velocity_components_choice"/>
      </element>
      <element name="type">
        <attribute name="name">
          <value>neumann</value>
        </attribute>
        <ref name="velocity_components_choice"/>
      </element>
      <element name="type">
        <a:documentation>Add a bulk formulae boundary condition. Only makes sense
on the Velocity field.</a:documentation>
        <attribute name="name">
          <value>bulk_formulae</value>
        </attribute>
        <empty/>
      </element>
      <element name="type">
        <attribute name="name">
          <value>free_surface</value>
        </attribute>
        <group>
          <optional>
            <element name="no_normal_stress">
              <a:documentation>The default free_surface implements the physical boundary
condition p=0 (this is full pressure without subtracting the hydrostatic component)
For viscous fluids the correct boundary condition is a no normal
stress condition, which includes a viscosity term. When using
this option a prognostic FreeSurface field is required.</a:documentation>
              <optional>
                <element name="explicit">
                  <a:documentation>Treat the free surface evolution equation separately from the momentum equation.  
i.e. stagger the solves.

Requires a prognostic FreeSurface field.</a:documentation>
                  <empty/>
                </element>
              </optional>
            </element>
          </optional>
          <optional>
            <element name="variable_density">
              <a:documentation>When selected the density at the surface is calculated using the Density field.  Therefore
this requires a Density field!</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="external_density">
              <a:documentation>When selected a hydrostatic pressure distribution on the outside is assumed
using the specified density, i.e. instead of applying p=0 (resp.
normal_stress=0) we apply p=p_external (resp. normal_stress=p_external) where p_external is determined by dp_external/dz=external_density*g</a:documentation>
              <ref name="real"/>
            </element>
          </optional>
          <optional>
            <element name="surface_stabilisation">
              <a:documentation>This options adds a surface stabilisation term to the free surface. Works only for cg velocity so far. 
Note: Once activated, the stabilisation term will occur in all free surface areas in the domain. 
IN DEVELOPMENT</a:documentation>
              <element name="scale_factor">
                <a:documentation>Scale factor for the surface stabilisation.</a:documentation>
                <ref name="real"/>
              </element>
            </element>
          </optional>
        </group>
      </element>
      <element name="type">
        <a:documentation>Apply quadratic drag. Specify drag coefficient. If you
want to exactly replicate results from using the OCEDRA
option, set this to 0.003 and remember to apply to both
bottom and sides.</a:documentation>
        <attribute name="name">
          <value>drag</value>
        </attribute>
        <ref name="input_choice_real"/>
        <choice>
          <element name="quadratic_drag">
            <a:documentation>Use a quadratic drag.

This means that the drag coefficient is nondimensional.</a:documentation>
            <optional>
              <element name="manning-strickler">
                <a:documentation>Use the Manning-Strickler formulation:
n^2*g*|u|*u/H^(1/3)
where n is the Manning coefficient, g is gravity, u is the velocity vector and H is the water heigth at that point.

The coefficient given above defines the Manning coefficient [s/m^(1/3)] (a typical value for sand is 0.02)</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
          <element name="linear_drag">
            <a:documentation>Use a linear drag (basically just a surface absorption term).

This means that the drag coefficient has units of momentum.</a:documentation>
            <empty/>
          </element>
        </choice>
      </element>
      <element name="type">
        <a:documentation>Apply wind forcing specified by stress or wind velocity.
Replaces windy.dat and windy.py</a:documentation>
        <attribute name="name">
          <value>wind_forcing</value>
        </attribute>
        <choice>
          <element name="wind_stress">
            <a:documentation>Wind forcing with user specified wind stress

&lt;b&gt; Note that the stress needs to be specified
using the same density units as the reference_density 
under equation of state.&lt;/b&gt;So if you use the recommended
non-dimensional value of 1.0 for reference_density and
your calculated stress is in kg m^-1s^-2 and the dimensional
reference_density is 1000.0 kg m^-3, you need to divide
the calculated stress in SI units by 1000.0.</a:documentation>
            <choice>
              <ref name="input_choice_real_dim_minus_one_vector"/>
              <element name="from_netcdf">
                <attribute name="file_name">
                  <a:documentation>The format of this file should conform to NetCDF CF 1.x
(http://cf-pcmdi.llnl.gov/).</a:documentation>
                  <data type="string"/>
                </attribute>
                <attribute name="east_west">
                  <data type="string"/>
                </attribute>
                <attribute name="north_south">
                  <data type="string"/>
                </attribute>
                <ref name="comment"/>
              </element>
            </choice>
          </element>
          <element name="wind_velocity">
            <a:documentation>Wind forcing with user specified 10m wind velocity</a:documentation>
            <element name="wind_drag_coefficient">
              <a:documentation>Specify wind drag coefficient (dimensionless)
Suggested value: 4.0e-4</a:documentation>
              <ref name="input_choice_real"/>
            </element>
            <element name="density_air">
              <a:documentation>Density of air. 

&lt;b&gt;Note that you have to specify
this density in the same units as the 
reference_density under equation of state.&lt;/b&gt;
So with a typicial value of rho_air=1.3 kgm^-3
and rho_water=1000 kgm^-3, if you fill in the 
recommended (non-dimensional) value of 1.0 for 
reference_density, this field needs to be 1.3e-3.</a:documentation>
              <ref name="real"/>
            </element>
            <element name="wind_velocity">
              <a:documentation>Specify wind velocity</a:documentation>
              <choice>
                <ref name="input_choice_real_dim_minus_one_vector"/>
                <element name="from_netcdf">
                  <attribute name="file_name">
                    <a:documentation>The format of this file should conform to NetCDF CF 1.x
(http://cf-pcmdi.llnl.gov/)</a:documentation>
                    <data type="string"/>
                  </attribute>
                  <attribute name="east_west">
                    <data type="string"/>
                  </attribute>
                  <attribute name="north_south">
                    <data type="string"/>
                  </attribute>
                  <ref name="comment"/>
                </element>
              </choice>
            </element>
          </element>
        </choice>
      </element>
      <element name="type">
        <a:documentation>When using control_volumes under Pressure
spatial_discretisation or when using
integrate_continuity_by_parts with continuous_galerkin
Pressure and continuous_galerkin Velocity this
boundary condition type imposes a weak no normal flow
boundary condition on the surface_ids specified.</a:documentation>
        <attribute name="name">
          <value>no_normal_flow</value>
        </attribute>
        <empty/>
      </element>
      <element name="type">
        <a:documentation>Implements a prescribed normal flow. Works for DG only. This
implements a weakly imposed bounadry condition normal to the surface.
Note: Positive points out of the domain, negative into the domain.</a:documentation>
        <attribute name="name">
          <value>prescribed_normal_flow</value>
        </attribute>
        <ref name="input_choice_real_bc_component"/>
      </element>
      <element name="type">
        <a:documentation>Flux boundary condition. 

Weakly enforces a flux across a boundary</a:documentation>
        <attribute name="name">
          <value>flux</value>
        </attribute>
        <element name="align_bc_with_cartesian">
          <optional>
            <element name="x_component">
              <ref name="input_choice_real_bc_component"/>
            </element>
          </optional>
          <optional>
            <element name="y_component">
              <ref name="input_choice_real_bc_component"/>
            </element>
          </optional>
          <optional>
            <element name="z_component">
              <ref name="input_choice_real_bc_component"/>
            </element>
          </optional>
        </element>
      </element>
    </choice>
  </define>
  <!-- Output options for prognostic fields -->
  <define name="prognostic_scalar_output_options">
    <element name="output">
      <a:documentation>Specify what is written to vtu dump files.</a:documentation>
      <optional>
        <element name="exclude_from_vtu">
          <a:documentation>Exclude this field from dump files.</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="include_previous_time_step">
          <a:documentation>Select this option to also write the values of this field
on the previous timestep.
(included under the name: Old&lt;field_name&gt; )</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="include_nonlinear_field">
          <a:documentation>Select this option to also write the values of this field
used in the nonlinear iteration.
(included under the name: Nonlinear&lt;field_name&gt; )</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="convergence_file">
          <a:documentation>Output a file details the convergence (or otherwise) of
this field with every advective nonlinear
iteration.
ONLY WORKS FOR PURE CONTROL VOLUME DISCRETISATIONS.</a:documentation>
          <ref name="comment"/>
        </element>
      </optional>
    </element>
  </define>
  <!-- Output options for pressure (can't have a convergence file) -->
  <define name="pressure_output_options">
    <element name="output">
      <a:documentation>Specify what is written to vtu dump files.</a:documentation>
      <optional>
        <element name="exclude_from_vtu">
          <a:documentation>Exclude this field from dump files.</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="include_previous_time_step">
          <a:documentation>Select this option to also write the values of this field
on the previous timestep.
(included under the name: Old&lt;field_name&gt; )</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="include_nonlinear_field">
          <a:documentation>Select this option to also write the values of this field
used in the nonlinear iteration.
(included under the name: Nonlinear&lt;field_name&gt; )</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="debugging_vtus">
          <a:documentation>Write out some extra debugging vtu files that can be used
to analyse what goes on in the pressure projection steps.
WARNING: this may create a huge amount of vtu files, as 
multiple files are written per nonlinear iteration.</a:documentation>
          <empty/>
        </element>
      </optional>
    </element>
  </define>
  <!-- Output options for prognostic fields -->
  <define name="prognostic_vector_output_options">
    <element name="output">
      <a:documentation>Specify what is written to dump files.</a:documentation>
      <optional>
        <element name="exclude_from_vtu">
          <a:documentation>Exclude this field from dump files.</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="include_previous_time_step">
          <a:documentation>Select this option to also write the values of this field
on the previous timestep.
(included under the name: Old&lt;field_name&gt; )</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="include_nonlinear_field">
          <a:documentation>Select this option to also write the values of this field
used in the nonlinear iteration.
(included under the name: Nonlinear&lt;field_name&gt; )</a:documentation>
          <empty/>
        </element>
      </optional>
    </element>
  </define>
  <!-- Field output options for all other fields -->
  <define name="field_output_options">
    <element name="output">
      <a:documentation>Specify what is written to dump files.</a:documentation>
      <optional>
        <element name="exclude_from_vtu">
          <a:documentation>Exclude this field from dump files.</a:documentation>
          <ref name="comment"/>
        </element>
      </optional>
      <optional>
        <element name="checkpoint">
          <a:documentation>Field will be checkpointed (this is not performed by default).</a:documentation>
          <empty/>
        </element>
      </optional>
    </element>
  </define>
  <define name="field_output_options_disabled">
    <element name="output">
      <a:documentation>Specify what is written to vtu dump files.</a:documentation>
      <choice>
        <element name="exclude_from_vtu">
          <a:documentation>Exclude this field from dump files.</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="include_in_vtu">
          <a:documentation>Include this field in dump files.</a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <define name="diagnostic_output_options">
    <ref name="field_output_options"/>
  </define>
  <define name="prescribed_output_options">
    <ref name="field_output_options"/>
  </define>
  <!--
    Options for inclusion/exclusion of standard field statistics from the .stat
    file
  -->
  <define name="include_stat">
    <element name="include_in_stat">
      <a:documentation>Include this field in the .stat file (magnitude and components)</a:documentation>
      <ref name="comment"/>
    </element>
  </define>
  <define name="exclude_components_from_stat">
    <element name="exclude_components_from_stat">
      <a:documentation>Include just the magnitude of this field in the .stat file
(excluding the components)</a:documentation>
      <ref name="comment"/>
    </element>
  </define>
  <define name="exclude_stat">
    <element name="exclude_from_stat">
      <a:documentation>Exclude this field from the .stat file.</a:documentation>
      <ref name="comment"/>
    </element>
  </define>
  <!-- Diagnostic statistics options for prognostic scalar fields -->
  <define name="prognostic_scalar_stat_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <ref name="prognostic_scalar_stat_options.stat"/>
    </element>
  </define>
  <!-- Diagnostic statistics for all other scalar fields -->
  <define name="prognostic_scalar_stat_no_old_or_nonlinear_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <ref name="prognostic_scalar_stat_no_old_or_nonlinear_options.stat"/>
    </element>
  </define>
  <define name="diagnostic_scalar_stat_options">
    <ref name="prognostic_scalar_stat_no_old_or_nonlinear_options"/>
  </define>
  <define name="prescribed_scalar_stat_options">
    <ref name="prognostic_scalar_stat_no_old_or_nonlinear_options"/>
  </define>
  <!-- Combining of stat elements for scalar fields -->
  <define name="prognostic_scalar_stat_options.stat">
    <ref name="prognostic_scalar_stat_no_old_or_nonlinear_options.stat"/>
  </define>
  <define name="prognostic_scalar_stat_options.stat" combine="interleave">
    <optional>
      <element name="include_previous_time_step">
        <a:documentation>Enable to include the previous timestep value of this field in the .stat file.</a:documentation>
        <ref name="comment"/>
      </element>
    </optional>
    <optional>
      <element name="include_nonlinear_field">
        <a:documentation>Enable to include the values of this field in the nonlinear
iteration in the .stat file.</a:documentation>
        <ref name="comment"/>
      </element>
    </optional>
  </define>
  <define name="prognostic_scalar_stat_no_old_or_nonlinear_options.stat">
    <optional>
      <ref name="exclude_stat"/>
    </optional>
    <optional>
      <ref name="cv_stats"/>
    </optional>
    <zeroOrMore>
      <ref name="surface_integral_stats_scalar"/>
    </zeroOrMore>
    <zeroOrMore>
      <ref name="mixing_stats"/>
    </zeroOrMore>
  </define>
  <!-- Diagnostic statistics options for vector fields, with enabled by default -->
  <define name="vector_field_stat_options_enabled_default">
    <ref name="include_stat"/>
  </define>
  <define name="vector_field_stat_options_enabled_default" combine="choice">
    <ref name="exclude_components_from_stat"/>
  </define>
  <define name="vector_field_stat_options_enabled_default" combine="choice">
    <ref name="exclude_stat"/>
  </define>
  <!-- Diagnostic statistics options for vector fields, with enabled by default -->
  <define name="vector_field_stat_options_disabled_default">
    <ref name="exclude_stat"/>
  </define>
  <define name="vector_field_stat_options_disabled_default" combine="choice">
    <ref name="exclude_components_from_stat"/>
  </define>
  <define name="vector_field_stat_options_disabled_default" combine="choice">
    <ref name="include_stat"/>
  </define>
  <!-- Diagnostic statistics options for tensor fields, with enabled by default -->
  <define name="tensor_field_stat_options_enabled_default">
    <ref name="include_stat"/>
  </define>
  <define name="tensor_field_stat_options_enabled_default" combine="choice">
    <ref name="exclude_components_from_stat"/>
  </define>
  <define name="tensor_field_stat_options_enabled_default" combine="choice">
    <ref name="exclude_stat"/>
  </define>
  <!-- Diagnostic statistics options for tensor fields, with enabled by default -->
  <define name="tensor_field_stat_options_disabled_default">
    <ref name="exclude_stat"/>
  </define>
  <define name="tensor_field_stat_options_disabled_default" combine="choice">
    <ref name="exclude_components_from_stat"/>
  </define>
  <define name="tensor_field_stat_options_disabled_default" combine="choice">
    <ref name="include_stat"/>
  </define>
  <!-- Diagnostic statistics for prognostic vector fields -->
  <define name="prognostic_velocity_stat_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <ref name="prognostic_velocity_stat_options.stat"/>
    </element>
  </define>
  <!-- Diagnostic statistics for all other vector fields -->
  <define name="prognostic_vector_stat_no_old_or_nonlinear_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <ref name="prognostic_vector_stat_no_old_or_nonlinear_options.stat"/>
    </element>
  </define>
  <define name="diagnostic_vector_stat_options">
    <ref name="prognostic_vector_stat_no_old_or_nonlinear_options"/>
  </define>
  <define name="prescribed_vector_stat_options">
    <ref name="prognostic_vector_stat_no_old_or_nonlinear_options"/>
  </define>
  <!-- Diagnostic statistics for tensor fields -->
  <define name="prognostic_tensor_stat_no_old_or_nonlinear_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <ref name="prognostic_tensor_stat_no_old_or_nonlinear_options.stat"/>
    </element>
  </define>
  <define name="diagnostic_tensor_stat_options">
    <ref name="prognostic_tensor_stat_no_old_or_nonlinear_options"/>
  </define>
  <define name="prescribed_tensor_stat_options">
    <ref name="prognostic_tensor_stat_no_old_or_nonlinear_options"/>
  </define>
  <!-- Combining of stat elements for vector fields -->
  <define name="prognostic_velocity_stat_options.stat">
    <ref name="prognostic_vector_stat_no_old_or_nonlinear_options.stat"/>
  </define>
  <define name="prognostic_velocity_stat_options.stat" combine="interleave">
    <element name="previous_time_step">
      <a:documentation>Specify how the previous timestep value of this field is added to the .stat file.</a:documentation>
      <ref name="vector_field_stat_options_disabled_default"/>
    </element>
    <element name="nonlinear_field">
      <a:documentation>Specify how the values of this field used in the nonlinear iteration are added to the .stat file.</a:documentation>
      <ref name="vector_field_stat_options_disabled_default"/>
    </element>
    <zeroOrMore>
      <element name="compute_body_forces_on_surfaces">
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <group>
          <element name="surface_ids">
            <a:documentation>What surface IDs do you want to do the calculation over?</a:documentation>
            <ref name="integer_vector"/>
          </element>
          <optional>
            <element name="output_terms">
              <a:documentation>Enable to output the pressure and viscous terms separately (as well
as the total force)</a:documentation>
              <ref name="comment"/>
            </element>
          </optional>
        </group>
      </element>
    </zeroOrMore>
    <optional>
      <element name="divergence_stats">
        <a:documentation>Compute the divergence of this field at the Gauss points
and return its stats.  This is a direct measure of the
divergence at the gauss points rather than a discrete measure
at the nodes (provided by several other diagnostic fields).</a:documentation>
        <empty/>
      </element>
    </optional>
    <optional>
      <element name="calculate_momentum_conservation_error">
        <a:documentation>Calculate the error in the conservation of momentum
IN PROGRESS - Does not include all terms!</a:documentation>
        <empty/>
      </element>
    </optional>
  </define>
  <define name="prognostic_vector_stat_no_old_or_nonlinear_options.stat">
    <ref name="vector_field_stat_options_enabled_default"/>
    <zeroOrMore>
      <ref name="surface_integral_stats_vector"/>
    </zeroOrMore>
  </define>
  <!-- Combining of stat elements for tensor fields -->
  <define name="prognostic_tensor_stat_no_old_or_nonlinear_options.stat">
    <ref name="tensor_field_stat_options_enabled_default"/>
  </define>
  <!-- Convergence options for prognostic scalar fields -->
  <define name="scalar_convergence_options">
    <element name="convergence">
      <a:documentation>Decide whether this field is tested for convergence
during nonlinear iterations
(if /timestepping/nonlinear_iterations and
/timestepping/nonlinear_iterations/tolerance are
enabled).
Also specifies whether the field is added to the 
convergence file (if /io/convergence_file is enabled).</a:documentation>
      <choice>
        <element name="include_in_convergence">
          <a:documentation>Include this field in convergence testing
(if /timestepping/nonlinear_iterations and
/timestepping/nonlinear_iterations/tolerance are
enabled) and file (if /io/convergence_file is enabled)</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_from_convergence">
          <a:documentation>Exclude this field from convergence testing and file </a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!-- Convergence statistics options for prognostic vector fields (velocity) -->
  <define name="vector_convergence_options">
    <element name="convergence">
      <a:documentation>Decide whether this field is tested for convergence
during nonlinear iterations
(if /timestepping/nonlinear_iterations and
/timestepping/nonlinear_iterations/tolerance are
enabled).
Also specifies whether the field is added to the 
convergence file (if /io/convergence_file is enabled).</a:documentation>
      <choice>
        <element name="include_in_convergence">
          <a:documentation>Include this field (magnitude and components)
in convergence testing
(if /timestepping/nonlinear_iterations and
/timestepping/nonlinear_iterations/tolerance are
enabled) and file (if /io/convergence_file is enabled)</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_components_from_convergence">
          <a:documentation>Include just the magnitude of this field 
in convergence testing
(if /timestepping/nonlinear_iterations and
/timestepping/nonlinear_iterations/tolerance are
enabled) and file (if /io/convergence_file is enabled)
i.e. excluding the components</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_from_convergence">
          <a:documentation>Exclude this field entirely from convergence testing and file </a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!-- Steady state options for prognostic scalar fields -->
  <define name="scalar_steady_state_options">
    <element name="steady_state">
      <a:documentation>Decide whether this field is tested for a steady state
between timesteps
(if /timestepping/steady_state is
enabled).</a:documentation>
      <choice>
        <element name="include_in_steady_state">
          <a:documentation>Include this field in steady state testing
(if /timestepping/steady_state is
enabled)</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_from_steady_state">
          <a:documentation>Exclude this field from steady state testing</a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!-- Steady state statistics options for prognostic vector fields (velocity) -->
  <define name="vector_steady_state_options">
    <element name="steady_state">
      <a:documentation>Decide whether this field is tested for a steady state
between timesteps
(if /timestepping/steady_state is
enabled).</a:documentation>
      <choice>
        <element name="include_in_steady_state">
          <a:documentation>Include this field (magnitude and components)
in steady state testing
(if /timestepping/steady_state is enabled)</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_components_from_steady_state">
          <a:documentation>Include just the magnitude of this field 
in steady state testing
(if /timestepping/steady_state is
enabled)
i.e. excluding the components</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_from_steady_state">
          <a:documentation>Exclude this field entirely from convergence testing and file </a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!-- Options for whether a field is to be included in detector output. -->
  <define name="detector_options_enabled_default">
    <element name="detectors">
      <a:documentation>Specify what is added to detector files</a:documentation>
      <choice>
        <element name="include_in_detectors">
          <a:documentation>This field is output at each detector location.</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_from_detectors">
          <a:documentation>This field is not output at detector locations.</a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!-- Options for whether a field is to be included in detector output. -->
  <define name="detector_options_disabled_default">
    <element name="detectors">
      <a:documentation>Specify what is added to detector files</a:documentation>
      <choice>
        <element name="exclude_from_detectors">
          <a:documentation>This field is not output at detector locations.</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="include_in_detectors">
          <a:documentation>This field is output at each detector location.</a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!--
    Detector output defaults on for prognostic and diagnostic fields, 
    off for prescribed.
  -->
  <define name="prognostic_detector_options">
    <ref name="detector_options_enabled_default"/>
  </define>
  <define name="diagnostic_detector_options">
    <ref name="detector_options_enabled_default"/>
  </define>
  <define name="prescribed_detector_options">
    <ref name="detector_options_disabled_default"/>
  </define>
  <define name="generic_aliased_field">
    <attribute name="material_phase_name">
      <data type="string"/>
    </attribute>
    <attribute name="field_name">
      <data type="string"/>
    </attribute>
  </define>
  <!-- This is the choice of additional scalar field to be solved for -->
  <define name="scalar_field_choice">
    <!--
      The first is a generic field, which may be used for any user-defined field
      that FLUIDITY knows nothing about, or a generic diagnostic
    -->
    <choice>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <choice>
          <a:documentation>Field type</a:documentation>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="diagnostic">
            <ref name="scalar_diagnostic_algorithms"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="___Prognostic_Fields_Below___">
        <a:documentation>Prognostic scalar fields below this</a:documentation>
        <empty/>
      </element>
      <!--
        This is the long list of fields that FLUIDITY knows about
        - - First is a list of fields that are primarily prognostic,
           but can be set to prescribed, or aliased...
        - - The list is in order of most frequently used.
      -->
      <element name="scalar_field">
        <a:documentation>Salinity</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Salinity</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Temperature</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Temperature</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Background Temperature</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>BackgroundTemperature</value>
        </attribute>
        <element name="prescribed">
          <ref name="velocity_mesh_choice"/>
          <ref name="prescribed_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Passive Tracer</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Tracer</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Free Surface
Use in combination with a free_surface boundary condition on velocity
Without the no_normal_stress option, this field should be diagnostic
and is optional. With the no_normal_stress option this field is required
and should be prognostic.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>FreeSurface</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <a:documentation>Free Surface elevation, to be used in combination with:

* a free_surface boundary condition applied to the Velocity
field, without the no_normal_stress_option.
It gives you a full dimensional field (constant over the vertical)
of the free surface elevation.

* equation type ShallowWater for Velocity. It simply divides 
Pressure by g, the gravitational constant.</a:documentation>
            <ref name="internal_algorithm"/>
            <ref name="pressure_mesh_choice">
              <a:documentation>Must be on the same mesh as Pressure</a:documentation>
            </ref>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="prognostic">
            <a:documentation>Free Surface
NOTE: the prognostic FreeSurface field only works in combination
with the free_surface boundary condition applied to the Velocity
field in combination with the no_normal_stress_option.
It gives you a full dimensional field (constant over the vertical)
of the free surface elevation. Initial and boundary conditions
for free surface should be set on this field.</a:documentation>
            <ref name="pressure_mesh_choice">
              <a:documentation>Must be on the same mesh as Pressure</a:documentation>
            </ref>
            <oneOrMore>
              <choice>
                <element name="initial_condition">
                  <a:documentation>Initial condition for WholeMesh

Only specify one condition if not using mesh regions.
Otherwise select other initial_condition option, specify region_ids
and distinct names.  Then add extra intial conditions for other regions.</a:documentation>
                  <attribute name="name">
                    <value>WholeMesh</value>
                  </attribute>
                  <ref name="input_choice_initial_condition_real"/>
                </element>
                <element name="initial_condition">
                  <a:documentation>Multiple initial_conditions are allowed if specifying
different values in different
regions of the mesh (defined by region_ids).  In this case
each initial_condition
requires a distinct name for the options dictionary.</a:documentation>
                  <attribute name="name">
                    <data type="string" datatypeLibrary=""/>
                  </attribute>
                  <optional>
                    <ref name="region_ids"/>
                  </optional>
                  <ref name="input_choice_initial_condition_real"/>
                </element>
              </choice>
            </oneOrMore>
            <element name="solver">
              <a:documentation>Solver - only necessary in combination with an explicit no_normal_stress free_surface bc under Velocity.</a:documentation>
              <ref name="linear_solver_options_sym"/>
            </element>
            <ref name="prognostic_scalar_output_options"/>
            <ref name="prognostic_scalar_stat_options"/>
            <ref name="scalar_convergence_options"/>
            <ref name="prognostic_detector_options"/>
            <ref name="scalar_steady_state_options"/>
            <ref name="adaptivity_options_prognostic_scalar_field"/>
            <ref name="interpolation_algorithm_scalar"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Wetting and drying alpha coefficient. Alpha is 1 in dry and 0 in wet regions.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>WettingDryingAlpha</value>
        </attribute>
        <element name="diagnostic">
          <a:documentation>Free Surface
NOTE: the diagnostic WettingDryingAlpha only works in combination
with the free_surface boundary condition applied to the Velocity
field. It gives you a 3D field (constant over the vertical)
of the wetting and drying alpha coefficient.</a:documentation>
          <ref name="internal_algorithm"/>
          <!--
            this is hard-coded on the PressureMesh as long as the Pressure is
            if this is no longer true, it should be option-checked to be on the
            same mesh as Pressure
          -->
          <ref name="pressure_mesh_choice">
            <a:documentation>Must be on the same mesh as Pressure</a:documentation>
          </ref>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Second Fluid</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>SecondFluid</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Diffuse Interface</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>DiffuseInterface</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>If enabled, decomposes Pressure by solving for the balanced part of 
Pressure using a "geopressure" solver:

  f = - grad p_gp + g

By choosing an appropriate mesh (typically velocity mesh order + 1)
for the balanced part of pressure, physical balance can be
represented to a higher degree of accuracy.

If buoyancy is included and HydrostaticPressure or
HydrostaticPressureGradient are enabled, the "geopressure" solver
is modified:

  f = - grad p_gp + g - grad p_hp</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>GeostrophicPressure</value>
        </attribute>
        <element name="prognostic">
          <element name="mesh">
            <a:documentation>The GeostrophicPressure mesh. Must be continuous.

&lt;b&gt;WARNING: It is usual for this to be a higher degree
mesh than the velocity mesh&lt;/b&gt;</a:documentation>
            <attribute name="name">
              <data type="string"/>
            </attribute>
            <ref name="comment"/>
          </element>
          <ref name="prognostic_geostrophic_pressure_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>If enabled, decomposes Pressure so that HydrostaticPressure balances against the density.
Solves:

grav_direction dot grad hp = grav*density

for hp.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HydrostaticPressure</value>
        </attribute>
        <element name="prognostic">
          <ref name="mesh_choice"/>
          <ref name="prognostic_hydrostatic_pressure_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>**UNDER TESTING**

If enabled, decomposes Pressure so that VerticalBalancePressure balances against the density.
Solves:

(grav_direction dot grad) (grav_direction dot grad) vbp = (grav_direction dot grad) grav*density

for vbp.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>VerticalBalancePressure</value>
        </attribute>
        <element name="prognostic">
          <ref name="mesh_choice">
            <a:documentation>This needs to be a continuous field!</a:documentation>
          </ref>
          <ref name="prognostic_vertical_balance_pressure_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>FoamVelocityPotential field:

Required in foam flow simulations where the foam velocity is not a
prescribed field. It solves Laplace's equation for a scalar potential, 
(the foam velocity is then obtained as the gradient of the potential).</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>FoamVelocityPotential</value>
        </attribute>
        <element name="prognostic">
          <ref name="velocity_mesh_choice"/>
          <ref name="prognostic_foam_velocity_potential_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>MaterialVolumeFraction field:

Volume fraction of this material.
Required in multimaterial simulations.
 - if prognostic solves for the volume fraction
 - if prescribed uses a specified volume fraction
 - if diagnostic solves for the final material volume fraction
Only 1 diagnostic MaterialVolumeFraction field allowed per
simulation or solves for all the volume fractions based on
the SumMaterialVolumeFractions field.

A diagnostic MaterialVolumeFraction field is currently required for
compressible multimaterial simulations (even if only 1 material).</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MaterialVolumeFraction</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
            <optional>
              <ref name="cap_option"/>
            </optional>
            <optional>
              <ref name="surface_tension_option"/>
            </optional>
          </element>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
            <optional>
              <ref name="cap_option"/>
            </optional>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
            <optional>
              <ref name="cap_option"/>
            </optional>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>MaterialDensity field:

Field for the density of this material.
Required in compressible multimaterial simulations.
Can be:
 - diagnostic if using a linear equation of state
 - prognostic if a compressible simulation
(note that if you set a multimaterial
equation of state and this field is
prognostic then its initial condition
will be overwritten by the density that
satisfies the initial pressure and
the equation of state)</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MaterialDensity</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>MaterialInternalEnergy field:

Field for the internal energy of this material.
Required in multimaterial compressible simulations
with full stiffened_gas (perfect gas) eos.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MaterialInternalEnergy</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>InternalEnergy field:

Field for the internal energy of a single material.
Required in compressible simulations
with full stiffened_gas (perfect gas) eos.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>InternalEnergy</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>SumMaterialVolumeFractions field:

Sums the prognostic MaterialVolumeFraction fields.
- diagnostic: sums all the volume fractions in the other
  material phases</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>SumMaterialVolumeFractions</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>CopiedField - This field copies the previous timesteps
values from another (specified) field at every iteration
and then solves the field using different (again, specified)
scheme and solution options.
For instance, this field can be used to create a diffused
field to adapt to.
Unless someone requests otherwise this is only currently possible
for fields within the same material_phase.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>CopiedField</value>
        </attribute>
        <element name="prognostic">
          <ref name="velocity_mesh_choice"/>
          <attribute name="copy_from_field">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <ref name="prognostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Calculate the stream function of 2D incompressible flow. Note 
that this *only* makes sense for proper 2D (not pseudo-2D) simulations.
Requires a continuous mesh.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>StreamFunction</value>
        </attribute>
        <element name="prognostic">
          <ref name="mesh_choice"/>
          <ref name="prognostic_stream_function_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>***UNDER TESTING***
Calculate the stream function of 2D incompressible flow for multiply connected domains.
Note that this *only* makes sense for proper 2D (not pseudo-2D) simulations.
Requires a continuous mesh.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MultiplyConnectedStreamFunction</value>
        </attribute>
        <attribute name="depends">
          <value>Velocity</value>
        </attribute>
        <element name="prognostic">
          <ref name="mesh_choice"/>
          <ref name="prognostic_multipath_stream_function_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Phytoplankton</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Phytoplankton</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Zooplankton</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Zooplankton</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Nutrient</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Nutrient</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Detritus</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Detritus</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Chlorophyll</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Chlorophyll</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Ammonium</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Ammonium</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>PhaseVolumeFraction
Required in porous_media and multiphase problem types</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>PhaseVolumeFraction</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
            <optional>
              <ref name="cap_option"/>
            </optional>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="internal_algorithm"/>
            <ref name="diagnostic_scalar_field_no_adapt"/>
            <optional>
              <ref name="cap_option"/>
            </optional>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Electrical Potential:
Required in electrokinetic, electrothermal
and electrochemical problems
(sub-option of porous_media problem type)</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ElectricalPotential</value>
        </attribute>
        <element name="prognostic">
          <ref name="velocity_mesh_choice"/>
          <ref name="prognostic_scalar_field"/>
        </element>
      </element>
      <!--
        Insert new prognostic scalar fields here using the template:
               element scalar_field {
                   attribute rank { "0" },
                   attribute name { "NewFieldName" },
                   (
                      element prognostic {
                         velocity_mesh_choice,
                         prognostic_scalar_field
                      }|
                      element prescribed {
                         velocity_mesh_choice,
                         prescribed_scalar_field
                      }|
                      element aliased {
                         generic_aliased_field
                      }
                   )
               }
      -->
      <!--
        - - Second is a list of fields that are primarily prescribed,
           but can be aliased. An example is wind velocity.
        - - The list is in order of most frequently used.
      -->
      <element name="___Prescribed_fields_below___">
        <a:documentation>Prescribed scalar fields below this</a:documentation>
        <empty/>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>DistanceToSideBoundaries</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>This is field should only be used with FEMDEM and adapt_at_first_timestep.
It is used for adapting the mesh at the first time step
and then it is removed from the state.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>FirstAdaptDummy</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>This field should only be used with foam simulations.
It is the local Plateau border length per unite volume.
lambda = 1.71/(bubble_radius)^2</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>DrainageLambda</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <!--
        
        Insert new prescribed scalar fields here using the template:
               element scalar_field {
                   attribute rank { "0" },
                   attribute name { "NewFieldName" },
                   (
                      element prescribed {
                         velocity_mesh_choice,
                         prescribed_scalar_field
                      }|
                      element aliased {
                         generic_aliased_field
                      }
                   )
               }
        
        - - Last is a list of fields that are primarily diagnostic,
           but can be aliased. An example is Tidal Range.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Diagnostic_Fields_Below___">
        <a:documentation>Diagnostic scalar fields below this</a:documentation>
        <empty/>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>PerturbationDensity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>ControlVolumeDivergence:

div field

Divergence of the velocity field where
the divergence operator is defined using
the control volume C^T matrix.
This assumes that the test space is discontinuous
control volumes.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ControlVolumeDivergence</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_cv_divergence_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>FiniteElementDivergence:

div field

Divergence of the velocity field where
the divergence operator is defined using
the finite element C^T matrix.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>FiniteElementDivergence</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="legacy_internal_algorithm"/>
            <attribute name="field_name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="velocity_mesh_choice"/>
            <optional>
              <element name="integrate_divergence_by_parts">
                <empty/>
              </element>
            </optional>
            <ref name="diagnostic_fe_divergence_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Diffusive dissipation

Only coded for 2D

  -g*drho/dy

where rho is the Density scalar field

BE AWARE OF WHAT THE DENSITY SCALAR FIELD IS

  Note the actual diffusive dissipation = -2*g*kappa*drho/dy so need
  to multiply by kappa in post-processing (2 subject to definition) where
  drho/dt + u.grad(rho) = kappa grad^2(rho)
  This assumes kappa is isotropic and constant
  For a linear equation of state kappa = diffusivity (thermal or haline)

c.f. Winters 1995, Journal of Fluid Mechanics</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>DiffusiveDissipation</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Richardson Number:

 Ri = \frac{N^2}{(\frac{\partial u}{\partial z})^2 + (\frac{\partial u}{\partial z})^2}
with 
 N^2 = -\frac{g}{\rho_0}\frac{\partial \rho}{\partial z}

Limitations:
 - Gravity must be constant.
 - Assumes gravity is in -ve final coordinate direction.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>RichardsonNumber</value>
        </attribute>
        <attribute name="depends">
          <value>Velocity,PerturbationDensity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_richardson_number_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>CFLNumber

See http://amcg.ese.ic.ac.uk/index.php?title=Local:Diagnostics#CFL_Number

Adapting to this field is not recommended</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>CFLNumber</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>ControlVolumeCFLNumber

Courant Number as defined on a control volume mesh

Adapting to this field is not recommended</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ControlVolumeCFLNumber</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>DG_CourantNumber

Courant Number as defined on a DG mesh

Adapting to this field is not recommended</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>DG_CourantNumber</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>InterstitialVelocityCGCourantNumber

Courant Number as defined on a CG mesh 
using the interstitial velocity for 
porous media flow.

Adapting to this field is not recommended</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>InterstitialVelocityCGCourantNumber</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="porosity_include_dg_and_cg_cfl"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>InterstitialVelocityCVCourantNumber

Courant Number as defined on a CV mesh 
using the interstitial velocity for 
porous media flow.

Adapting to this field is not recommended</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>InterstitialVelocityCVCourantNumber</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="porosity_include_cv_cfl"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>InterstitialVelocityDGCourantNumber

Courant Number as defined on a DG mesh 
using the interstitial velocity for 
porous media flow.

Adapting to this field is not recommended</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>InterstitialVelocityDGCourantNumber</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="porosity_include_dg_and_cg_cfl"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Buoyancy Adjustment diffusivity

The element-wise diffusion applied
in the buoyancy adjustment by vertical mixing
scheme available for tracer fields.

This is an element-wise P0 field, so it is best
calculated in a discontinuous function space.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>BuoyancyAdjustmentDiffusivity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>The equilibrium pressure perturbation 

Further details to be added
Currently a test field</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>EquilibriumPressure</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="pressure_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>The equilibrium pressure perturbation 

Further details to be added
Currently a test field</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>PressureRelativeToExternal</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="pressure_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Second invariant of the strain_rate tensor field. Selecting this field ensures
that it is updated as part of the momeuntum diagnostics (i.e. 
at the start of each momentum solve - within non-linear iterations.)</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>StrainRateSecondInvariant</value>
        </attribute>
        <element name="diagnostic">
          <ref name="strain_rate_second_invariant_algorithm"/>
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Discontinuity detector

takes value 1 where detector is triggered

Adapting to this field is not recommended</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>DiscontinuityDetector</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>CVMaterialDensityCFLNumber

Courant Number as defined on a control volume mesh and
incorporating the MaterialDensity.
Requires a MaterialDensity field!

Adapting to this field is not recommended</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>CVMaterialDensityCFLNumber</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>SolidConcentration</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>This scalar field is meant to replace DENTRAF.
Basically, if you use new options, DENTRAF is no longer needed
No repointing is done from this field to DENTRAF.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>CopyofDensity</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Add field to be used by Solid_configuration to 
Visualize the solids and MaterialVolumeFraction together</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>VisualizeSolidFluid</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Add field to be used by Solid_configuration to 
Visualize the solid_Concentration</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>VisualizeSolid</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Add field to be used by Solid_configuration to 
map  the solid_Concentration from particle mesh to 
the fluid mesh.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ParticleScalar</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Add field to be used by Explicit_ALE to 
visualize functional values before iterations start.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>FunctionalBegin</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Add field to be used by Explicit_ALE to 
visualize functional values at each iteration.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>FunctionalIter</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>add a MaterialVolume scalar_field to calculate the spatially varying 
volume of a material (requires a MaterialVolumeFraction)</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MaterialVolume</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>add a MaterialMass scalar_field to calculate the spatially varying 
mass of a material (requires a MaterialVolumeFraction and either a
MaterialDensity field or a reference_density in a linear eos)</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MaterialMass</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Calculates the material density based on the bulk Pressure
(and MaterialInternalEnergy if appropriate) for the equation
of state of this material.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MaterialEOSDensity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Calculates the MaterialPressure based on the MaterialDensity
(and MaterialInternalEnergy if appropriate) for the equation
of state of this material.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MaterialPressure</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Calculates the BulkMaterialPressure based on the MaterialDensity
and MaterialVolumeFraction (and MaterialInternalEnergy if appropriate) 
for the equation of state of all materials.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>BulkMaterialPressure</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Buoyancy adjustment (mixing by diffusion) coefficient</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>BuoyancyAdjustment</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Grid Reynolds number</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>GridReynoldsNumber</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <optional>
              <element name="include_density_field">
                <a:documentation>Include the density field in the Grid Reynolds number calculation.
A Density field must exist in the material_phase for this.
This assumes that the viscosity used is the dynamic viscosity.</a:documentation>
                <ref name="comment"/>
              </element>
            </optional>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>GridPecletNumber

Peclet Number Pe = U*dx/2*diffusivity

Also see the test case 'grid_peclet_number'
if you wish to see the effect of changing the 
diffusivity on a 1D, cg-discretised tracer-field

Adapting to this field is not recommended</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>GridPecletNumber</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="mesh_choice">
              <a:documentation>Mesh on which to calculate dx</a:documentation>
            </ref>
            <element name="field_name">
              <a:documentation>This is the name of the scalar field
to calculate the Peclet number for
Note this field needs to have a diffusivity</a:documentation>
              <data type="string" datatypeLibrary=""/>
            </element>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Horizontal velocity divergence:

div_H velocity

Uses the gravity field direction to determine the horizontal plane.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HorizontalVelocityDivergence</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Velocity divergence:

div velocity
</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>VelocityDivergence</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Kinetic energy density:

 1/2 rho*|u|^2

where rho is the Density scalar field

BE AWARE OF WHAT IS IN THE DENSITY SCALAR FIELD

In the Boussinesq approximation 
rho -&gt; rho_0 (reference density)
to get this use the square of the 
L2norm of the velocity field
from the stat file and multiply by
1/2*rho_0 in post-processing</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>KineticEnergyDensity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Gravitational potential energy density:

-rho*(g dot (r - r_0))

where rho is the Density scalar field
r_0 is the potential energy zero point
and g is the gravity vector

BE AWARE OF WHAT IS IN THE DENSITY SCALAR FIELD

Limitations:
 - Requires a constant gravity direction.
 - The Density and GravitationalPotentialEnergyDensity fields must be on the same mesh.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>GravitationalPotentialEnergyDensity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
            <element name="zero_point">
              <a:documentation>Coordinate of a point with a potential energy of zero.</a:documentation>
              <ref name="real_dim_vector"/>
            </element>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Isopycnal coordinate
Not parallelised

 z_star(x,t) = 1/A int_V' H(rho(x',t)-rho(x,t)) dV'

where rho is the Density scalar field, A is the width/area of the domain

BE AWARE OF WHAT IS IN THE DENSITY SCALAR FIELD

Limitations:
 - You need to specify a (fine) mesh to redistribute the Density onto
 - Requires a constant gravity direction.
 - The Density and GravitationalPotentialEnergyDensity fields must be on the same mesh.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>IsopycnalCoordinate</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <element name="fine_mesh">
              <a:documentation>This is the mesh onto which we redistribute the PerturbationDensity</a:documentation>
              <attribute name="name">
                <data type="string" datatypeLibrary=""/>
              </attribute>
            </element>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Background potential energy density:

  PE_b = rho*g*z_star

where rho is the Density scalar field and
z_star is the isopycnal coordinate. 


BE AWARE OF WHAT IS IN THE DENSITY SCALAR FIELD


Limitations:
 - Requires a constant gravity direction.
 - Requires a Density scalar field.
 - Requires the IsopycnalCoordinate diagnostic field.
 - The Density and GravitationalPotentialEnergyDensity
 fields must be on the same mesh.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>BackgroundPotentialEnergyDensity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Ertel potential vorticity:

 (f + curl u) dot grad rho'

Limitations:
 - Requires a geometry dimension of 3.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>PotentialVorticity</value>
        </attribute>
        <attribute name="depends">
          <value>Velocity,PerturbationDensity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Relative potential vorticity:

  curl u dot grad rho'</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>RelativePotentialVorticity</value>
        </attribute>
        <attribute name="depends">
          <value>Velocity,PerturbationDensity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Calculate the horizontal stream function psi where:
  \partial_x \psi = -v
  \partial_y \psi = u
where u and v are perpendicular to the gravity direction. Applies a
strong Dirichlet boundary condition of 0 on all boundaries.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HorizontalStreamFunction</value>
        </attribute>
        <attribute name="depends">
          <value>Velocity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <element name="solver">
              <a:documentation>Solver</a:documentation>
              <ref name="linear_solver_options_sym"/>
            </element>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Speed:

 |u|

Limitations:
 - The Speed and Velocity fields must be on the same mesh.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Speed</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Used in implicit_solids to determine the interface (i.e. boundary) between the fluid and solid.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>SolidPhase</value>
        </attribute>
        <attribute name="raplaces">
          <value>IDENT = -42</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Absolute Difference between two scalar fields.

Both fields must be in this material_phase.
Assumes both fields are on the same mesh as the AbsoluteDifference field.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>AbsoluteDifference</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name_a">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <attribute name="field_name_b">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
            <optional>
              <element name="relative_to_average">
                <a:documentation>Evaluate the absolute difference once the average difference has been removed?</a:documentation>
                <empty/>
              </element>
            </optional>
            <optional>
              <element name="ignore_boundaries">
                <a:documentation>Ignore boundary nodes (i.e. zero them when calculating the difference)</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Absolute Difference between two scalar fields.

Both fields must be in this material_phase.
Assumes both fields are on the same mesh as the AbsoluteDifference field.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ScalarAbsoluteDifference</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name_a">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <attribute name="field_name_b">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
            <optional>
              <element name="relative_to_average">
                <a:documentation>Evaluate the absolute difference once the average difference has been removed?</a:documentation>
                <empty/>
              </element>
            </optional>
            <optional>
              <element name="ignore_boundaries">
                <a:documentation>Ignore boundary nodes (i.e. zero them when calculating the difference)</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Galerkin projection of one field onto another mesh.

The field must be in this material_phase.

NOTE: you need the solver options if the mesh
of this field is continuous.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>GalerkinProjection</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="legacy_internal_algorithm"/>
            <element name="source_field_name">
              <data type="string" datatypeLibrary=""/>
            </element>
            <ref name="mesh_choice"/>
            <optional>
              <element name="lump_mass">
                <a:documentation>Lump the mass matrix of the galerkin projection
less accurate but faster and might give smoother result.                  </a:documentation>
                <empty/>
              </element>
            </optional>
            <optional>
              <element name="solver">
                <ref name="linear_solver_options_sym"/>
              </element>
            </optional>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Primary production of Phytoplankton. This is calculated by
the ocean biology module and will not be calculated unless
ocean biology is being simulated.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>PrimaryProduction</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Grazing of Phytoplankton by Zooplankton. This is calculated by
the ocean biology module and will not be calculated unless
ocean biology is being simulated.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>PhytoplanktonGrazing</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>TidalRange</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field_tidal_range"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>FreeSurfaceHistory</value>
        </attribute>
        <element name="diagnostic">
          <ref name="free_surface_history_algorithm"/>
          <ref name="velocity_mesh_choice"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Output the universal numbering of the mesh on which this field is based.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>UniversalNumber</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="legacy_internal_algorithm"/>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Output the processors which own the nodes of the mesh on which this field is based.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>NodeOwner</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="legacy_internal_algorithm"/>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>An estimate of the edge wieghts whilst adapting using Zoltan
Note: you *must* turn on inteprolation otherwise this field
will be emptied by an adapt.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MaxEdgeWeightOnNodes</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>SumVelocityDivergence

Diagnostic field used in multiphase simulations.
Sums up the divergence of each phase's apparent velocity, i.e. \sum{ div(vfrac*u) }</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>SumVelocityDivergence</value>
        </attribute>
        <element name="diagnostic">
          <ref name="velocity_mesh_choice"/>
          <ref name="internal_algorithm"/>
          <optional>
            <element name="integrate_divergence_by_parts">
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="test_with_cv_dual">
              <a:documentation>Test the divergence operator with the CV dual function space. 
This is useful if the pressure is solved with a CV discretisation 
or with a CG but with the continuity tested with the CV dual. </a:documentation>
              <ref name="comment"/>
            </element>
          </optional>
          <ref name="diagnostic_scalar_field_no_adapt"/>
          <element name="solver">
            <ref name="linear_solver_options_sym"/>
          </element>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>CompressibleContinuityResidual

Computes the residual of the continuity equation used in compressible multiphase flow simulations
i.e. vfrac_c*d(rho_c)/dt + div(rho_c*vfrac_c*u_c) + \sum_i{ rho_c*div(vfrac_i*u_i) }
where _c and _i denote the compressible and incompressible phases respectively.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>CompressibleContinuityResidual</value>
        </attribute>
        <element name="diagnostic">
          <ref name="velocity_mesh_choice"/>
          <ref name="internal_algorithm"/>
          <ref name="diagnostic_scalar_field_no_adapt"/>
          <element name="solver">
            <ref name="linear_solver_options_sym"/>
          </element>
        </element>
      </element>
    </choice>
    <!--
      Insert new diagnostic scalar fields here using the template:
             element scalar_field {
                 attribute rank { "0" },
                 attribute name { "NewFieldName" },
                 (
                    element diagnostic {
                       internal_algorithm,
                       velocity_mesh_choice,
                       diagnostic_scalar_field
                    }|
                    element aliased {
                       generic_aliased_field
                    }
                 )
             }
    -->
  </define>
  <!-- This is the choice of additional vector field to be solved for -->
  <define name="vector_field_choice">
    <!--
      The first is a generic field, which may be used for any user-defined field
      that FLUIDITY knows nothing about, or a generic diagnostic
      Prognostic vector fields are not possible (other than velocity and those known fields below).
    -->
    <choice>
      <element name="vector_field">
        <a:documentation>Generic field variable (vector)</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <choice>
          <a:documentation>Field type</a:documentation>
          <element name="prescribed">
            <ref name="mesh_choice"/>
            <ref name="prescribed_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
          <element name="diagnostic">
            <ref name="vector_diagnostic_algorithms"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
        </choice>
      </element>
      <!--
        
        - - List of fields that are primarily prognostic,
           but can be aliased.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Prognostic_fields_below___">
        <a:documentation>Prescribed vector fields below this</a:documentation>
        <empty/>
      </element>
      <element name="vector_field">
        <a:documentation>As HydrostaticPressure, but solves for the gradient of the pressure
associated with buoyancy. Requires a discontinuous mesh.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HydrostaticPressureGradient</value>
        </attribute>
        <element name="prognostic">
          <ref name="mesh_choice"/>
          <ref name="prognostic_hydrostatic_pressure_gradient_field"/>
        </element>
      </element>
      <!--
        
        - - List of fields that are primarily prescribed,
           but can be aliased.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Prescribed_fields_below___">
        <a:documentation>Prescribed vector fields below this</a:documentation>
        <empty/>
      </element>
      <element name="vector_field">
        <a:documentation>MaterialVelocity field.  Used to impose a velocity on a material
in combination with the imposed_material_velocity_absorption_algorithm
for VelocityAbsorption and imposed_material_velocity_source_algorithm 
for VelocitySource.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>MaterialVelocity</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="mesh_choice"/>
            <ref name="prescribed_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <!--
        
        Insert new prescribed vector fields here using the template:
               element vector_field {
                   attribute rank { "1" },
                   attribute name { "NewFieldName" },
                   (
                      element prescribed {
                         mesh_choice,
                         prescribed_vector_field
                      }|
                      element aliased {
                         generic_aliased_field
                      }
                   )
               }
        
        - - Last is a list of fields that are primarily diagnostic,
           but can be aliased. An example is Tidal Range.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Diagnostic_Fields_Below___">
        <a:documentation>Diagnostic vector fields below this</a:documentation>
        <empty/>
      </element>
      <element name="vector_field">
        <a:documentation>Gradient of a scalar field evaluated using the C gradient
matrix constructed using finite elements.
Field must be in this material_phase.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>FiniteElementGradient</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="mesh_choice"/>
            <optional>
              <element name="integrate_gradient_by_parts">
                <empty/>
              </element>
            </optional>
            <ref name="diagnostic_gradient_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Gradient of a scalar field evaluated using the transpose
of the C^T divergence matrix constructed using finite
elements.
Field must be in this material_phase.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>FiniteElementDivergenceTransposed</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="legacy_internal_algorithm"/>
            <attribute name="field_name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="mesh_choice"/>
            <optional>
              <element name="integrate_divergence_by_parts">
                <empty/>
              </element>
            </optional>
            <ref name="diagnostic_gradient_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Foam Velocity field. 
Required for simulations of foam flow and liquid drainage in foams. 
If diagnostic, a FoamVelocityPotential field is required, 
and the Foam Velocity is obtained by taking its gradient.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>FoamVelocity</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_vector_field_no_adapt"/>
          </element>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="mesh_choice"/>
            <element name="solver">
              <ref name="linear_solver_options_sym"/>
            </element>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Foam Liquid Content times Velocity field.
Its surface integral gives the liquid 
volumetric flow in the flowing foam </a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>FoamLiquidContentVelocity</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_vector_field"/>
        </element>
      </element>
      <element name="vector_field">
        <a:documentation>Relative vorticity field - curl of the velocity field</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>Vorticity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="vorticity_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Planetary vorticity

Limitations:
 - Requires geometry dimension of 3.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>PlanetaryVorticity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Absolute vorticity:

  f + curl u

Limitations:
 - Requires a geometry dimension of 3.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>AbsoluteVorticity</value>
        </attribute>
        <attribute name="depends">
          <value>Velocity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Gradient of a scalar field evaluated using the transpose
of the C^T matrix constructed using control volumes.
Field must be in this material_phase.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>ControlVolumeDivergenceTransposed</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_cv_gradient_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Solid Velocity field.  Used to generate the momentum source </a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>SolidVelocity</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="mesh_choice"/>
          <ref name="diagnostic_vector_field"/>
        </element>
      </element>
      <element name="vector_field">
        <a:documentation>Same as Solid Velocity field but it is on the Particle mesh.
It is used to map the velocities coming from an external program like
FEMDEM or DEM to the fluid mesh. </a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>ParticleVector</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="mesh_choice"/>
          <ref name="diagnostic_vector_field"/>
        </element>
      </element>
      <element name="vector_field">
        <a:documentation>Same as Solid Velocity field but it is on the Particle mesh.
It is used to map the velocities coming from an external program like
FEMDEM or DEM to the fluid mesh. </a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>ParticleForce</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="mesh_choice"/>
          <ref name="diagnostic_vector_field"/>
        </element>
      </element>
      <element name="vector_field">
        <a:documentation>Same as Solid Velocity field but it is on the Particle mesh.
It is used to map the velocities coming from an external program like
FEMDEM or DEM to the fluid mesh. </a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>SolidForce</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_vector_field"/>
        </element>
      </element>
      <element name="vector_field">
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>VelocityPlotForSolids</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_vector_field"/>
        </element>
      </element>
      <element name="vector_field">
        <a:documentation>Same as Solid Velocity field but it is on the Particle mesh.
It is used to map the velocities coming from an external program like
FEMDEM or DEM to the fluid mesh. </a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>FunctionalGradient</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_vector_field"/>
        </element>
      </element>
      <element name="vector_field">
        <a:documentation>LinearMomentum field.
 p = \rho*u 
(where p is the linear momentum, \rho the density and u the velocity)</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>LinearMomentum</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Absolute Difference between two vector fields.

Both fields must be in this material_phase.
Assumes both fields are on the same mesh as the AbsoluteDifference field.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>AbsoluteDifference</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name_a">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <attribute name="field_name_b">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
            <optional>
              <element name="relative_to_average">
                <a:documentation>Evaluate the absolute difference once the average difference has been removed?</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Absolute Difference between two vector fields.

Both fields must be in this material_phase.
Assumes both fields are on the same mesh as the AbsoluteDifference field.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>VectorAbsoluteDifference</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name_a">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <attribute name="field_name_b">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
            <optional>
              <element name="relative_to_average">
                <a:documentation>Evaluate the absolute difference once the average difference has been removed?</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Bed Shear Stress

This diagnostic vector field is only calculated over surface elements/nodes, 
interior nodes will have zero value.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>BedShearStress</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_vector_field_bed_shear_stress"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_vector_field_no_adapt"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Max Bed Shear Stress.

Note that you need BedShearStress turned on for this to work.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>MaxBedShearStress</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <group>
              <ref name="internal_algorithm"/>
              <ref name="velocity_mesh_choice"/>
            </group>
            <!-- diagnostic_vector_field_max_bed_shear_stress -->
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
        <element name="spin_up_time">
          <a:documentation>This is the time after which the max operator is
applied to the bed shear stress.</a:documentation>
          <ref name="real"/>
        </element>
      </element>
      <element name="vector_field">
        <a:documentation>Coordinate field remapped to the mesh of your choice.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>DiagnosticCoordinate</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Galerkin projection of one field onto another mesh.

The field must be in this material_phase.

NOTE: you need the solver options if the mesh
of this field is continuous.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>GalerkinProjection</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="legacy_internal_algorithm"/>
            <element name="source_field_name">
              <data type="string" datatypeLibrary=""/>
            </element>
            <ref name="mesh_choice"/>
            <optional>
              <element name="lump_mass">
                <a:documentation>Lump the mass matrix of the galerkin projection
less accurate but faster and might give smoother result.                  </a:documentation>
                <empty/>
              </element>
            </optional>
            <optional>
              <element name="solver">
                <ref name="linear_solver_options_sym"/>
              </element>
            </optional>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Computes the buoyancy term</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>Buoyancy</value>
        </attribute>
        <element name="diagnostic">
          <ref name="buoyancy_algorithm"/>
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_vector_field"/>
        </element>
      </element>
      <element name="vector_field">
        <a:documentation>Projects the Coriolis term onto the mesh of this diagnostic field.
Note that multiple projection methods are available (under the
algorithm option).</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>Coriolis</value>
        </attribute>
        <element name="diagnostic">
          <ref name="coriolis_algorithm"/>
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_vector_field"/>
        </element>
      </element>
    </choice>
    <!--
      Insert new diagnostic vector field here using the template:
             element vector_field {
                 attribute rank { "1" },
                 attribute name { "NewFieldName" },
                 (
                    element diagnostic {
                       internal_algorithm,
                       mesh_choice,
                       diagnostic_vector_field
                    }|
                    element aliased {
                       generic_aliased_field
                    }
                 )
             }
    -->
  </define>
  <!-- This is the choice of additional tensor fields -->
  <define name="tensor_field_choice">
    <!--
      The first is a generic field, which may be used for any user-defined field
      that FLUIDITY knows nothing about, or a generic diagnostic
      Prognostic tensor fields are not possible.
    -->
    <choice>
      <element name="tensor_field">
        <a:documentation>Generic field variable (tensor)</a:documentation>
        <attribute name="rank">
          <value>2</value>
        </attribute>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <choice>
          <a:documentation>Field type</a:documentation>
          <element name="prescribed">
            <ref name="mesh_choice"/>
            <ref name="prescribed_tensor_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
          <element name="diagnostic">
            <ref name="tensor_diagnostic_algorithms"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_tensor_field"/>
          </element>
        </choice>
      </element>
      <!--
        
        - - Second is a list of tensor fields that are primarily prescribed,
           but can be aliased.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Prescribed_fields_below___">
        <a:documentation>Prescribed scalar fields below this</a:documentation>
        <empty/>
      </element>
      <element name="tensor_field">
        <a:documentation>MaterialViscosity field:

Field for the viscosity of this material.
Required if using a diagnostic bulk viscosity
in a multimaterial simulation.</a:documentation>
        <attribute name="rank">
          <value>2</value>
        </attribute>
        <attribute name="name">
          <value>MaterialViscosity</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="mesh_choice"/>
            <ref name="prescribed_tensor_field"/>
          </element>
          <element name="diagnostic">
            <ref name="mesh_choice"/>
            <ref name="tensor_python_diagnostic_algorithm"/>
            <ref name="diagnostic_tensor_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <!--
        
        Insert new prescribed tensor fields here using the template:
               element tensor_field {
                   attribute rank { "2" },
                   attribute name { "NewFieldName" },
                   (
                      element prescribed {
                         mesh_choice,
                         prescribed_tensor_field
                      }|
                      element aliased {
                         generic_aliased_field
                      }
                   )
               }|
        
        - - Last is a list of fields that are primarily diagnostic,
           but can be aliased.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Diagnostic_Fields_Below___">
        <a:documentation>Diagnostic tensor fields below this</a:documentation>
        <empty/>
      </element>
    </choice>
    <!--
      Insert new diagnostic tensor field here using the template:
             element tensor_field {
                 attribute name { "NewFieldName" },
                 (
                    element diagnostic {
                       internal_algorithm,
                       mesh_choice,
                       diagnostic_tensor_field
                    }|
                    element aliased {
                       generic_aliased_field
                    }
                 )
             }
    -->
  </define>
  <!--
    Select the type of dynamic control to be used
    Note: DEM and FEMDEM require the respective libraries
    to be compiled.
  -->
  <define name="input_solid_dynamics_choice">
    <choice>
      <element name="dynamic_type">
        <a:documentation>Obtain values from point and radius file.

First line of file is free to use (for comments)
Second line must contain the number of particles
Third and fourth line are again for comments. 
Following lines include 10 columns, corresponding to 
the particle's x, y, and z positions, followed by the radius, then
velocities in x, y, and z directions, followed by angular velocities
in the x, y, and z directions.</a:documentation>
        <attribute name="name">
          <value>from_input_file</value>
        </attribute>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
      </element>
      <element name="dynamic_type">
        <a:documentation>Two python scripts must be provided. The script is cycled over each particle.
One script for particle position (output is tuple of position coords)
Second script is for particle radius (output is tuple of position coords)
Third script is for particle translational velocity.
Fourth script is for particle angular velocity. (Note: particles 
have a no slip boundary condition at the surface, so this angular velocity
WILL matter to the flow.)
Python functions should be of the form:
 def val(X, t):
   Function code
   return # Return value
where X is a tuple of length geometry dimension.
   X[0] contains the number of the particle (in real format)</a:documentation>
        <attribute name="name">
          <value>python_script</value>
        </attribute>
      </element>
      <element name="dynamic_type">
        <attribute name="name">
          <value>use_simple_dynamics</value>
        </attribute>
        <element name="set_bottom">
          <ref name="real"/>
        </element>
        <element name="set_xmin">
          <ref name="real"/>
        </element>
        <element name="set_ymin">
          <ref name="real"/>
        </element>
        <element name="set_zmin">
          <ref name="real"/>
        </element>
        <element name="set_xmax">
          <ref name="real"/>
        </element>
        <element name="set_ymax">
          <ref name="real"/>
        </element>
        <element name="set_zmax">
          <ref name="real"/>
        </element>
      </element>
      <element name="dynamic_type">
        <a:documentation>Using y3D to model dynamics. Filename of input file for y3D must
be specified.</a:documentation>
        <attribute name="name">
          <value>use_y3D</value>
        </attribute>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
      </element>
      <element name="dynamic_type">
        <a:documentation>Using femdem 2D to model dynamics. Filename of input file must
be specified.</a:documentation>
        <attribute name="name">
          <value>use_2Dfemdem</value>
        </attribute>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
      </element>
      <element name="dynamic_type">
        <a:documentation>Using femdem 3D to model dynamics. Filename of input file must
be specified.</a:documentation>
        <attribute name="name">
          <value>use_3Dfemdem</value>
        </attribute>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
        <element name="quad2lin">
          <attribute name="file_name">
            <data type="string"/>
          </attribute>
        </element>
      </element>
    </choice>
  </define>
  <define name="cap_option">
    <element name="cap_values">
      <a:documentation>Cap the min and max values of this field when using
it as a volume fraction to work out bulk material
properties.
No capping used if not selected.</a:documentation>
      <optional>
        <element name="upper_cap">
          <a:documentation>Set the upper bound on the field.
Defaults to huge(0.0)*epsilon(0.0) if not set.</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
      <optional>
        <element name="lower_cap">
          <a:documentation>Set the lower bound on the field.
Defaults to -huge(0.0)*epsilon(0.0) if not set.</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="surface_tension_option">
    <element name="surface_tension">
      <element name="surface_tension_coefficient">
        <a:documentation>Surface tension coefficient</a:documentation>
        <ref name="real"/>
      </element>
      <optional>
        <element name="equilibrium_contact_angle">
          <a:documentation>The equilibrium contact angle (in radians) with the boundaries identified by the surface ids</a:documentation>
          <ref name="real"/>
          <element name="surface_ids">
            <a:documentation>Surface ids:</a:documentation>
            <ref name="integer_vector"/>
          </element>
        </element>
      </optional>
    </element>
  </define>
  <define name="limiter_options">
    <choice>
      <element name="limit_face_value">
        <a:documentation>Limit the face value to satisfy a boundedness criterion.</a:documentation>
        <choice>
          <ref name="sweby_limiter"/>
          <ref name="ultimate_limiter"/>
        </choice>
      </element>
      <element name="do_not_limit_face_value">
        <a:documentation>Do not limit the face value</a:documentation>
        <empty/>
      </element>
    </choice>
  </define>
  <!--
    cv limiter options that 
    have NO reliance on any CFL field. 
  -->
  <define name="limiter_options_excluding_cfl">
    <choice>
      <element name="limit_face_value">
        <a:documentation>Limit the face value to satisfy a boundedness criterion.</a:documentation>
        <ref name="sweby_limiter"/>
      </element>
      <element name="do_not_limit_face_value">
        <a:documentation>Do not limit the face value</a:documentation>
        <empty/>
      </element>
    </choice>
  </define>
  <define name="sweby_limiter">
    <element name="limiter">
      <a:documentation>See "High-Resolution Schemes Using Flux Limiters for
Hyperbolic Conservation-Laws", P. K. Sweby, 1984, Siam
Journal on Numerical Analysis, 21, 995-1011</a:documentation>
      <attribute name="name">
        <value>Sweby</value>
      </attribute>
      <optional>
        <ref name="slope_options"/>
      </optional>
      <optional>
        <ref name="upwind_value_options"/>
      </optional>
    </element>
  </define>
  <define name="ultimate_limiter">
    <element name="limiter">
      <a:documentation>See "The Ultimate Conservative Difference Scheme Applied
to Unsteady One-Dimensional Advection", B. P. Leonard,
1991, Computer Methods in Applied Mechanics and
Engineering, 88, 17-74</a:documentation>
      <attribute name="name">
        <value>Ultimate</value>
      </attribute>
      <ref name="field_based_cfl_number_options"/>
      <optional>
        <ref name="upwind_value_options"/>
      </optional>
    </element>
  </define>
  <define name="slope_options">
    <element name="slopes">
      <a:documentation>Control the upper and lower slopes of the NVD limiter</a:documentation>
      <optional>
        <element name="lower">
          <a:documentation>Defaults to Sweby, 1984 limiter (= 1.0) if unselected</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
      <optional>
        <element name="upper">
          <a:documentation>Defaults to Sweby, 1984 limiter (= 2.0) if unselected</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="upwind_value_options">
    <choice>
      <element name="project_upwind_value_from_point">
        <a:documentation>Select the method to be used for calculating the upwind value.
If not selected will default to project_upwind_value_from_point for
simplex element meshes and to a locally_bound_upwind_value for cube
element meshes.

This method projects the upwind value from a point in the element just
upwind of the node pair straddling the face.  It is otherwise known as 
anisotropic limiting.
This is only available on simplex meshes as it involes a search around
the donor node to find the upwind element.</a:documentation>
        <optional>
          <element name="reflect_off_domain_boundaries">
            <a:documentation>When the donor node is on a domain boundary reflect the projection
back into the mesh.</a:documentation>
            <empty/>
          </element>
        </optional>
        <optional>
          <element name="bound_projected_value_locally">
            <a:documentation>Constrain the projected value to be between the min and max of the
element values which it was found from.</a:documentation>
            <empty/>
          </element>
        </optional>
        <optional>
          <element name="store_upwind_elements">
            <a:documentation>Store the locations of the elements where the upwind values
are projected from for each node pair.
This inserts an integer csr matrix into state so is memory expensive but
saves a significant amount of time (searching around the neighbouring elements).
This is unsafe for moving meshes but should be ok for adaptive meshes.</a:documentation>
            <optional>
              <element name="store_upwind_quadrature">
                <a:documentation>Store the quadrature locations within the elements
where the upwind values
are projected from for each node pair.
This inserts a real block csr matrix into state so is even more memory
expensive than just storing the upwind elements and
only saves a comparitively
marginal amount of time (as actually searching the
neighbouring elements is the
slowest bit, finding the quadrature is relatively easy).</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
        </optional>
      </element>
      <element name="project_upwind_value_from_gradient">
        <a:documentation>Select the method to be used for calculating the upwind value.
If not selected will default to project_upwind_value_from_point for
simplex element meshes and to a locally_bound_upwind_value for cube
element meshes.

Projects the value of the advected variable from the downwind or donor node
using the interpolated gradient at the donor node in the
direction of the vector
connecting the node pair straddling the face.
This is available on all meshes (except if bounding the values).</a:documentation>
        <choice>
          <element name="project_from_downwind_value">
            <a:documentation>Select which node to project from:
Project from the downwind node (Jasak et al., 1999) so that:
upwind_value = downwind_value - 2*gradient.vector</a:documentation>
            <ref name="comment"/>
          </element>
          <element name="project_from_donor_value">
            <a:documentation>Select which node to project from:
Project from the donor node so that:
upwind_value = donor_value - gradient.vector</a:documentation>
            <ref name="comment"/>
          </element>
        </choice>
        <optional>
          <element name="reflect_off_domain_boundaries">
            <a:documentation>When the donor node is on a domain boundary reflect the projection
back into the mesh.</a:documentation>
            <empty/>
          </element>
        </optional>
        <optional>
          <element name="bound_projected_value_locally">
            <a:documentation>Constrain the projected value to be between the min and max of the
element values which surround it.
This is only available on simplex meshes as it involes a search around
the donor node to find the upwind element.</a:documentation>
            <optional>
              <element name="store_upwind_elements">
                <a:documentation>Store the locations of the elements closest to the project value.
This inserts an integer csr matrix into state so is
memory expensive but
saves a significant amount of time (searching around
the neighbouring elements).
This is unsafe for moving meshes but should be ok for adaptive meshes.</a:documentation>
                <ref name="comment"/>
              </element>
            </optional>
          </element>
        </optional>
      </element>
      <element name="locally_bound_upwind_value">
        <a:documentation>Select the method to be used for calculating the upwind value.
If not selected will default to project_upwind_value_from_point for
simplex element meshes and to a locally_bound_upwind_value for cube
element meshes.

Chooses an upwind value by selecting the maximum or minimum of the neighbouring
nodes depending on the local slope of the donor and downwind values.
Otherwise known as isotropic limiting.
This is available on all meshes except periodic domains.</a:documentation>
        <empty/>
      </element>
      <element name="pseudo_structured_upwind_value">
        <a:documentation>Select the method to be used for calculating the upwind value.
If not selected will default to project_upwind_value_from_point for
simplex element meshes and to a locally_bound_upwind_value for cube
element meshes.

Chooses an upwind value by selecting the value at the node most directy
upwind from the vector connecting the donor and downwind nodes.
This is available on all meshes.</a:documentation>
        <empty/>
      </element>
    </choice>
  </define>
  <define name="field_based_cfl_number_options">
    <choice>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used.

This uses the control volume definition of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>ControlVolumeCFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>***UNDER TESTING***

Select the Courant Number definition to be used.

This uses the control volume definition of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>CVMaterialDensityCFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used.

This uses the finite element approximation of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>CFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used.

This uses the control volume approximation of the CFL Number 
and the interstitial velocity for porous media flow.</a:documentation>
        <attribute name="name">
          <value>InterstitialVelocityCVCourantNumber</value>
        </attribute>
        <ref name="porosity_include_cv_cfl"/>
      </element>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used.

This uses the CG finite element approximation of the CFL Number 
and the interstitial velocity for porous media flow.</a:documentation>
        <attribute name="name">
          <value>InterstitialVelocityCGCourantNumber</value>
        </attribute>
        <ref name="porosity_include_cv_cfl"/>
      </element>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used.</a:documentation>
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
        <empty/>
      </element>
    </choice>
  </define>
  <define name="dg_field_based_cfl_number_options">
    <optional>
      <choice>
        <element name="courant_number">
          <a:documentation>IF NOT SELECTED THEN THE DEFAULT DG_CourantNumber IS USED.

Select the Courant Number definition to be used.

This uses the DG finite element approximation of the CFL Number.</a:documentation>
          <attribute name="name">
            <value>DG_CourantNumber</value>
          </attribute>
          <empty/>
        </element>
        <element name="courant_number">
          <a:documentation>IF NOT SELECTED THEN THE DEFAULT DG_CourantNumber IS USED.

Select the Courant Number definition to be used.

This uses the DG finite element approximation of the CFL Number 
and the interstitial velocity for porous media flow.</a:documentation>
          <attribute name="name">
            <value>InterstitialVelocityDGCourantNumber</value>
          </attribute>
          <ref name="porosity_include_cv_cfl"/>
        </element>
        <element name="courant_number">
          <a:documentation>IF NOT SELECTED THEN THE DEFAULT DG_CourantNumber IS USED.

Select the Courant Number definition to be used.</a:documentation>
          <attribute name="name">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <empty/>
        </element>
      </choice>
    </optional>
  </define>
  <define name="cv_face_cfl_number_options">
    <choice>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used in the slope of
the NVD diagram upper bound.
This uses the control volume definition of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>ControlVolumeCFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>***UNDER TESTING***

Select the Courant Number definition to be used in the slope of
the NVD diagram upper bound.
This uses a control volume definition of the CFL Number
that incorporates the MaterialDensity.
Requires a MaterialDensity field in this material_phase!</a:documentation>
        <attribute name="name">
          <value>CVMaterialDensityCFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>***UNDER TESTING***

Select the Courant Number definition to be used in the slope of
the NVD diagram upper bound.
This uses the finite element approximation of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>CFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used in the slope of
the NVD diagram upper bound.
This uses a control volume definition of the CFL Number
and the interstitial velocity for porous media flow.</a:documentation>
        <attribute name="name">
          <value>InterstitialVelocityCVCourantNumber</value>
        </attribute>
        <ref name="porosity_include_cv_cfl"/>
      </element>
      <element name="courant_number">
        <a:documentation>***UNDER TESTING***

Select the Courant Number definition to be used in the slope of
the NVD diagram upper bound.</a:documentation>
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
        <empty/>
      </element>
    </choice>
  </define>
  <define name="timestep_cfl_number_options">
    <choice>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used for adaptive timestepping.
This uses the finite element approximation of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>CFLNumber</value>
        </attribute>
        <ref name="velocity_mesh_choice">
          <a:documentation>Select the mesh on which you wish to evaluate the CFLNumber.</a:documentation>
        </ref>
      </element>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used for adaptive timestepping.
This uses the control volume definition of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>ControlVolumeCFLNumber</value>
        </attribute>
        <ref name="velocity_mesh_choice">
          <a:documentation>Select the mesh on which you wish to evaluate the ControlVolumeCFLNumber.</a:documentation>
        </ref>
      </element>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used for adaptive timestepping.
This uses the CG finite element approximation of the CFL Number 
and the interstitial velocity for porous media flow.</a:documentation>
        <attribute name="name">
          <value>InterstitialVelocityCGCourantNumber</value>
        </attribute>
        <ref name="velocity_mesh_choice"/>
        <ref name="porosity_include_dg_and_cg_cfl"/>
      </element>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used for adaptive timestepping.
This uses the control volume approximation of the CFL Number 
and the interstitial velocity for porous media flow.         </a:documentation>
        <attribute name="name">
          <value>InterstitialVelocityCVCourantNumber</value>
        </attribute>
        <ref name="velocity_mesh_choice"/>
        <ref name="porosity_include_cv_cfl"/>
      </element>
    </choice>
  </define>
  <define name="mixing_stats">
    <element name="include_mixing_stats">
      <a:documentation>Enable to include in the .stat file the fractions of the
scalar field contained in
bins specified by the user. This allows mixing of the field to be quantified.
Replaces and expands upon the old heaviside.dat file</a:documentation>
      <attribute name="name">
        <data type="string"/>
      </attribute>
      <choice>
        <element name="continuous_galerkin">
          <a:documentation>Select whether to evaluate the volume fraction over the finite element
(continuous galerkin) or within the control volume (control_volumes).

NOTE: continuous_galerkin only works with linear tets

NOTE: continuous_galerkin is not fully validated yet</a:documentation>
          <optional>
            <element name="normalise">
              <a:documentation>if select normalise the volume fractions will be
divided by the total volume of the domain</a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
        <element name="control_volumes">
          <a:documentation>Select whether to evaluate the volume fraction over the finite element
(continuous galerkin) or within the control volume (control_volumes).</a:documentation>
          <optional>
            <element name="normalise">
              <a:documentation>if select normalise the volume fractions will be divided by the total volume of the domain  </a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
      </choice>
      <element name="mixing_bin_bounds">
        <a:documentation>The values of the bounds of the bins 
e.g. the values -1.5 0.0 1.5 2.0 will return 4 bins 
and the fraction of the field in each bin with,
-1.5&lt;=field&lt;0.0, 0.0&lt;=field&lt;1.5, 1.5&lt;=field&lt;2.0, 2.0&lt;=field, 
will be calculated.  </a:documentation>
        <choice>
          <element name="constant">
            <a:documentation>list of bin bounds</a:documentation>
            <ref name="real_vector"/>
          </element>
          <element name="python">
            <a:documentation>Python function prescribing bin bounds. Functions should be of the form:

 def val(t):
    # Function code
    return # Return value that should be an array of reals

</a:documentation>
            <ref name="python_code"/>
          </element>
        </choice>
      </element>
      <optional>
        <element name="tolerance">
          <a:documentation>Define the tolerance beneath the specified bins that should be included.
Defaults to zero at machine tolerance (epsilon(0.0)) if not selected.</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="cv_stats">
    <element name="include_cv_stats">
      <a:documentation>Include statistics evaluated on the control volume mesh.</a:documentation>
      <empty/>
    </element>
  </define>
  <!-- Options for inclusion of calculations of surface integrals in the .stat file   -->
  <define name="surface_integral_stats_base.surface_integral">
    <attribute name="name">
      <data type="string"/>
    </attribute>
    <optional>
      <element name="surface_ids">
        <a:documentation>Surface IDs defining the surface over which to integrate. If disabled, integrates over the whole surface.</a:documentation>
        <ref name="integer_vector"/>
      </element>
    </optional>
    <optional>
      <element name="normalise">
        <a:documentation>Enable to normalise the integral by dividing by the surface area</a:documentation>
        <ref name="comment"/>
      </element>
    </optional>
  </define>
  <define name="surface_integral_stats_scalar">
    <element name="surface_integral">
      <a:documentation>Surface integral calculations. The following integral types are available:
 value: Integrates the field
 gradient_normal: Integrates the normal component of the gradient of the field</a:documentation>
      <ref name="surface_integral_stats_scalar.surface_integral"/>
    </element>
  </define>
  <define name="surface_integral_stats_scalar.surface_integral">
    <ref name="surface_integral_stats_base.surface_integral"/>
  </define>
  <define name="surface_integral_stats_scalar.surface_integral" combine="interleave">
    <attribute name="type">
      <choice>
        <value>value</value>
        <value>gradient_normal</value>
      </choice>
    </attribute>
  </define>
  <define name="surface_integral_stats_vector">
    <element name="surface_integral">
      <a:documentation>Surface integral calculations. The following integral types are available:
 normal: Integrates the normal component of the field</a:documentation>
      <ref name="surface_integral_stats_vector.surface_integral"/>
    </element>
  </define>
  <define name="surface_integral_stats_vector.surface_integral">
    <ref name="surface_integral_stats_base.surface_integral"/>
  </define>
  <define name="surface_integral_stats_vector.surface_integral" combine="interleave">
    <attribute name="type">
      <value>normal</value>
    </attribute>
  </define>
  <define name="forcing">
    <element name="ocean_forcing">
      <a:documentation>Force the boundary conditions of various fields in ocean simulations</a:documentation>
      <optional>
        <element name="iceshelf_meltrate">
          <optional>
            <element name="Holland08">
              <a:documentation>The type of parameterisation </a:documentation>
              <element name="c0">
                <a:documentation>Specific heat capacity of water [Jkg^{-1}]. Default value 3974.</a:documentation>
                <ref name="real"/>
              </element>
              <element name="cI">
                <a:documentation>Specific heat capacity of ice [Jkg^{-1}] Default value 2009.</a:documentation>
                <ref name="real"/>
              </element>
              <element name="L">
                <a:documentation>Transfer of heat and salt through the boundary layer [Jkg^{-1}]. Default value 3.35e5</a:documentation>
                <ref name="real"/>
              </element>
              <element name="TI">
                <a:documentation>Temperature of ice [C]. Default value -25, pretty cold </a:documentation>
                <ref name="real"/>
              </element>
              <element name="a">
                <a:documentation>Tb=aSb+b+cB, See equation (4) of Holland08. Default value -0.0573C. </a:documentation>
                <ref name="real"/>
              </element>
              <element name="b">
                <a:documentation>Tb=aSb+b+cB, See equation (4) of Holland08. Default value 0.0832C. </a:documentation>
                <ref name="real"/>
              </element>
              <element name="Cd">
                <a:documentation>Drag coefficient, 1.5e-3, see Holland and Jenkins's(1999) Cd. </a:documentation>
                <ref name="real"/>
              </element>
              <optional>
                <element name="melt_surfaceID">
                  <a:documentation>Surface ID for the ice</a:documentation>
                  <ref name="integer_vector"/>
                </element>
              </optional>
              <element name="melt_LayerLength">
                <a:documentation>Distance for the far field</a:documentation>
                <ref name="real"/>
              </element>
              <optional>
                <element name="scalar_field">
                  <a:documentation>Meltrate, calculated from the three equations.</a:documentation>
                  <attribute name="rank">
                    <value>0</value>
                  </attribute>
                  <attribute name="name">
                    <value>MeltRate</value>
                  </attribute>
                  <element name="diagnostic">
                    <ref name="internal_algorithm"/>
                    <ref name="velocity_mesh_choice"/>
                    <ref name="diagnostic_scalar_field"/>
                  </element>
                </element>
              </optional>
              <optional>
                <element name="scalar_field">
                  <a:documentation>Temperature of the ice-ocean interface, calculated from the three equations.</a:documentation>
                  <attribute name="rank">
                    <value>0</value>
                  </attribute>
                  <attribute name="name">
                    <value>Tb</value>
                  </attribute>
                  <element name="diagnostic">
                    <ref name="internal_algorithm"/>
                    <ref name="velocity_mesh_choice"/>
                    <ref name="diagnostic_scalar_field"/>
                  </element>
                </element>
              </optional>
              <optional>
                <element name="scalar_field">
                  <a:documentation>Salinity of the ice-ocean interface, calculated from the three equations.</a:documentation>
                  <attribute name="rank">
                    <value>0</value>
                  </attribute>
                  <attribute name="name">
                    <value>Sb</value>
                  </attribute>
                  <element name="diagnostic">
                    <ref name="internal_algorithm"/>
                    <ref name="velocity_mesh_choice"/>
                    <ref name="diagnostic_scalar_field"/>
                  </element>
                </element>
              </optional>
              <optional>
                <element name="scalar_field">
                  <a:documentation>Heat flux at the ice-ocean interface.</a:documentation>
                  <attribute name="rank">
                    <value>0</value>
                  </attribute>
                  <attribute name="name">
                    <value>Heat_flux</value>
                  </attribute>
                  <element name="diagnostic">
                    <ref name="internal_algorithm"/>
                    <ref name="velocity_mesh_choice"/>
                    <ref name="diagnostic_scalar_field"/>
                  </element>
                </element>
              </optional>
              <optional>
                <element name="scalar_field">
                  <a:documentation>Salt flux at the ice-ocean interface.</a:documentation>
                  <attribute name="rank">
                    <value>0</value>
                  </attribute>
                  <attribute name="name">
                    <value>Salt_flux</value>
                  </attribute>
                  <element name="diagnostic">
                    <ref name="internal_algorithm"/>
                    <ref name="velocity_mesh_choice"/>
                    <ref name="diagnostic_scalar_field"/>
                  </element>
                </element>
              </optional>
              <optional>
                <element name="scalar_field">
                  <a:documentation>Temperature of the far field, which is "melt_LayerLength" away from the ice. 
This variable feeds into the three equations. </a:documentation>
                  <attribute name="rank">
                    <value>0</value>
                  </attribute>
                  <attribute name="name">
                    <value>Tloc</value>
                  </attribute>
                  <element name="diagnostic">
                    <ref name="internal_algorithm"/>
                    <ref name="velocity_mesh_choice"/>
                    <ref name="diagnostic_scalar_field"/>
                  </element>
                </element>
              </optional>
              <optional>
                <element name="scalar_field">
                  <a:documentation>Salinity of the far field, which is "melt_LayerLength" away from the ice.
This variable feeds into the three equations. </a:documentation>
                  <attribute name="rank">
                    <value>0</value>
                  </attribute>
                  <attribute name="name">
                    <value>Sloc</value>
                  </attribute>
                  <element name="diagnostic">
                    <ref name="internal_algorithm"/>
                    <ref name="velocity_mesh_choice"/>
                    <ref name="diagnostic_scalar_field"/>
                  </element>
                </element>
              </optional>
              <optional>
                <element name="scalar_field">
                  <a:documentation>Pressure used in the three equations. 
We need to use the pressure at the ice-ocean interface.</a:documentation>
                  <attribute name="rank">
                    <value>0</value>
                  </attribute>
                  <attribute name="name">
                    <value>Ploc</value>
                  </attribute>
                  <element name="diagnostic">
                    <ref name="internal_algorithm"/>
                    <ref name="velocity_mesh_choice"/>
                    <ref name="diagnostic_scalar_field"/>
                  </element>
                </element>
              </optional>
              <optional>
                <element name="vector_field">
                  <a:documentation>Velocity of the far field, which is "melt_LayerLength" away from the ice.
This variable feeds into the three equations. </a:documentation>
                  <attribute name="rank">
                    <value>0</value>
                  </attribute>
                  <attribute name="name">
                    <value>Vloc</value>
                  </attribute>
                  <element name="diagnostic">
                    <ref name="internal_algorithm"/>
                    <ref name="velocity_mesh_choice"/>
                    <ref name="diagnostic_vector_field"/>
                  </element>
                </element>
              </optional>
              <optional>
                <element name="vector_field">
                  <a:documentation>Location of your far field, which is "melt_LayerLength" away from the ice.
Location should be perpendicular to the ice-ocean boundary.
melt_LayerLength = ||Location - Location_org||</a:documentation>
                  <attribute name="rank">
                    <value>0</value>
                  </attribute>
                  <attribute name="name">
                    <value>Location</value>
                  </attribute>
                  <element name="diagnostic">
                    <ref name="internal_algorithm"/>
                    <ref name="velocity_mesh_choice"/>
                    <ref name="diagnostic_vector_field"/>
                  </element>
                </element>
              </optional>
              <optional>
                <element name="vector_field">
                  <a:documentation>Location of your ice-ocean boundary.</a:documentation>
                  <attribute name="rank">
                    <value>0</value>
                  </attribute>
                  <attribute name="name">
                    <value>Location_org</value>
                  </attribute>
                  <element name="diagnostic">
                    <ref name="internal_algorithm"/>
                    <ref name="velocity_mesh_choice"/>
                    <ref name="diagnostic_vector_field"/>
                  </element>
                </element>
              </optional>
              <optional>
                <element name="calculate_boundaries">
                  <a:documentation>Boundary stuff   </a:documentation>
                  <element name="string_value">
                    <choice>
                      <value>neumann</value>
                      <value>dirichlet</value>
                    </choice>
                  </element>
                </element>
              </optional>
            </element>
          </optional>
        </element>
      </optional>
      <optional>
        <element name="shelf">
          <optional>
            <element name="amplitude">
              <a:documentation>Multiplying factor on equilibrium pressure</a:documentation>
              <ref name="real"/>
            </element>
          </optional>
          <optional>
            <element name="y_sign">
              <a:documentation>Change sign of depth / perturbation from original eta_0</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="calculate_only">
              <a:documentation>Only calculate the field, don't add to pressure (RHS of Momentum)</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="salinity_change_constant">
              <a:documentation>DeltaS for constant change over ocean,
or the difference between min and max for a linear variation in S</a:documentation>
              <ref name="real"/>
            </element>
          </optional>
          <optional>
            <element name="add_pressure_from_ice">
              <a:documentation>If the ice shelf is not included in the original mesh and a free-surface initial condition is used to generate the shelf, the hydrostatic pressure where the shelf now exists needs to be included</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="include_density_change_of_ice">
              <a:documentation>If using a linear variation in S, include the associated change in density of the ice shelf
NOT arranged to work with add_pressure_from_ice - TODO</a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
      </optional>
      <optional>
        <element name="external_data_boundary_conditions">
          <a:documentation>Check this option to use an external data set for the t(0)
and in/out boundary conditions. This sets up NEMO-type forcing.</a:documentation>
          <element name="input_file">
            <a:documentation>Path of the file containing the external data set</a:documentation>
            <attribute name="file_name">
              <data type="string"/>
            </attribute>
          </element>
        </element>
      </optional>
      <optional>
        <element name="bulk_formulae">
          <a:documentation>Bulk formulae allow the boundary conditions of Temperature, Velocity, Salinty
and photosynthetic radiation to be set using data obtained from
the ERA-40 reanalysis (http://data-portal.ecmwf.int/data/d/era40_daily/)</a:documentation>
          <optional>
            <element name="bulk_formulae">
              <a:documentation>The type of bulk formulae to use. Default is NCAR if no selection is made.</a:documentation>
              <choice>
                <element name="type">
                  <a:documentation>Bulk formulae from Large and Yeager (2004)
Large, W. G. &amp; Yeager, S. G. Diurnal to decadal global forcing 
for ocean and sea-ice models: The data sets and flux climatologies. NCAR TR.</a:documentation>
                  <attribute name="name">
                    <value>NCAR</value>
                  </attribute>
                  <empty/>
                </element>
                <element name="type">
                  <a:documentation>Bulk formulae from Fairall et al (2003). 
Bulk Parameterization of AirSea Fluxes: Updates and 
Verification for the COARE Algorithm Journal of Climate, 2003, 16, 571-591</a:documentation>
                  <attribute name="name">
                    <value>COARE</value>
                  </attribute>
                  <empty/>
                </element>
                <element name="type">
                  <a:documentation>Bulk formulae from Kara et al (2005).
Stability-Dependent Exchange Coefficients for AirSea Fluxes
Journal of Atmospheric and Oceanic Technology, 2005, 22, 1080-1094</a:documentation>
                  <attribute name="name">
                    <value>Kara</value>
                  </attribute>
                  <empty/>
                </element>
              </choice>
            </element>
          </optional>
          <element name="input_file">
            <a:documentation>The netCDF data file downloaded from ERA-40 reanalysis website
(see above)</a:documentation>
            <attribute name="file_name">
              <data type="string"/>
            </attribute>
          </element>
          <optional>
            <element name="input_file_type">
              <choice>
                <element name="type">
                  <a:documentation>What kind of file is this? Currently only ERA40 files are supported</a:documentation>
                  <attribute name="name">
                    <value>ERA40</value>
                  </attribute>
                  <optional>
                    <element name="no_accumulation">
                      <a:documentation>The data from ERA40 website included accumulated values (ppt, ro, ssrd, strd).
If these values have been already ammended to instantaneous values, then switch this
flag on and the accumulation correction will not be applied.</a:documentation>
                      <empty/>
                    </element>
                  </optional>
                </element>
                <element name="type">
                  <attribute name="name">
                    <value>NSEP</value>
                  </attribute>
                  <empty/>
                </element>
                <element name="type">
                  <attribute name="name">
                    <value>ICOM</value>
                  </attribute>
                  <empty/>
                </element>
              </choice>
            </element>
          </optional>
          <optional>
            <element name="position">
              <a:documentation>Adding a latitude and longitude here (specified as two real numbers)
will obtain data from the forcing file at that location. The
mesh is not translated nor is the mesh put on the sphere, instead the
specified lat/long is translated into cartesian coordinates and this is simply
added to the surface mesh node coordinates when fluxes are calculated.</a:documentation>
              <ref name="real_vector"/>
              <optional>
                <element name="single_location">
                  <a:documentation>Turning on this option will cause all nodes on the surface mesh to
experience the same forcing, regardless of position. Only really
useful for psuedo-1D simulations.</a:documentation>
                  <empty/>
                </element>
              </optional>
            </element>
          </optional>
          <element name="output_fluxes_diagnostics">
            <a:documentation>Ouput some extra diagnostic fields for the momentum, temperature and salinity fluxes
These &lt;b&gt;must&lt;/b&gt; be on the velocity mesh</a:documentation>
            <optional>
              <element name="vector_field">
                <attribute name="rank">
                  <value>1</value>
                </attribute>
                <attribute name="name">
                  <value>MomentumFlux</value>
                </attribute>
                <choice>
                  <element name="diagnostic">
                    <ref name="internal_algorithm"/>
                    <ref name="velocity_mesh_choice"/>
                    <ref name="diagnostic_scalar_field"/>
                  </element>
                  <element name="aliased">
                    <ref name="generic_aliased_field"/>
                  </element>
                </choice>
              </element>
            </optional>
            <optional>
              <element name="scalar_field">
                <attribute name="rank">
                  <value>0</value>
                </attribute>
                <attribute name="name">
                  <value>HeatFlux</value>
                </attribute>
                <choice>
                  <element name="diagnostic">
                    <ref name="internal_algorithm"/>
                    <ref name="velocity_mesh_choice"/>
                    <ref name="diagnostic_scalar_field"/>
                  </element>
                  <element name="aliased">
                    <ref name="generic_aliased_field"/>
                  </element>
                </choice>
              </element>
            </optional>
            <optional>
              <element name="scalar_field">
                <attribute name="rank">
                  <value>0</value>
                </attribute>
                <attribute name="name">
                  <value>SalinityFlux</value>
                </attribute>
                <choice>
                  <element name="diagnostic">
                    <ref name="internal_algorithm"/>
                    <ref name="velocity_mesh_choice"/>
                    <ref name="diagnostic_scalar_field"/>
                  </element>
                  <element name="aliased">
                    <ref name="generic_aliased_field"/>
                  </element>
                </choice>
              </element>
            </optional>
            <optional>
              <element name="scalar_field">
                <attribute name="rank">
                  <value>0</value>
                </attribute>
                <attribute name="name">
                  <value>PhotosyntheticRadiationDownward</value>
                </attribute>
                <choice>
                  <element name="diagnostic">
                    <ref name="internal_algorithm"/>
                    <ref name="velocity_mesh_choice"/>
                    <ref name="diagnostic_scalar_field"/>
                  </element>
                  <element name="aliased">
                    <ref name="generic_aliased_field"/>
                  </element>
                </choice>
              </element>
            </optional>
          </element>
        </element>
      </optional>
      <optional>
        <element name="tidal_forcing">
          <a:documentation>Tidal forcing options </a:documentation>
          <optional>
            <element name="M2">
              <a:documentation>M2</a:documentation>
              <optional>
                <element name="frequency">
                  <a:documentation>Ancient frequencies:

Ma     Frequency

0        1.405e-4

10      1.408e-4

50      1.416e-4

100    1.423e-4

200    1.428e-4

300    1.431e-4

350    1.434e-4

400    1.436e-4

450    1.441e-4

500    1.451e-4

570    1.469e-4

From Poliakow,2005</a:documentation>
                  <ref name="real"/>
                </element>
              </optional>
              <optional>
                <element name="amplitude">
                  <a:documentation>Ma     Amplitude

0        0.2423

10      0.2428

50      0.2446

100    0.2460

200    0.2471

300    0.2477

350    0.2485

400    0.2489

450    0.2499

500    0.2521

570    0.2560

From Poliakow,2005</a:documentation>
                  <ref name="real"/>
                </element>
              </optional>
            </element>
          </optional>
          <optional>
            <element name="S2">
              <a:documentation>S2</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="N2">
              <a:documentation>N2</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="K2">
              <a:documentation>K2</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="K1">
              <a:documentation>K1</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="O1">
              <a:documentation>O1</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="P1">
              <a:documentation>P1</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="Q1">
              <a:documentation>Q1</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="Mf">
              <a:documentation>Mf</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="Mm">
              <a:documentation>Mm</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="Ssa">
              <a:documentation>Ssa</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="all_tidal_components">
              <a:documentation>Switch on all tidal components</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="love_number">
              <a:documentation>Sets a user defined Love number. If not active a value of 1.0 is used.
Recommended value is 0.693</a:documentation>
              <element name="value">
                <ref name="real"/>
              </element>
            </element>
          </optional>
          <optional>
            <element name="sal">
              <a:documentation>Self attraction and loading term (SAL). This is a simple implementation
that uses a constant beta value</a:documentation>
              <element name="beta">
                <ref name="real"/>
              </element>
            </element>
          </optional>
          <optional>
            <element name="chi">
              <a:documentation>Add the CHI term to the harmonics. You probably only want to do this is you're simulating a specific time</a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
      </optional>
    </element>
  </define>
  <define name="biology">
    <element name="ocean_biology">
      <a:documentation>Model of biological processes in the ocean.</a:documentation>
      <choice>
        <element name="pznd">
          <a:documentation>A simple model of phytoplankton, zooplankton, general nutrient and detritus. </a:documentation>
          <choice>
            <element name="source_and_sink_algorithm">
              <a:documentation>Python code specifying the source and sink relationships 
between the biological tracers. This is usually achieved by 
importing fluidity.ocean_biology and calling a scheme from there. </a:documentation>
              <ref name="python_code"/>
            </element>
            <element name="disable_sources_and_sinks">
              <a:documentation>Do not calculate sources and sinks. 
This option is generally only useful for testing. </a:documentation>
              <empty/>
            </element>
          </choice>
          <element name="scalar_field">
            <a:documentation>Photosynthetically Active Radiation (PAR)</a:documentation>
            <attribute name="rank">
              <value>0</value>
            </attribute>
            <attribute name="name">
              <value>PhotosyntheticRadiation</value>
            </attribute>
            <choice>
              <element name="prognostic">
                <ref name="velocity_mesh_choice"/>
                <ref name="prognostic_photosynthetic_radiation"/>
              </element>
              <element name="prescribed">
                <ref name="velocity_mesh_choice"/>
                <ref name="prescribed_scalar_field"/>
              </element>
            </choice>
          </element>
        </element>
        <element name="six_component">
          <a:documentation>6 component biology model, which models Nitrates, Ammonium, 
Phytoplankton, Zooplankton, Detritus and Chlorophyll.

These fields must be enabled in the material phase

Based on the equations in
Popova, E. E.; Coward, A. C.; Nurser, G. A.; de Cuevas, B.; Fasham, M. J. R. &amp; Anderson, T. R. 
Mechanisms controlling primary and new production in a global ecosystem model - Part I: 
Validation of the biological simulation Ocean Science, 2006, 2, 249-266. 
DOI: 10.5194/os-2-249-2006</a:documentation>
          <choice>
            <element name="source_and_sink_algorithm">
              <a:documentation>Python code specifying the biology model. This takes
in velocity and light and outputs Phytoplankton, if
those fields exist.</a:documentation>
              <ref name="python_code"/>
            </element>
            <element name="disable_sources_and_sinks">
              <a:documentation>Do not calculate biology
This option is generally only useful for testing. </a:documentation>
              <empty/>
            </element>
          </choice>
          <optional>
            <element name="scalar_field">
              <a:documentation>Photosynthetically Active Radiation (PAR)</a:documentation>
              <attribute name="rank">
                <value>0</value>
              </attribute>
              <attribute name="name">
                <value>PhotosyntheticRadiation</value>
              </attribute>
              <choice>
                <element name="prognostic">
                  <ref name="velocity_mesh_choice"/>
                  <ref name="prognostic_photosynthetic_radiation"/>
                </element>
                <element name="prescribed">
                  <ref name="velocity_mesh_choice"/>
                  <ref name="prescribed_scalar_field"/>
                </element>
              </choice>
            </element>
          </optional>
        </element>
      </choice>
    </element>
  </define>
  <define name="prognostic_photosynthetic_radiation">
    <element name="equation">
      <a:documentation>PAR equation.</a:documentation>
      <attribute name="name">
        <value>PhotosyntheticRadiation</value>
      </attribute>
    </element>
    <element name="spatial_discretisation">
      <a:documentation>Spatial discretisation options</a:documentation>
      <element name="discontinuous_galerkin">
        <a:documentation>Discontinuous galerkin formulation. You can also use this
formulation with a continuous field in which case a simple
galerkin formulation will result. </a:documentation>
        <empty/>
      </element>
    </element>
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options_asym_scalar"/>
    </element>
    <!-- Alas, no initial_condition either, so we'd better not checkpoint it... -->
    <element name="exclude_from_checkpointing">
      <a:documentation>Disables checkpointing of this field</a:documentation>
      <ref name="comment"/>
    </element>
    <element name="absorption_coefficients">
      <a:documentation>Coefficients of absorption of photosynthetically active
radiation for water and phytoplankton.</a:documentation>
      <element name="water">
        <a:documentation>Photosynthetically active radiation absorption coefficient for water.</a:documentation>
        <ref name="real"/>
      </element>
      <element name="phytoplankton">
        <a:documentation>Photosynthetically active radiation absorption coefficient for water.</a:documentation>
        <ref name="real"/>
      </element>
    </element>
    <optional>
      <element name="boundary_conditions">
        <a:documentation>Boundary conditions</a:documentation>
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
        <element name="surface_ids">
          <a:documentation>Surface id:</a:documentation>
          <ref name="integer_vector"/>
        </element>
        <choice>
          <a:documentation>Type</a:documentation>
          <element name="type">
            <attribute name="name">
              <value>dirichlet</value>
            </attribute>
            <element name="apply_weakly">
              <a:documentation>Apply the dirichlet bc weakly.  Only available with
discontinuous_galerkin and control_volume
spatial_discretisations.

If not selected boundary conditions are applied strongly.</a:documentation>
              <empty/>
            </element>
            <ref name="input_choice_real"/>
          </element>
          <element name="type">
            <attribute name="name">
              <value>bulk_formulae</value>
            </attribute>
            <empty/>
          </element>
          <element name="type">
            <attribute name="name">
              <value>neumann</value>
            </attribute>
            <ref name="input_choice_real"/>
          </element>
        </choice>
      </element>
    </optional>
    <ref name="prognostic_scalar_output_options"/>
    <ref name="prognostic_scalar_stat_options"/>
    <ref name="scalar_convergence_options"/>
    <ref name="prognostic_detector_options"/>
    <ref name="scalar_steady_state_options"/>
    <ref name="adaptivity_options_scalar_field"/>
    <optional>
      <element name="priority">
        <a:documentation>Set the priority of this field
This determines the order in which scalar_fields are solved for:
 - higher numbers have the highest priority
 - lower numbers (including negative) have the lowest priority
 - default if not set is 0</a:documentation>
        <ref name="integer"/>
      </element>
    </optional>
  </define>
  <define name="recalculation_options">
    <element name="do_not_recalculate">
      <a:documentation>Prevent this field from being recalculated at every timestep.
This is cheaper especially if you are enforcing discrete properties on the field.</a:documentation>
      <empty/>
    </element>
  </define>
  <define name="discrete_properties_algorithm_scalar">
    <element name="enforce_discrete_properties">
      <a:documentation>Select discrete properties to enforce on the field
either after being prescribed or interpolated</a:documentation>
      <optional>
        <element name="solenoidal_lagrange_update">
          <a:documentation>Update this field using the lagrangian multiplier
calculated in the solenoidal projection of a
scalar field.

Note this field must be specified as the update field
underneath that vector field too.

Note also this only really makes sense for coupled
fields like velocity and pressure.</a:documentation>
          <empty/>
        </element>
      </optional>
    </element>
  </define>
  <define name="discrete_properties_algorithm_vector">
    <element name="enforce_discrete_properties">
      <a:documentation>Select discrete properties to enforce on the field
either after being prescribed or interpolated</a:documentation>
      <optional>
        <ref name="solenoidal_options"/>
      </optional>
    </element>
  </define>
  <define name="solenoidal_options">
    <element name="solenoidal">
      <a:documentation>Constrained divergence-free projection.
This adds an additional constraint that ensures that the field
is solenoidal, i.e. divergence-free.
This is equivalent in cost to a pressure solve.
This is expensive, and thus best left until
needed.

Note well: this only makes sense for nondivergent
vector fields, such as incompressible velocity!</a:documentation>
      <element name="interpolated_field">
        <a:documentation>Options for the mass matrix of the field being interpolated</a:documentation>
        <choice>
          <element name="continuous">
            <element name="lump_mass_matrix">
              <a:documentation>Lump the mass matrix for the assembly of the projection matrix
(not for the initial galerkin projection)

Required when using interpolating continuous fields</a:documentation>
              <optional>
                <element name="use_submesh">
                  <a:documentation>Lump on the submesh.
This only works for simplex meshes and is only
strictly valid on 2d meshes.</a:documentation>
                  <empty/>
                </element>
              </optional>
            </element>
          </element>
          <element name="discontinuous">
            <optional>
              <element name="lump_mass_matrix">
                <a:documentation>Lump the mass matrix for the assembly of the projection matrix
(not for the initial galerkin projection)</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
        </choice>
      </element>
      <element name="lagrange_multiplier">
        <a:documentation>Options for the lagrange multiplier

Must be on a continuous mesh!</a:documentation>
        <ref name="pressure_mesh_choice"/>
        <element name="spatial_discretisation">
          <choice>
            <element name="continuous_galerkin">
              <optional>
                <element name="remove_stabilisation_term">
                  <a:documentation>Remove the stabilisation term from the projection operator.

Automatic when not using P1P1.</a:documentation>
                  <empty/>
                </element>
              </optional>
              <optional>
                <element name="integrate_divergence_by_parts">
                  <a:documentation>Integrate the divergence operator by parts.

Automatic when projecting a discontinuous field</a:documentation>
                  <empty/>
                </element>
              </optional>
              <optional>
                <element name="test_divergence_with_cv_dual">
                  <a:documentation>Test the divergence equation with the control volume dual mesh
of the finite element lagrange multiplier mesh.
This will make the lagrange multiplier matrix non symmetric which must be 
considered when selecting the lagrange multiplier  solver options.</a:documentation>
                  <ref name="comment"/>
                </element>
              </optional>
            </element>
            <element name="control_volumes">
              <empty/>
            </element>
          </choice>
        </element>
        <optional>
          <element name="reference_node">
            <ref name="integer"/>
          </element>
        </optional>
        <optional>
          <element name="repair_stiff_nodes">
            <a:documentation>**UNDER DEVELOPMENT**
This searches the CMC matrix diagonal looking for nodes that are less than the maximum value time epsilon(0.0) (i.e. nodes that are effectively zero).
It then zeros that row and column and places a one on the diagonal and a zero on the rhs.
At a debug level of 2 it also prints out the value and the sum of the row values.
This is useful as a debugging tool if PETSc complains about zeros on the diagonal (i.e. if you have a stiff node in your mesh) but doesn't necessary produce nice answers at the end.</a:documentation>
            <empty/>
          </element>
        </optional>
        <optional>
          <choice>
            <element name="update_scalar_field">
              <a:documentation>Update a scalar field using the lagrange multiplier from
the divergence free projection of this field.  The selected
scalar field must have solenoidal selected in its interpolation
options too and it must be on the same mesh as used for the
solenoidal projection above.

Note well: this only really makes sense for scalar fields linked to nondivergent
vector fields, such as pressure to incompressible velocity!                  </a:documentation>
              <attribute name="name">
                <value>Pressure</value>
              </attribute>
              <empty/>
            </element>
            <element name="update_scalar_field">
              <a:documentation>Update a scalar field using the lagrange multiplier from
the divergence free projection of this field.  The selected
scalar field must have solenoidal selected in its interpolation
options too and it must be on the same mesh as used for the
solenoidal projection above.

Note well: this only really makes sense for scalar fields linked to nondivergent
vector fields, such as pressure to incompressible velocity!                  </a:documentation>
              <attribute name="name">
                <data type="string" datatypeLibrary=""/>
              </attribute>
              <empty/>
            </element>
          </choice>
        </optional>
        <element name="solver">
          <a:documentation>Solver options for the linear solve.
This method requires the inversion of a projection matrix.</a:documentation>
          <ref name="linear_solver_options_sym"/>
        </element>
      </element>
    </element>
  </define>
  <define name="represcribe_before_interpolation">
    <element name="represcribe_before_interpolation">
      <a:documentation>Represcribe the field before interpolation.

This means the interpolation will not be conservative from the previous mesh so be careful what you're trying to achieve!</a:documentation>
      <empty/>
    </element>
  </define>
</grammar>
