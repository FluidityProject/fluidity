<?xml version="1.0" encoding="UTF-8"?>
<grammar xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0" xmlns="http://relaxng.org/ns/structure/1.0" datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes">
  <include href="spud_base.rng"/>
  <include href="adaptivity_options.rng"/>
  <include href="diagnostic_algorithms.rng"/>
  <include href="input_output.rng"/>
  <include href="solvers.rng"/>
  <include href="stabilisation.rng"/>
  <include href="adjoint_options.rng"/>
  <include href="physical_parameters.rng"/>
  <include href="mesh_options.rng"/>
  <include href="prognostic_field_options.rng"/>
  <include href="spatial_discretisation.rng"/>
  <include href="temporal_discretisation.rng"/>
  <start>
    <element name="shallow_water_options">
      <a:documentation>The root node of the options dictionary.</a:documentation>
      <ref name="comment"/>
      <element name="simulation_name">
        <a:documentation>Model output files are named according to the simulation
name, e.g. [simulation_name]_0.vtu. Non-standard
characters in the simulation name should be avoided.</a:documentation>
        <ref name="anystring"/>
      </element>
      <element name="geometry">
        <a:documentation>Options dealing with the specification of geometry</a:documentation>
        <element name="dimension">
          <a:documentation>Dimension of the problem.
&lt;b&gt;This can only be set once&lt;/b&gt;</a:documentation>
          <element name="integer_value">
            <attribute name="rank">
              <value>0</value>
            </attribute>
            <value>3</value>
          </element>
        </element>
        <element name="mesh">
          <a:documentation>The position mesh</a:documentation>
          <attribute name="name">
            <value>CoordinateMesh</value>
          </attribute>
          <ref name="mesh_info"/>
          <optional>
            <element name="recompute_coordinate_field">
              <a:documentation>Mapping to recompute coordinate field after creation.
Used for e.g. getting a higher-order representation
of the sphere from a linear sphere mesh.</a:documentation>
              <element name="python">
                <a:documentation>Python function to apply recomputation of coordinate
field Functions should be of the form:

 def val(t):
    # Function code
    return # Return value

</a:documentation>
                <ref name="python_code"/>
              </element>
            </element>
          </optional>
        </element>
        <element name="mesh">
          <a:documentation>The velocity mesh</a:documentation>
          <attribute name="name">
            <value>VelocityMesh</value>
          </attribute>
          <ref name="mesh_info"/>
          <optional>
            <element name="check_continuity">
              <a:documentation>Debugging option for hybridised solver
Check continuity in Cartesian space
Test only works for linear geometry field</a:documentation>
              <element name="tolerance">
                <a:documentation>Tolerance for check</a:documentation>
                <ref name="real"/>
              </element>
            </element>
          </optional>
          <optional>
            <element name="check_continuity_matrix">
              <a:documentation>Debugging option for hybridised solver
Check continuity matrix
Checks for jumps using local coordinates</a:documentation>
              <element name="tolerance">
                <a:documentation>Tolerance for check</a:documentation>
                <ref name="real"/>
              </element>
            </element>
          </optional>
        </element>
        <element name="mesh">
          <a:documentation>The pressure mesh</a:documentation>
          <attribute name="name">
            <value>PressureMesh</value>
          </attribute>
          <ref name="mesh_info"/>
        </element>
        <optional>
          <element name="mesh">
            <a:documentation>Vorticity mesh</a:documentation>
            <attribute name="name">
              <value>VorticityMesh</value>
            </attribute>
            <ref name="mesh_info"/>
          </element>
        </optional>
        <zeroOrMore>
          <element name="mesh">
            <attribute name="name">
              <data type="string"/>
            </attribute>
            <ref name="mesh_info"/>
            <optional>
              <element name="exclude_from_mesh_adaptivity">
                <empty/>
              </element>
            </optional>
          </element>
        </zeroOrMore>
        <element name="quadrature">
          <a:documentation>Quadrature</a:documentation>
          <element name="degree">
            <a:documentation>Quadrature degree

note: this specifies the degree of quadrature,
not the number of gauss points</a:documentation>
            <ref name="integer"/>
          </element>
          <optional>
            <element name="surface_degree">
              <a:documentation>Surface quadrature degree

note: this specifies the degree of surface
quadrature not the number of surface gauss points</a:documentation>
              <ref name="integer"/>
            </element>
          </optional>
          <optional>
            <element name="quadrature_family">
              <a:documentation>Select which family of quadrature rules to use.
The default is family_cools.
family_wandzura allows for degree up to 30
on triangular meshes.
family_grundmann_moeller allows for degree up to
29 on simplicial meshes in arbitrary dimension.</a:documentation>
              <choice>
                <value>family_cools</value>
                <value>family_grundmann_moeller</value>
                <value>family_wandzura</value>
              </choice>
            </element>
          </optional>
        </element>
        <optional>
          <element name="spherical_earth">
            <a:documentation>Options specifying that the problem is on the surface of the sphere.</a:documentation>
            <choice>
              <element name="linear_mapping">
                <empty/>
              </element>
              <element name="superparametric_mapping">
                <a:documentation>Enabling this option approximates the curvature of the Earth as an
nth degree polynomial, where n is the polynomial degree of the coordinate mesh.</a:documentation>
                <empty/>
              </element>
            </choice>
          </element>
        </optional>
      </element>
      <element name="io">
        <a:documentation>Input/output options</a:documentation>
        <element name="dump_format">
          <a:documentation>Format for dump files. Only vtk for now.</a:documentation>
          <element name="string_value">
            <value>vtk</value>
          </element>
        </element>
        <choice>
          <element name="dump_period">
            <a:documentation>Period between dumps in time units.

Specifies the period between each dump of the solution to disk.
A value of 0.0 indicates that there would be a dump at every timestep.</a:documentation>
            <choice>
              <element name="constant">
                <ref name="real"/>
              </element>
              <element name="python">
                <a:documentation>Python function prescribing real input. Functions should be of the form:

 def val(t):
    # Function code
    return # Return value

</a:documentation>
                <ref name="python_code"/>
              </element>
            </choice>
          </element>
          <element name="dump_period_in_timesteps">
            <a:documentation>Dump period, in timesteps.

Specifies the number of timesteps between each dump of the solution to disk.
A value of 0 indicates a dump at every timestep.</a:documentation>
            <choice>
              <element name="constant">
                <ref name="integer"/>
              </element>
              <element name="python">
                <a:documentation>Python function prescribing integer input. Functions should be of the form:

 def val(t):
    # Function code
    return # Return value

</a:documentation>
                <ref name="python_code"/>
              </element>
            </choice>
          </element>
        </choice>
        <optional>
          <!-- every CPUDUM seconds write results to disc. -->
          <element name="cpu_dump_period">
            <a:documentation>This is usually disabled.</a:documentation>
            <ref name="real"/>
          </element>
        </optional>
        <optional>
          <element name="wall_time_dump_period">
            <a:documentation>The period between dumps in walltime seconds. This is usually disabled.</a:documentation>
            <ref name="real"/>
          </element>
        </optional>
        <choice>
          <element name="output_mesh">
            <a:documentation>The mesh on to which all the fields will be
interpolated for VTK output.</a:documentation>
            <attribute name="name">
              <value>VelocityMesh</value>
            </attribute>
          </element>
          <element name="output_mesh">
            <a:documentation>The mesh on to which all the fields will be
interpolated for VTK output.</a:documentation>
            <attribute name="name">
              <value>PressureMesh</value>
            </attribute>
          </element>
          <element name="output_mesh">
            <a:documentation>The mesh on to which all the fields will be
interpolated for VTK output.</a:documentation>
            <attribute name="name">
              <value>CoordinateMesh</value>
            </attribute>
          </element>
          <element name="output_mesh">
            <a:documentation>The mesh on to which all the fields will be
interpolated for VTK output.</a:documentation>
            <attribute name="name">
              <data type="string"/>
            </attribute>
          </element>
        </choice>
      </element>
      <element name="timestepping">
        <a:documentation>Options dealing with time discretisation</a:documentation>
        <element name="current_time">
          <a:documentation>Current simulation time. At the start of the simulation this
is the start time.</a:documentation>
          <ref name="real"/>
          <optional>
            <element name="time_units">
              <a:documentation>The following excerpt from the Udunits
documentation explains the time unit encoding by
example:

The specification:

seconds since 1992-10-8 15:15:42.5 -6:00

indicates seconds since October 8th, 1992 at 3
hours, 15 minutes and 42.5 seconds in the afternoon
in the time zone which is six hours to the west of
Coordinated Universal Time (i.e.  Mountain Daylight
Time). The time zone specification can also be
written without a colon using one or two-digits
(indicating hours) or three or four digits
(indicating hours and minutes).

Time units are particularly required in situations
where the problem (time-varying) boundary conditions
and/ initial conditions are a function of time as
defined by a calendar.  Examples include atmospheric
forcing and climatology. The current time, specified
above, is zero at the reference data/time.</a:documentation>
              <attribute name="date">
                <data type="string"/>
              </attribute>
            </element>
          </optional>
        </element>
        <element name="timestep">
          <a:documentation>The time step size. If adaptive time stepping is used
then this is the initial time step size.</a:documentation>
          <ref name="real"/>
        </element>
        <element name="theta">
          <a:documentation>Implicit/explicit control (THETA)
 =0.  -- explicit
 =0.5 -- Crank-Nicolson
 =1.  -- implicit</a:documentation>
          <ref name="real"/>
        </element>
        <element name="nonlinear_iterations">
          <a:documentation>How many nonlinear iterations in the timestepping loop</a:documentation>
          <ref name="integer"/>
        </element>
        <element name="finish_time">
          <a:documentation>Simulation time at which the simulation should end.</a:documentation>
          <ref name="real"/>
        </element>
        <optional>
          <element name="final_timestep">
            <a:documentation>Timestep after which the simulation should end.</a:documentation>
            <ref name="integer"/>
          </element>
        </optional>
        <optional>
          <element name="cpu_time_limit">
            <a:documentation>Maximum CPU time (secs) taken up before
simulation terminates writing results to disc.

Manual suggests 1.E+20</a:documentation>
            <ref name="real"/>
          </element>
        </optional>
        <optional>
          <element name="wall_time_limit">
            <a:documentation>Maximum wall time (secs) taken up before
simulation terminates writing results to disc.

This is usually disabled.</a:documentation>
            <ref name="real"/>
          </element>
        </optional>
      </element>
      <element name="physical_parameters">
        <a:documentation>The physical parameters</a:documentation>
        <element name="gravity">
          <a:documentation>Set a gravity to be included in the buoyancy term.</a:documentation>
          <element name="magnitude">
            <a:documentation>Acceleration due to gravity. 9.8 m/s^2 on earth.</a:documentation>
            <ref name="real"/>
          </element>
          <element name="vector_field">
            <a:documentation>The direction of the gravity vector.</a:documentation>
            <attribute name="name">
              <value>GravityDirection</value>
            </attribute>
            <attribute name="rank">
              <value>1</value>
            </attribute>
            <element name="prescribed">
              <ref name="coordinate_mesh_choice"/>
              <ref name="prescribed_vector_field_no_adapt"/>
              <ref name="recalculation_options"/>
            </element>
          </element>
        </element>
        <optional>
          <element name="coriolis">
            <a:documentation>Use this option to create a Coriolis parameter field if 
if isn't present as a field in state.</a:documentation>
            <ref name="python_code"/>
          </element>
        </optional>
      </element>
      <element name="material_phase">
        <a:documentation>The material or phase options</a:documentation>
        <attribute name="name">
          <value>Fluid</value>
        </attribute>
        <group>
          <element name="vector_field">
            <a:documentation>Velocity vector and momentum options</a:documentation>
            <attribute name="rank">
              <value>1</value>
            </attribute>
            <attribute name="name">
              <value>Velocity</value>
            </attribute>
            <choice>
              <a:documentation>Field type</a:documentation>
              <element name="prognostic">
                <element name="mesh">
                  <attribute name="name">
                    <value>VelocityMesh</value>
                  </attribute>
                </element>
                <ref name="prognostic_sw_velocity_field"/>
              </element>
              <element name="prescribed">
                <element name="mesh">
                  <attribute name="name">
                    <value>VelocityMesh</value>
                  </attribute>
                </element>
                <ref name="prescribed_vector_field"/>
              </element>
              <element name="aliased">
                <attribute name="material_phase_name">
                  <data type="string"/>
                </attribute>
                <attribute name="field_name">
                  <value>Velocity</value>
                </attribute>
              </element>
            </choice>
          </element>
          <optional>
            <element name="scalar_field">
              <a:documentation>Free surface elevation</a:documentation>
              <attribute name="rank">
                <value>0</value>
              </attribute>
              <attribute name="name">
                <value>LayerThickness</value>
              </attribute>
              <element name="prognostic">
                <ref name="pressure_mesh_choice"/>
                <ref name="prognostic_layerthickness_field"/>
              </element>
            </element>
          </optional>
          <optional>
            <element name="scalar_field">
              <a:documentation>Potential vorticity</a:documentation>
              <attribute name="rank">
                <value>0</value>
              </attribute>
              <attribute name="name">
                <value>PotentialVorticity</value>
              </attribute>
              <element name="prognostic">
                <ref name="vorticity_mesh_choice"/>
                <element name="spatial_discretisation">
                  <element name="continuous_galerkin">
                    <ref name="pv_advection_options_options"/>
                  </element>
                </element>
                <element name="solver">
                  <a:documentation>Solver</a:documentation>
                  <ref name="linear_solver_options_asym"/>
                </element>
                <ref name="prognostic_scalar_output_options"/>
                <ref name="prognostic_scalar_stat_options"/>
                <optional>
                  <element name="debug">
                    <empty/>
                  </element>
                </optional>
              </element>
            </element>
          </optional>
          <optional>
            <element name="scalar_field">
              <a:documentation>Tracer to test PV flux calculation
Only used if wave equation is not solved</a:documentation>
              <attribute name="rank">
                <value>0</value>
              </attribute>
              <attribute name="name">
                <value>PotentialVorticityTracer</value>
              </attribute>
              <element name="prognostic">
                <element name="spatial_discretisation">
                  <element name="continuous_galerkin">
                    <ref name="pv_advection_options_options"/>
                  </element>
                </element>
                <element name="initial_condition">
                  <attribute name="name">
                    <value>WholeMesh</value>
                  </attribute>
                  <ref name="input_choice_initial_condition_real"/>
                  <optional>
                    <element name="zero_bubble_component">
                      <empty/>
                    </element>
                  </optional>
                </element>
                <element name="timestepping">
                  <element name="theta">
                    <ref name="real"/>
                  </element>
                </element>
                <element name="solver">
                  <a:documentation>Solver</a:documentation>
                  <ref name="linear_solver_options_asym"/>
                </element>
                <ref name="vorticity_mesh_choice"/>
                <ref name="prognostic_scalar_output_options"/>
                <ref name="prognostic_scalar_stat_options"/>
                <optional>
                  <element name="debug">
                    <empty/>
                  </element>
                </optional>
              </element>
            </element>
          </optional>
          <optional>
            <element name="scalar_field">
              <a:documentation>Streamfunction for balanced initialisation</a:documentation>
              <attribute name="rank">
                <value>0</value>
              </attribute>
              <attribute name="name">
                <value>Streamfunction</value>
              </attribute>
              <choice>
                <element name="prescribed">
                  <element name="value">
                    <ref name="input_choice_real"/>
                  </element>
                  <optional>
                    <element name="initialise_from_quadrature_points">
                      <empty/>
                    </element>
                  </optional>
                  <optional>
                    <element name="solver">
                      <ref name="linear_solver_options_sym"/>
                    </element>
                  </optional>
                  <ref name="vorticity_mesh_choice"/>
                  <ref name="prognostic_scalar_output_options"/>
                </element>
                <element name="diagnostic">
                  <ref name="scalar_diagnostic_algorithms"/>
                  <ref name="vorticity_mesh_choice"/>
                  <ref name="diagnostic_scalar_field"/>
                </element>
              </choice>
            </element>
          </optional>
          <optional>
            <element name="scalar_field">
              <a:documentation>Orography</a:documentation>
              <attribute name="rank">
                <value>0</value>
              </attribute>
              <attribute name="name">
                <value>Orography</value>
              </attribute>
              <element name="prescribed">
                <element name="value">
                  <ref name="input_choice_real"/>
                </element>
                <optional>
                  <element name="projected">
                    <a:documentation>Initialise field from L2 projection</a:documentation>
                    <empty/>
                  </element>
                </optional>
                <optional>
                  <element name="limit_values">
                    <a:documentation>Apply limiter to orography</a:documentation>
                    <empty/>
                  </element>
                </optional>
                <optional>
                  <element name="subtract_from_layer_thickness">
                    <a:documentation>Subtract orography from layer thickness
field</a:documentation>
                    <empty/>
                  </element>
                </optional>
                <ref name="pressure_mesh_choice"/>
                <ref name="prognostic_scalar_output_options"/>
              </element>
            </element>
          </optional>
          <optional>
            <element name="scalar_field">
              <attribute name="rank">
                <value>0</value>
              </attribute>
              <attribute name="name">
                <value>ManifoldDivergence</value>
              </attribute>
              <element name="diagnostic">
                <ref name="scalar_diagnostic_algorithms"/>
                <ref name="pressure_mesh_choice"/>
              </element>
            </element>
          </optional>
          <optional>
            <element name="scalar_field">
              <attribute name="rank">
                <value>0</value>
              </attribute>
              <attribute name="name">
                <value>InitialLayerThickness</value>
              </attribute>
              <element name="diagnostic">
                <ref name="pressure_mesh_choice"/>
              </element>
            </element>
          </optional>
          <zeroOrMore>
            <ref name="scalar_field_choice"/>
          </zeroOrMore>
          <zeroOrMore>
            <ref name="vector_field_choice"/>
          </zeroOrMore>
          <zeroOrMore>
            <ref name="tensor_field_choice"/>
          </zeroOrMore>
        </group>
      </element>
      <optional>
        <element name="mesh_adaptivity">
          <choice>
            <ref name="hr_adaptivity"/>
            <ref name="prescribed_adaptivity"/>
          </choice>
        </element>
      </optional>
      <optional>
        <element name="debug">
          <a:documentation>Debugging options</a:documentation>
          <optional>
            <element name="check_inverse_coriolis_matrix">
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="check_wave_matrix">
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="check_solution">
              <empty/>
            </element>
          </optional>
        </element>
      </optional>
      <optional>
        <ref name="adjoint_options"/>
      </optional>
    </element>
  </start>
  <define name="pv_advection_options_options">
    <choice>
      <element name="theta_method">
        <a:documentation>Use the theta method for timestepping,
usually stabilised by SUPG</a:documentation>
        <optional>
          <element name="laplacian_filter">
            <element name="diffusivity">
              <ref name="real"/>
            </element>
          </element>
        </optional>
        <optional>
          <element name="streamline_upwinding">
            <element name="alpha">
              <a:documentation>Scaling parameter for upwinding
parameter tau, 1 = first-order upwind,
magic value for 1D = 1.0/sqrt(15)</a:documentation>
              <ref name="real"/>
            </element>
            <element name="tol">
              <a:documentation>For velocities below this tolerance, 
does not apply any upwinding</a:documentation>
              <ref name="real"/>
            </element>
          </element>
        </optional>
        <optional>
          <element name="local_projection">
            <empty/>
          </element>
        </optional>
      </element>
      <element name="taylor_galerkin">
        <a:documentation>Use the multistage Taylor-Galerkin timestepping
schemes of Safjan and Oden, 1995.</a:documentation>
        <element name="eta">
          <a:documentation>Stability parameter.</a:documentation>
          <ref name="real"/>
        </element>
        <choice>
          <a:documentation>Choice of particular scheme</a:documentation>
          <element name="Tbar2_3_scheme">
            <a:documentation>The \bar{T}(2,3) 2-stage
3rd order scheme 
(with positive sign)
unconditionally stable for 
eta&gt;0.473ish
stable for small enough Courant
number otherwise</a:documentation>
            <empty/>
          </element>
          <element name="T1_2_scheme">
            <a:documentation>Standard one-step TG(1,2) scheme
Unconditionally stable for eta&gt;0.5</a:documentation>
            <empty/>
          </element>
          <element name="T1_1_scheme">
            <a:documentation>Unstable one-step TG(1,1) scheme
Only useful for testing.</a:documentation>
            <empty/>
          </element>
        </choice>
      </element>
    </choice>
    <optional>
      <element name="discontinuity_capturing">
        <a:documentation>Use discontinuity capturing similar to that used in
A Local Projection Stabilization method with shock capturing
and diagonal mass matrix for solving non-stationary transport
dominated problems, Schieweck and Skrzpacz

Requires a discontinuity indicator diagnostic field
The discontinuity indicator uses the pressure space for 
the local projection filter.

The scaling coefficient controls the strength of the
discontinuity capturing and is proportional to the solution
magnitude</a:documentation>
        <attribute name="discontinuity_indicator_name">
          <a:documentation>Field to use as discontinuity indicator</a:documentation>
          <data type="string"/>
        </attribute>
        <element name="scaling_coefficient">
          <a:documentation>Constant scaling factor for discontinuity capturing term</a:documentation>
          <ref name="real"/>
        </element>
        <element name="filter_ratio">
          <a:documentation>Filter ratio (filter is switched on in cells whose ratio
of discontinuity indicator to the maximum value exceed
this value)</a:documentation>
          <ref name="real"/>
        </element>
      </element>
    </optional>
  </define>
  <define name="scalar_field_choice">
    <!--
      The first is a generic field, which may be used for any user-defined field
      that FLUIDITY knows nothing about, or a generic diagnostic
    -->
    <choice>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <choice>
          <a:documentation>Field type</a:documentation>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="diagnostic">
            <ref name="scalar_diagnostic_algorithms"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Passive Tracer</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Tracer</value>
        </attribute>
        <element name="prognostic">
          <ref name="velocity_mesh_choice"/>
          <ref name="prognostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>CFLNumber

See http://amcg.ese.ic.ac.uk/index.php?title=Local:Diagnostics#CFL_Number

Adapting to this field is not recommended</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>CFLNumber</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
          <ref name="adjoint_storage"/>
        </element>
      </element>
    </choice>
  </define>
  <!-- Choice of input method, e.g. for boundary conditions -->
  <define name="input_choice_real">
    <ref name="input_choice_real_contents"/>
  </define>
  <define name="input_choice_real_plus_boundary_forcing">
    <choice>
      <ref name="input_choice_real_contents"/>
      <element name="from_file">
        <oneOrMore>
          <element name="tidal">
            <attribute name="file_name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <attribute name="variable_name_amplitude">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <attribute name="variable_name_phase">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <attribute name="name">
              <a:documentation>See E.W. Schwiderski - Rev. Geophys. Space
Phys. Vol. 18 No. 1 pp. 243--268, 1980
for details of these constituent.</a:documentation>
              <choice>
                <value>M2</value>
                <value>S2</value>
                <value>N2</value>
                <value>K2</value>
                <value>K1</value>
                <value>O1</value>
                <value>P1</value>
                <value>Q1</value>
                <value>Mf</value>
                <value>Mm</value>
                <value>Ssa</value>
              </choice>
            </attribute>
          </element>
        </oneOrMore>
      </element>
    </choice>
  </define>
  <define name="input_choice_real_plus_file">
    <choice>
      <ref name="input_choice_real_contents"/>
      <element name="from_file">
        <a:documentation>Initialise the field from an existing file (indended primarily for picking up prescribed fields from previously run prognostic simulations). The file mesh must match the mesh of this field (except for piecewise constant fields which will be remapped back from the discontinuous nodal values).

THIS WILL NOT WORK FOR PRESCRIBED FIELDS NOT DIRECTLY UNDERNEATH /material_phase</a:documentation>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
        <ref name="vtu_input_format"/>
        <ref name="comment"/>
      </element>
    </choice>
  </define>
  <define name="input_choice_real_contents">
    <choice>
      <element name="constant">
        <a:documentation>Constant value</a:documentation>
        <ref name="real"/>
      </element>
      <element name="python">
        <a:documentation>Python function prescribing real input. Functions should be of the form:

 def val(X, t):
    # Function code
    return # Return value

where X is a tuple of length geometry dimension.</a:documentation>
        <ref name="python_code"/>
      </element>
    </choice>
  </define>
  <!-- Choice of input method, e.g. for boundary conditions -->
  <define name="input_choice_real_dim_vector">
    <ref name="input_choice_real_dim_vector_contents"/>
  </define>
  <!-- Choice of input method, e.g. for prescribed fields -->
  <define name="input_choice_real_dim_vector_plus_file">
    <choice>
      <ref name="input_choice_real_dim_vector_contents"/>
      <element name="from_file">
        <a:documentation>Initialise the field from an existing file (indended primarily for picking up prescribed fields from previously run prognostic simulations). The file mesh must match the mesh of this field (except for piecewise constant fields which will be remapped back from the discontinuous nodal values).

THIS WILL NOT WORK FOR PRESCRIBED FIELDS NOT DIRECTLY UNDERNEATH /material_phase</a:documentation>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
        <ref name="vtu_input_format"/>
        <ref name="comment"/>
      </element>
    </choice>
  </define>
  <define name="input_choice_real_dim_vector_contents">
    <choice>
      <element name="constant">
        <a:documentation>Constant value</a:documentation>
        <ref name="real_dim_vector"/>
      </element>
      <element name="python">
        <a:documentation>Python function prescribing dimensional vector input. Functions should be of the form:

 def val(X, t):
    # Function code
    return # Return value

where X and the return value are tuples of length geometry dimension.</a:documentation>
        <ref name="python_code"/>
      </element>
    </choice>
  </define>
  <!--
    Choice of input method, e.g. for boundary conditions
    this one specifies a vector field of dim minus one
  -->
  <define name="input_choice_real_dim_minus_one_vector">
    <choice>
      <element name="constant">
        <a:documentation>Constant value</a:documentation>
        <ref name="real_dim_minus_one_vector"/>
      </element>
      <element name="python">
        <a:documentation>Python function prescribing dimensional vector input. Functions should be of the form:

 def val(X, t):
    # Function code
    return # Return value

where X and the return value are tuples of length geometry dimension.</a:documentation>
        <ref name="python_code"/>
      </element>
    </choice>
  </define>
  <define name="input_choice_netcdf">
    <a:documentation>Import data from NetCDF CF-1.x file.</a:documentation>
    <element name="from_file">
      <attribute name="file_name">
        <a:documentation>The format of this file should conform to NetCDF CF 1.x
(http://cf-pcmdi.llnl.gov/)</a:documentation>
        <data type="string"/>
      </attribute>
      <ref name="comment"/>
    </element>
  </define>
  <!--
    Choice of input method for initial conditions
    Note: combine = "choice" should be used here to combine with input_choice_real, but Diamond doesn't support it
  -->
  <define name="input_choice_initial_condition_vector">
    <choice>
      <element name="constant">
        <a:documentation>Constant value</a:documentation>
        <ref name="real_dim_vector"/>
      </element>
      <element name="python">
        <a:documentation>Python function prescribing dimensional vector input. Functions should be of the form:

 def val(X, t):
    # Function code
    return # Return value

where X and the return value are tuples of length geometry dimension.</a:documentation>
        <ref name="python_code"/>
      </element>
      <element name="from_file">
        <a:documentation>Initialise the field from an existing file (indended primarily for use in checkpointing). The file mesh must match the mesh of this field (except for piecewise constant fields which will be remapped back from the discontinuous nodal values).</a:documentation>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
        <ref name="vtu_input_format"/>
        <ref name="comment"/>
      </element>
      <element name="balanced">
        <a:documentation>Set balanced velocity from height field</a:documentation>
        <optional>
          <element name="solver">
            <a:documentation>Solver</a:documentation>
            <ref name="linear_solver_options_sym"/>
          </element>
        </optional>
        <optional>
          <choice>
            <element name="streamfunction_projection">
              <empty/>
            </element>
            <element name="elliptic_solver">
              <empty/>
            </element>
          </choice>
        </optional>
      </element>
      <element name="from_streamfunction">
        <a:documentation>Set velocity from streamfunction</a:documentation>
        <empty/>
      </element>
      <element name="galerkin_projection">
        <a:documentation>Set velocity from galerkin projection</a:documentation>
        <element name="python">
          <a:documentation>Vector field to be evaluated at quadrature points
Python function prescribing dimensional vector input. Functions should be of the form:

 def val(X, t):
    # Function code
    return # Return value</a:documentation>
          <ref name="python_code"/>
        </element>
      </element>
    </choice>
  </define>
  <!--
    Choice of input method for initial/boundary conditions
    version for real symmetric tensor
  -->
  <define name="input_choice_real_dim_symmetric_tensor">
    <choice>
      <element name="constant">
        <a:documentation>Constant symmetric tensor</a:documentation>
        <ref name="real_dim_symmetric_tensor"/>
      </element>
      <element name="python">
        <a:documentation>Python command prescribing symmetric tensor input.

Note that it is for the python function to determine 
that the results it produces are, in fact, symmetric.

An example that returns the three-dimensional identity:

 def val(X, t):
   return [[1, 0, 0],
               [0, 1, 0],
               [0, 0, 1]]</a:documentation>
        <ref name="python_code"/>
      </element>
    </choice>
  </define>
  <!--
    Choice of input method for initial/boundary conditions
    version for real tensor
  -->
  <define name="input_choice_real_dim_tensor">
    <choice>
      <element name="constant">
        <a:documentation>Constant tensor</a:documentation>
        <ref name="real_dim_tensor"/>
      </element>
      <element name="python">
        <a:documentation>Python command prescribing tensor input.

An example that returns the three-dimensional identity:

 def val(X, t):
   return [[1, 0, 0],
               [0, 1, 0],
               [0, 0, 1]]</a:documentation>
        <ref name="python_code"/>
      </element>
    </choice>
  </define>
  <define name="prognostic_sw_velocity_field">
    <ref name="velocity_equation_choice"/>
    <element name="wave_equation">
      <choice>
        <element name="just_wave_equation_step">
          <a:documentation>Only solve the linear equations</a:documentation>
          <empty/>
        </element>
        <element name="no_wave_equation_step">
          <a:documentation>Leave out the wave equation step</a:documentation>
          <empty/>
        </element>
        <element name="fully_coupled">
          <a:documentation>Solve the fully coupled equations</a:documentation>
          <optional>
            <element name="linear_debug">
              <a:documentation>Use the linear residuals anyway</a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
      </choice>
    </element>
    <element name="spatial_discretisation">
      <a:documentation>Spatial discretisation options</a:documentation>
      <element name="discontinuous_galerkin">
        <a:documentation>Discontinuous galerkin formulation.</a:documentation>
        <optional>
          <element name="advection_scheme">
            <a:documentation>Options for the wave equation solver</a:documentation>
            <choice>
              <element name="edge_coordinates_upwind">
                <a:documentation>Upwinding using the coordinate system consisting
of the edge tangential and normal components of
the nonlinear velocity.</a:documentation>
                <empty/>
              </element>
              <element name="sphere_coordinates_upwind">
                <a:documentation>Upwinding using the sphere coordinate system
where one tangent vector is orthogonal to the
(0,0,1) vector.</a:documentation>
                <empty/>
              </element>
              <element name="none">
                <a:documentation>Disable advection</a:documentation>
                <empty/>
              </element>
            </choice>
          </element>
        </optional>
        <optional>
          <element name="slope_limiter">
            <empty>
              <a:documentation>If present the vertex based slope limiter (the only one that works!) will be used.</a:documentation>
            </empty>
          </element>
        </optional>
      </element>
    </element>
    <element name="temporal_discretisation">
      <a:documentation>Temporal discretisation options</a:documentation>
      <optional>
        <element name="relaxation">
          <a:documentation>Non-linear relaxation term
 = 0  -- previous timestep velocity solution used in non-linear terms of momentum equations
 = 1  -- previous iteration velocity solution used in non-linear terms of momentum equations
 0 &lt;= ITHETA &lt;= 1</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
      <optional>
        <element name="discontinuous_galerkin">
          <choice>
            <element name="maximum_courant_number_per_subcycle">
              <a:documentation>Use timestep subcycling to solve this equation.
Specify the maximum courant number per subcycle.</a:documentation>
              <ref name="real"/>
            </element>
            <element name="number_advection_subcycles">
              <a:documentation>Use timestep subcycling to solve this equation.
Specify the number of subcycles.</a:documentation>
              <ref name="integer"/>
            </element>
          </choice>
        </element>
      </optional>
    </element>
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options_asym"/>
    </element>
    <oneOrMore>
      <choice>
        <element name="initial_condition">
          <a:documentation>Initial condition for WholeMesh

Only specify one condition if not using mesh regions.
Otherwise select other initial_condition option, specify region_ids
and distinct names.  Then add extra intial conditions for other regions.</a:documentation>
          <attribute name="name">
            <value>WholeMesh</value>
          </attribute>
          <ref name="input_choice_initial_condition_vector"/>
        </element>
        <element name="initial_condition">
          <a:documentation>Multiple initial_conditions are allowed if specifying
different values in different
regions of the mesh (defined by region_ids).  In this case
each initial_condition
requires a distinct name for the options dictionary.</a:documentation>
          <attribute name="name">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <optional>
            <ref name="region_ids"/>
          </optional>
          <ref name="input_choice_initial_condition_vector"/>
        </element>
      </choice>
    </oneOrMore>
    <zeroOrMore>
      <element name="prescribed_region">
        <a:documentation>Prescribed different regions of the field</a:documentation>
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
        <ref name="region_ids"/>
        <ref name="input_choice_initial_condition_vector"/>
      </element>
    </zeroOrMore>
    <optional>
      <element name="vector_field">
        <a:documentation>Source</a:documentation>
        <attribute name="name">
          <value>Source</value>
        </attribute>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <optional>
              <ref name="mesh_choice"/>
            </optional>
            <ref name="prescribed_vector_field_no_adapt"/>
          </element>
          <element name="diagnostic">
            <optional>
              <ref name="mesh_choice"/>
            </optional>
            <choice>
              <ref name="vector_python_diagnostic_algorithm"/>
              <ref name="internal_velocity_source_algorithm"/>
            </choice>
            <ref name="diagnostic_vector_field"/>
          </element>
        </choice>
        <optional>
          <element name="lump_source">
            <empty/>
          </element>
        </optional>
      </element>
    </optional>
    <ref name="prognostic_vector_output_options"/>
    <ref name="prognostic_vector_stat_options"/>
  </define>
  <define name="prognostic_layerthickness_field">
    <element name="spatial_discretisation">
      <a:documentation>Spatial discretisation options</a:documentation>
      <element name="discontinuous_galerkin">
        <a:documentation>Discontinuous Galerkin formulation.</a:documentation>
        <optional>
          <a:documentation>Discretisation options for the advection terms.
use a slope limiter for advection</a:documentation>
          <element name="slope_limiter">
            <attribute name="name">
              <value>Vertex_Based</value>
            </attribute>
          </element>
        </optional>
        <ref name="comment"/>
      </element>
      <element name="conservative_advection">
        <a:documentation>Conservative discretisation of field advection equation
 TBETA=1. -- conservative (divergence form)
 TBETA=0. -- non-conservative
 0. &lt; TBETA &lt; 1.</a:documentation>
        <ref name="real"/>
      </element>
      <optional>
        <element name="debug">
          <empty/>
        </element>
      </optional>
    </element>
    <element name="temporal_discretisation">
      <a:documentation>Temporal discretisation options</a:documentation>
      <element name="discontinuous_galerkin">
        <a:documentation>This enables DG-specific timestepping options, such as
explicit advection subcycling. </a:documentation>
        <element name="number_advection_subcycles">
          <a:documentation>Use timestep subcycling to solve this equation.
Specify the number of subcycles.</a:documentation>
          <ref name="integer"/>
        </element>
        <element name="SSPRK_order">
          <a:documentation>Choose the order of an explicit SSPRK method.
Order 1 is unstable for P1, 
Order 2 is unstable for P2.
Recommended value: 3</a:documentation>
          <ref name="integer"/>
        </element>
      </element>
    </element>
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options_asym"/>
    </element>
    <choice>
      <element name="initial_condition">
        <a:documentation>Initial condition for WholeMesh

Only specify one condition if not using mesh regions.
Otherwise select other initial_condition option, specify region_ids
and distinct names.  Then add extra intial conditions for other regions.</a:documentation>
        <attribute name="name">
          <value>WholeMesh</value>
        </attribute>
        <ref name="input_choice_initial_condition_real"/>
      </element>
      <element name="initial_condition">
        <a:documentation>Multiple initial_conditions are allowed if specifying
different values in different
regions of the mesh (defined by region_ids).  In this case
each initial_condition
requires a distinct name for the options dictionary.</a:documentation>
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
        <ref name="region_ids"/>
        <ref name="input_choice_initial_condition_real"/>
      </element>
      <element name="initial_condition">
        <a:documentation>Initialise layer thickness by projecting from a field</a:documentation>
        <attribute name="name">
          <value>ProjectionFromPython</value>
        </attribute>
        <element name="python">
          <a:documentation>Field to project from (evaluated at Gauss points)
Python function prescribing dimensional vector input. Functions should be of the form:

 def val(X, t):
    # Function code
    return # Return value

where X and the return value are tuples of length geometry dimension.</a:documentation>
          <ref name="python_code"/>
        </element>
      </element>
    </choice>
    <element name="mean_layer_thickness">
      <a:documentation>Mean value of thickness to use in wave equation solver
Will be replaced by a field in due course</a:documentation>
      <ref name="real"/>
      <choice>
        <element name="reset_field_mean">
          <a:documentation>Add constant to layer field so that
it has mean equal to this value</a:documentation>
          <empty/>
        </element>
        <element name="reset_this_value">
          <a:documentation>Reset this value to mean calculated
from layer field</a:documentation>
          <empty/>
        </element>
      </choice>
    </element>
    <optional>
      <element name="scalar_field">
        <a:documentation>Source</a:documentation>
        <attribute name="name">
          <value>Source</value>
        </attribute>
        <element name="prescribed">
          <ref name="prescribed_scalar_field_no_adapt"/>
        </element>
      </element>
    </optional>
    <ref name="prognostic_scalar_output_options"/>
    <ref name="prognostic_scalar_stat_options"/>
    <ref name="adaptivity_options_prognostic_scalar_field"/>
    <ref name="interpolation_algorithm_scalar"/>
  </define>
  <define name="prognostic_lagrangemultiplier_field">
    <element name="spatial_discretisation">
      <a:documentation>Spatial discretisation options</a:documentation>
      <empty/>
    </element>
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options_asym"/>
    </element>
    <optional>
      <element name="initial_condition">
        <a:documentation>Initial condition is not used for shallow water or Helmholtz 
solves but is required for test_trace_space.</a:documentation>
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
        <ref name="region_ids"/>
        <ref name="input_choice_initial_condition_real"/>
      </element>
    </optional>
    <ref name="prognostic_scalar_output_options"/>
    <ref name="prognostic_scalar_stat_options"/>
    <ref name="adaptivity_options_prognostic_scalar_field"/>
    <ref name="interpolation_algorithm_scalar"/>
  </define>
  <!-- Default child of diagnostic scalar field -->
  <define name="diagnostic_scalar_field">
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_scalar_stat_options"/>
    <ref name="scalar_convergence_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="scalar_steady_state_options"/>
    <ref name="adaptivity_options_scalar_field"/>
    <optional>
      <ref name="recalculation_options"/>
    </optional>
    <ref name="adjoint_storage"/>
  </define>
  <!-- Default child of diagnostic scalar field without adaptivity options -->
  <define name="diagnostic_scalar_field_no_adapt">
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_scalar_stat_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="adjoint_storage"/>
  </define>
  <!-- Default child of diagnostic scalar field -->
  <define name="diagnostic_scalar_field_tidal_range">
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_scalar_stat_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="adaptivity_options_scalar_field"/>
    <element name="spin_up_time">
      <ref name="real"/>
    </element>
    <ref name="adjoint_storage"/>
  </define>
  <!--
    Default child of prescribed scalar field
    This is a choice of ways of inputing the prescribed field
  -->
  <define name="prescribed_scalar_field">
    <ref name="prescribed_scalar_field_no_adapt"/>
    <ref name="adaptivity_options_scalar_field"/>
    <optional>
      <ref name="interpolation_algorithm_scalar"/>
    </optional>
    <optional>
      <ref name="discrete_properties_algorithm_scalar"/>
    </optional>
    <optional>
      <ref name="recalculation_options"/>
    </optional>
  </define>
  <!--
    Default child of prescribed scalar field without adaptivity options
    This is a choice of ways of inputing the prescribed field
  -->
  <define name="prescribed_scalar_field_no_adapt">
    <ref name="prescribed_values_scalar_field"/>
    <ref name="prescribed_output_options"/>
    <ref name="prescribed_scalar_stat_options"/>
    <ref name="prescribed_detector_options"/>
    <ref name="adjoint_storage"/>
  </define>
  <define name="prescribed_values_scalar_field">
    <oneOrMore>
      <choice>
        <element name="value">
          <a:documentation>Value for WholeMesh
Only specify one value if not using mesh regions.
Otherwise select other value option, specify region_ids
and distinct names.  Then add extra values for other regions.</a:documentation>
          <attribute name="name">
            <value>WholeMesh</value>
          </attribute>
          <ref name="input_choice_real_plus_file"/>
        </element>
        <element name="value">
          <a:documentation>Multiple values are now allowed if using different value assignments
in different regions of the mesh (specified by region_ids).
In this case each value requires a distinct name for the options dictionary.</a:documentation>
          <attribute name="name">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <ref name="region_ids"/>
          <ref name="input_choice_real_plus_file"/>
        </element>
      </choice>
    </oneOrMore>
  </define>
  <!--
    Default child of diagnostic vector field
    Currently, this is empty, but in future this might include
    options that are general to all diagnostic vector fields
  -->
  <define name="diagnostic_vector_field">
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_vector_stat_options"/>
    <ref name="vector_convergence_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="vector_steady_state_options"/>
    <ref name="adaptivity_options_vector_field"/>
    <optional>
      <ref name="recalculation_options"/>
    </optional>
    <ref name="adjoint_storage"/>
  </define>
  <define name="diagnostic_vector_field_bed_shear_stress">
    <element name="density">
      <ref name="real"/>
    </element>
    <element name="drag_coefficient">
      <ref name="real"/>
    </element>
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_vector_stat_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="adaptivity_options_vector_field"/>
    <ref name="adjoint_storage"/>
  </define>
  <!--
    Default child of prescribed vector field
    This is a choice of ways of inputing the prescribed field
  -->
  <define name="prescribed_vector_field">
    <ref name="prescribed_vector_field_no_adapt"/>
    <ref name="adaptivity_options_vector_field"/>
    <optional>
      <ref name="interpolation_algorithm_vector"/>
    </optional>
    <optional>
      <ref name="discrete_properties_algorithm_vector"/>
    </optional>
    <optional>
      <ref name="recalculation_options"/>
    </optional>
  </define>
  <!--
    Default child of prescribed vector field without adaptivity options
    This is a choice of ways of inputing the prescribed field
  -->
  <define name="prescribed_vector_field_no_adapt">
    <ref name="prescribed_values_vector_field"/>
    <ref name="prescribed_output_options"/>
    <ref name="prescribed_vector_stat_options"/>
    <ref name="prescribed_detector_options"/>
    <ref name="adjoint_storage"/>
  </define>
  <define name="prescribed_values_vector_field">
    <oneOrMore>
      <choice>
        <element name="value">
          <a:documentation>Value for WholeMesh

Only specify one value if not using mesh regions.
Otherwise select other value option, specify region_ids
and distinct names.  Then add extra values for other regions.</a:documentation>
          <attribute name="name">
            <value>WholeMesh</value>
          </attribute>
          <ref name="input_choice_real_dim_vector_plus_file"/>
        </element>
        <element name="value">
          <a:documentation>Multiple values are now allowed if using different value assignments
in different regions of the mesh (specified by region_ids).
In this case each value requires a distinct name for the options dictionary.</a:documentation>
          <attribute name="name">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <ref name="region_ids"/>
          <ref name="input_choice_real_dim_vector_plus_file"/>
        </element>
      </choice>
    </oneOrMore>
  </define>
  <!--
    Default child of diagnostic tensor field
    Currently, this is empty, but in future this might include
    options that are general to all diagnostic tensor fields
  -->
  <define name="diagnostic_tensor_field">
    <ref name="diagnostic_output_options"/>
    <ref name="adaptivity_options_tensor_field"/>
  </define>
  <!--
    Default child of prescribed vector field
    This is a choice of ways of inputing the prescribed tensor field
    If the field is constant then a symmetric, or asymmetric tensor may be entered
  -->
  <define name="prescribed_tensor_field">
    <ref name="prescribed_values_tensor_field"/>
    <ref name="adaptivity_options_tensor_field"/>
  </define>
  <define name="prescribed_values_tensor_field">
    <oneOrMore>
      <choice>
        <element name="value">
          <a:documentation>Value for WholeMesh

Only specify one value if not using mesh regions.
Otherwise select other value option, specify region_ids
and distinct names.  Then add extra values for other regions.</a:documentation>
          <attribute name="name">
            <value>WholeMesh</value>
          </attribute>
          <ref name="input_choice_tensor_field"/>
        </element>
        <element name="value">
          <a:documentation>Multiple values are now allowed if using different value assignments
in different regions of the mesh (specified by region_ids).
In this case each value requires a distinct name for the options dictionary.</a:documentation>
          <attribute name="name">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <ref name="region_ids"/>
          <ref name="input_choice_tensor_field"/>
        </element>
      </choice>
    </oneOrMore>
  </define>
  <define name="velocity_components_choice">
    <!--
      rotated bcs are not implemented... this is where they should go when they are
              element align_bc_with_surface {
                 element normal_component {
                    input_choice_real
                 }?,
                 element tangent_component_1 {
                    input_choice_real
                 }?,
                 element tangent_component_2 {
                    input_choice_real
                 }?,
                 rotation_matrix_components
              }|
    -->
    <element name="align_bc_with_cartesian">
      <optional>
        <element name="x_component">
          <ref name="input_choice_real_bc_component"/>
        </element>
      </optional>
      <optional>
        <element name="y_component">
          <ref name="input_choice_real_bc_component"/>
        </element>
      </optional>
      <optional>
        <element name="z_component">
          <ref name="input_choice_real_bc_component"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="input_choice_real_bc_component">
    <choice>
      <ref name="input_choice_real"/>
      <element name="synthetic_eddy_method">
        <element name="number_of_eddies">
          <a:documentation>use a large number to ensure Gaussian 
behaviour of the fluctuating component</a:documentation>
          <ref name="integer"/>
        </element>
        <element name="turbulence_lengthscale">
          <ref name="input_choice_real"/>
        </element>
        <element name="mean_profile">
          <a:documentation>mean profile

usually a function of height,
for ABL simulations use a log profile</a:documentation>
          <ref name="input_choice_real"/>
        </element>
        <element name="Re_stresses_profile">
          <a:documentation>Reynolds stresses profile

usually a function of height,
assumes that the remaining stresses are negligible </a:documentation>
          <ref name="input_choice_real"/>
        </element>
      </element>
    </choice>
  </define>
  <!-- and again for robin b.c.s -->
  <define name="robin_velocity_components_choice">
    <!--
              element align_bc_with_surface {
                 element normal_component {
                    element order_zero_coefficient {
                       input_choice_real
                    },
                    element order_one_coefficient {
                       input_choice_real
                    }
                 }?,
                 element tangent_component_1 {
                    element order_zero_coefficient {
                       input_choice_real
                    },
                    element order_one_coefficient {
                       input_choice_real
                    }
                 }?,
                 element tangent_component_2 {
                    element order_zero_coefficient {
                       input_choice_real
                    },
                    element order_one_coefficient {
                       input_choice_real
                    }
                 }?,
                 rotation_matrix_components
              }|
    -->
    <element name="align_bc_with_cartesian">
      <optional>
        <element name="x_component">
          <element name="order_zero_coefficient">
            <ref name="input_choice_real"/>
          </element>
          <element name="order_one_coefficient">
            <ref name="input_choice_real"/>
          </element>
        </element>
      </optional>
      <optional>
        <element name="y_component">
          <element name="order_zero_coefficient">
            <ref name="input_choice_real"/>
          </element>
          <element name="order_one_coefficient">
            <ref name="input_choice_real"/>
          </element>
        </element>
      </optional>
      <optional>
        <element name="z_component">
          <element name="order_zero_coefficient">
            <ref name="input_choice_real"/>
          </element>
          <element name="order_one_coefficient">
            <ref name="input_choice_real"/>
          </element>
        </element>
      </optional>
    </element>
  </define>
  <define name="velocity_boundary_conditions">
    <choice>
      <element name="type">
        <attribute name="name">
          <value>dirichlet</value>
        </attribute>
        <optional>
          <element name="apply_weakly">
            <a:documentation>Apply the dirichlet bc weakly.  Available automatically
with a discontinuous_galerkin Velocity
spatial_discretisation.  Available if you
integrate_continuity_by_parts with a
continuous_galerkin Pressure or use a control_volume
Pressure spatial_discretisation and/or
integrate_advection_by_parts under Velocity
spatial_discretisation with continuous_galerkin.

If not selected boundary conditions are applied strongly.</a:documentation>
            <optional>
              <element name="boundary_overwrites_initial_condition">
                <a:documentation>If the initial condition and boundary conditions
differ, setting this option will cause the initial
condition on the boundary to be overwritten with
the boundary condition. Since you are applying the
boundary condition weakly, you probably do *not*
want this.</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
        </optional>
        <ref name="velocity_components_choice"/>
      </element>
      <element name="type">
        <attribute name="name">
          <value>neumann</value>
        </attribute>
        <ref name="velocity_components_choice"/>
      </element>
      <element name="type">
        <attribute name="name">
          <value>robin</value>
        </attribute>
        <ref name="robin_velocity_components_choice"/>
      </element>
      <element name="type">
        <attribute name="name">
          <value>free_surface</value>
        </attribute>
      </element>
      <element name="type">
        <a:documentation>Apply quadratic drag. Specify drag coefficient. If you
want to exactly replicate results from using the OCEDRA
option, set this to 0.003 and remember to apply to both
bottom and sides.</a:documentation>
        <attribute name="name">
          <value>drag</value>
        </attribute>
        <ref name="input_choice_real"/>
        <choice>
          <element name="quadratic_drag">
            <a:documentation>Use a quadratic drag.

This means that the drag coefficient is nondimensional.</a:documentation>
            <empty/>
          </element>
          <element name="linear_drag">
            <a:documentation>Use a linear drag (basically just a surface absorption term).

This means that the drag coefficient has units of momentum.</a:documentation>
            <empty/>
          </element>
        </choice>
      </element>
      <element name="type">
        <a:documentation>Apply wind forcing specified by stress or wind velocity.
Replaces windy.dat and windy.py</a:documentation>
        <attribute name="name">
          <value>wind_forcing</value>
        </attribute>
        <choice>
          <element name="wind_stress">
            <a:documentation>Wind forcing with user specified wind stress

&lt;b&gt; Note that the stress needs to be specified
using the same density units as the reference_density 
under equation of state.&lt;/b&gt;So if you use the recommended
non-dimensional value of 1.0 for reference_density and
your calculated stress is in kg m^-1s^-2 and the dimensional
reference_density is 1000.0 kg m^-3, you need to divide
the calculated stress in SI units by 1000.0.</a:documentation>
            <choice>
              <ref name="input_choice_real_dim_minus_one_vector"/>
              <element name="from_netcdf">
                <attribute name="file_name">
                  <a:documentation>The format of this file should conform to NetCDF CF 1.x
(http://cf-pcmdi.llnl.gov/).</a:documentation>
                  <data type="string"/>
                </attribute>
                <attribute name="east_west">
                  <data type="string"/>
                </attribute>
                <attribute name="north_south">
                  <data type="string"/>
                </attribute>
                <ref name="comment"/>
              </element>
            </choice>
          </element>
          <element name="wind_velocity">
            <a:documentation>Wind forcing with user specified 10m wind velocity</a:documentation>
            <element name="wind_drag_coefficient">
              <a:documentation>Specify wind drag coefficient (dimensionless)
Suggested value: 4.0e-4</a:documentation>
              <ref name="input_choice_real"/>
            </element>
            <element name="density_air">
              <a:documentation>Density of air. 

&lt;b&gt;Note that you have to specify
this density in the same units as the 
reference_density under equation of state.&lt;/b&gt;
So with a typicial value of rho_air=1.3 kgm^-3
and rho_water=1000 kgm^-3, if you fill in the 
recommended (non-dimensional) value of 1.0 for 
reference_density, this field needs to be 1.3e-3.</a:documentation>
              <ref name="real"/>
            </element>
            <element name="wind_velocity">
              <a:documentation>Specify wind velocity</a:documentation>
              <choice>
                <ref name="input_choice_real_dim_minus_one_vector"/>
                <element name="from_netcdf">
                  <attribute name="file_name">
                    <a:documentation>The format of this file should conform to NetCDF CF 1.x
(http://cf-pcmdi.llnl.gov/)</a:documentation>
                    <data type="string"/>
                  </attribute>
                  <attribute name="east_west">
                    <data type="string"/>
                  </attribute>
                  <attribute name="north_south">
                    <data type="string"/>
                  </attribute>
                  <ref name="comment"/>
                </element>
              </choice>
            </element>
          </element>
        </choice>
      </element>
      <element name="type">
        <a:documentation>When using control_volumes under Pressure
spatial_discretisation or when using
integrate_continuity_by_parts with continuous_galerkin
Pressure and continuous_galerkin Velocity this
boundary condition type imposes a weak no normal flow
boundary condition on the surface_ids specified.</a:documentation>
        <attribute name="name">
          <value>no_normal_flow</value>
        </attribute>
        <empty/>
      </element>
      <element name="type">
        <a:documentation>Implements a penalty function for the near wall region.
Using this option coarse meshes can
be used in the near wall region.

Should be used in combination with a no_normal_flow condition. 

See Bazilevs et al. 2007</a:documentation>
        <attribute name="name">
          <value>near_wall_treatment</value>
        </attribute>
        <element name="tolerance">
          <ref name="real"/>
        </element>
      </element>
      <element name="type">
        <a:documentation>Log law of the wall

Should be used in combination with a no_normal_flow condition. </a:documentation>
        <attribute name="name">
          <value>log_law_of_wall</value>
        </attribute>
        <element name="surface_roughness">
          <ref name="real"/>
        </element>
      </element>
    </choice>
  </define>
  <!-- Output options for prognostic fields -->
  <define name="prognostic_scalar_output_options">
    <element name="output">
      <a:documentation>Specify what is written to vtu dump files</a:documentation>
      <optional>
        <element name="exclude_from_vtu">
          <a:documentation>By default each field in the options file is written to vtu.
Select this option to exclude this field.</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="include_previous_time_step">
          <a:documentation>Select this option to also write the values of this field
on the previous timestep.
(included under the name: Old&lt;field_name&gt; )</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="include_nonlinear_field">
          <a:documentation>Select this option to also write the values of this field
used in the nonlinear iteration.
(included under the name: Nonlinear&lt;field_name&gt; )</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="convergence_file">
          <a:documentation>Output a file details the convergence (or otherwise) of
this field with every advective nonlinear
iteration.
ONLY WORKS FOR PURE CONTROL VOLUME DISCRETISATIONS.</a:documentation>
          <ref name="comment"/>
        </element>
      </optional>
    </element>
  </define>
  <!-- Output options for pressure (can't have a convergence file) -->
  <define name="pressure_output_options">
    <element name="output">
      <a:documentation>Specify what is written to vtu dump files</a:documentation>
      <optional>
        <element name="exclude_from_vtu">
          <a:documentation>By default each field in the options file is written to vtu.
Select this option to exclude this field.</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="include_previous_time_step">
          <a:documentation>Select this option to also write the values of this field
on the previous timestep.
(included under the name: Old&lt;field_name&gt; )</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="include_nonlinear_field">
          <a:documentation>Select this option to also write the values of this field
used in the nonlinear iteration.
(included under the name: Nonlinear&lt;field_name&gt; )</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="debugging_vtus">
          <a:documentation>Write out some extra debugging vtu files that can be used
to analyse what goes on in the pressure projection steps.
WARNING: this may create a huge amount of vtu files, as 
multiple files are written per nonlinear iteration.</a:documentation>
          <empty/>
        </element>
      </optional>
    </element>
  </define>
  <!-- Output options for prognostic fields -->
  <define name="prognostic_vector_output_options">
    <element name="output">
      <a:documentation>Specify what is written to vtu dump files</a:documentation>
      <optional>
        <element name="exclude_from_vtu">
          <a:documentation>By default each field in the options file is written to vtu.
Select this option to exclude this field.</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="include_previous_time_step">
          <a:documentation>Select this option to also write the values of this field
on the previous timestep.
(included under the name: Old&lt;field_name&gt; )</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="include_nonlinear_field">
          <a:documentation>Select this option to also write the values of this field
used in the nonlinear iteration.
(included under the name: Nonlinear&lt;field_name&gt; )</a:documentation>
          <empty/>
        </element>
      </optional>
    </element>
  </define>
  <!-- Output options for all other fields -->
  <define name="field_output_options">
    <element name="output">
      <a:documentation>Specify what is written to vtu dump files</a:documentation>
      <optional>
        <element name="exclude_from_vtu">
          <a:documentation>By default each field in the options file is written to vtu.
Select this option to exclude this field.</a:documentation>
          <empty/>
        </element>
      </optional>
    </element>
  </define>
  <define name="diagnostic_output_options">
    <ref name="field_output_options"/>
  </define>
  <define name="prescribed_output_options">
    <ref name="field_output_options"/>
  </define>
  <!--
    Options for inclusion/exclusion of standard field statistics from the .stat
    file
  -->
  <define name="include_stat">
    <element name="include_in_stat">
      <a:documentation>Include this field in the .stat file (magnitude and components)</a:documentation>
      <ref name="comment"/>
    </element>
  </define>
  <define name="exclude_components_from_stat">
    <element name="exclude_components_from_stat">
      <a:documentation>Include just the magnitude of this field in the .stat file
(excluding the components)</a:documentation>
      <ref name="comment"/>
    </element>
  </define>
  <define name="exclude_stat">
    <element name="exclude_from_stat">
      <a:documentation>Exclude this field from the .stat file.</a:documentation>
      <ref name="comment"/>
    </element>
  </define>
  <!-- Diagnostic statistics options for prognostic scalar fields -->
  <define name="prognostic_scalar_stat_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <element name="manifold_transformation">
        <empty/>
      </element>
      <ref name="prognostic_scalar_stat_options.stat"/>
    </element>
  </define>
  <!-- Diagnostic statistics for all other scalar fields -->
  <define name="prognostic_scalar_stat_no_old_or_nonlinear_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <element name="manifold_transformation">
        <empty/>
      </element>
      <ref name="prognostic_scalar_stat_no_old_or_nonlinear_options.stat"/>
    </element>
  </define>
  <define name="diagnostic_scalar_stat_options">
    <ref name="prognostic_scalar_stat_no_old_or_nonlinear_options"/>
  </define>
  <define name="prescribed_scalar_stat_options">
    <ref name="prognostic_scalar_stat_no_old_or_nonlinear_options"/>
  </define>
  <!-- Combining of stat elements for scalar fields -->
  <define name="prognostic_scalar_stat_options.stat">
    <ref name="prognostic_scalar_stat_no_old_or_nonlinear_options.stat"/>
  </define>
  <define name="prognostic_scalar_stat_options.stat" combine="interleave">
    <optional>
      <element name="include_previous_time_step">
        <a:documentation>Enable to include the previous timestep value of this field in the .stat file.</a:documentation>
        <ref name="comment"/>
      </element>
    </optional>
    <optional>
      <element name="include_nonlinear_field">
        <a:documentation>Enable to include the values of this field in the nonlinear
iteration in the .stat file.</a:documentation>
        <ref name="comment"/>
      </element>
    </optional>
  </define>
  <define name="prognostic_scalar_stat_no_old_or_nonlinear_options.stat">
    <optional>
      <ref name="exclude_stat"/>
    </optional>
    <optional>
      <ref name="cv_stats"/>
    </optional>
    <zeroOrMore>
      <ref name="surface_integral_stats_scalar"/>
    </zeroOrMore>
    <zeroOrMore>
      <ref name="mixing_stats"/>
    </zeroOrMore>
  </define>
  <!-- Diagnostic statistics options for vector fields, with enabled by default -->
  <define name="vector_field_stat_options_enabled_default">
    <ref name="include_stat"/>
  </define>
  <define name="vector_field_stat_options_enabled_default" combine="choice">
    <ref name="exclude_components_from_stat"/>
  </define>
  <define name="vector_field_stat_options_enabled_default" combine="choice">
    <ref name="exclude_stat"/>
  </define>
  <!-- Diagnostic statistics options for vector fields, with enabled by default -->
  <define name="vector_field_stat_options_disabled_default">
    <ref name="exclude_stat"/>
  </define>
  <define name="vector_field_stat_options_disabled_default" combine="choice">
    <ref name="exclude_components_from_stat"/>
  </define>
  <define name="vector_field_stat_options_disabled_default" combine="choice">
    <ref name="include_stat"/>
  </define>
  <!-- Diagnostic statistics for prognostic vector fields -->
  <define name="prognostic_vector_stat_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <element name="manifold_transformation">
        <empty/>
      </element>
      <ref name="prognostic_vector_stat_options.stat"/>
    </element>
  </define>
  <!-- Diagnostic statistics for all other vector fields -->
  <define name="prognostic_vector_stat_no_old_or_nonlinear_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <element name="manifold_transformation">
        <empty/>
      </element>
      <ref name="prognostic_vector_stat_no_old_or_nonlinear_options.stat"/>
    </element>
  </define>
  <define name="diagnostic_vector_stat_options">
    <ref name="prognostic_vector_stat_no_old_or_nonlinear_options"/>
  </define>
  <define name="prescribed_vector_stat_options">
    <ref name="prognostic_vector_stat_no_old_or_nonlinear_options"/>
  </define>
  <!-- Combining of stat elements for vector fields -->
  <define name="prognostic_vector_stat_options.stat">
    <ref name="prognostic_vector_stat_no_old_or_nonlinear_options.stat"/>
  </define>
  <define name="prognostic_vector_stat_options.stat" combine="interleave">
    <element name="previous_time_step">
      <a:documentation>Specify how the previous timestep value of this field is added to the .stat file.</a:documentation>
      <ref name="vector_field_stat_options_disabled_default"/>
    </element>
    <element name="nonlinear_field">
      <a:documentation>Specify how the values of this field used in the nonlinear iteration are added to the .stat file.</a:documentation>
      <ref name="vector_field_stat_options_disabled_default"/>
    </element>
    <optional>
      <element name="compute_body_forces_on_surfaces">
        <a:documentation>What surface IDs do you want to do the calculation over?</a:documentation>
        <ref name="integer_vector"/>
      </element>
    </optional>
  </define>
  <define name="prognostic_vector_stat_no_old_or_nonlinear_options.stat">
    <ref name="vector_field_stat_options_enabled_default"/>
    <zeroOrMore>
      <ref name="surface_integral_stats_vector"/>
    </zeroOrMore>
  </define>
  <!-- Convergence options for prognostic scalar fields -->
  <define name="scalar_convergence_options">
    <element name="convergence">
      <a:documentation>Decide whether this field is tested for convergence
during nonlinear iterations
(if /timestepping/nonlinear_iterations and
/timestepping/nonlinear_iterations/tolerance are
enabled).
Also specifies whether the field is added to the 
convergence file (if /io/convergence_file is enabled).</a:documentation>
      <choice>
        <element name="include_in_convergence">
          <a:documentation>Include this field in convergence testing
(if /timestepping/nonlinear_iterations and
/timestepping/nonlinear_iterations/tolerance are
enabled) and file (if /io/convergence_file is enabled)</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_from_convergence">
          <a:documentation>Exclude this field from convergence testing and file </a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!-- Convergence statistics options for prognostic vector fields (velocity) -->
  <define name="vector_convergence_options">
    <element name="convergence">
      <a:documentation>Decide whether this field is tested for convergence
during nonlinear iterations
(if /timestepping/nonlinear_iterations and
/timestepping/nonlinear_iterations/tolerance are
enabled).
Also specifies whether the field is added to the 
convergence file (if /io/convergence_file is enabled).</a:documentation>
      <choice>
        <element name="include_in_convergence">
          <a:documentation>Include this field (magnitude and components)
in convergence testing
(if /timestepping/nonlinear_iterations and
/timestepping/nonlinear_iterations/tolerance are
enabled) and file (if /io/convergence_file is enabled)</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_components_from_convergence">
          <a:documentation>Include just the magnitude of this field 
in convergence testing
(if /timestepping/nonlinear_iterations and
/timestepping/nonlinear_iterations/tolerance are
enabled) and file (if /io/convergence_file is enabled)
i.e. excluding the components</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_from_convergence">
          <a:documentation>Exclude this field entirely from convergence testing and file </a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!-- Steady state options for prognostic scalar fields -->
  <define name="scalar_steady_state_options">
    <element name="steady_state">
      <a:documentation>Decide whether this field is tested for a steady state
between timesteps
(if /timestepping/steady_state is
enabled).</a:documentation>
      <choice>
        <element name="include_in_steady_state">
          <a:documentation>Include this field in steady state testing
(if /timestepping/steady_state is
enabled)</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_from_steady_state">
          <a:documentation>Exclude this field from steady state testing</a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!-- Steady state statistics options for prognostic vector fields (velocity) -->
  <define name="vector_steady_state_options">
    <element name="steady_state">
      <a:documentation>Decide whether this field is tested for a steady state
between timesteps
(if /timestepping/steady_state is
enabled).</a:documentation>
      <choice>
        <element name="include_in_steady_state">
          <a:documentation>Include this field (magnitude and components)
in steady state testing
(if /timestepping/steady_state is enabled)</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_components_from_steady_state">
          <a:documentation>Include just the magnitude of this field 
in steady state testing
(if /timestepping/steady_state is
enabled)
i.e. excluding the components</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_from_steady_state">
          <a:documentation>Exclude this field entirely from convergence testing and file </a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!-- Options for whether a field is to be included in detector output. -->
  <define name="detector_options_enabled_default">
    <element name="detectors">
      <a:documentation>Specify what is added to detector files</a:documentation>
      <choice>
        <element name="include_in_detectors">
          <a:documentation>This field is output at each detector location.</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_from_detectors">
          <a:documentation>This field is not output at detector locations.</a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!-- Options for whether a field is to be included in detector output. -->
  <define name="detector_options_disabled_default">
    <element name="detectors">
      <a:documentation>Specify what is added to detector files</a:documentation>
      <choice>
        <element name="exclude_from_detectors">
          <a:documentation>This field is not output at detector locations.</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="include_in_detectors">
          <a:documentation>This field is output at each detector location.</a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!--
    Detector output defaults on for prognostic and diagnostic fields, 
    off for prescribed.
  -->
  <define name="prognostic_detector_options">
    <ref name="detector_options_enabled_default"/>
  </define>
  <define name="diagnostic_detector_options">
    <ref name="detector_options_enabled_default"/>
  </define>
  <define name="prescribed_detector_options">
    <ref name="detector_options_disabled_default"/>
  </define>
  <define name="adaptivity_preprocessing">
    <optional>
      <element name="preprocessing">
        <a:documentation>Occasionally, it is desirable to apply operations or filters
to fields before using them for the purposes of adaptivity.</a:documentation>
        <element name="helmholtz_smoother">
          <a:documentation>Invert a helmholtz operator to smooth out the field
before using it to adapt. This can help with noisy
fields.</a:documentation>
          <element name="smoothing_length_scale">
            <ref name="real_dim_symmetric_tensor"/>
          </element>
          <element name="solver">
            <ref name="linear_solver_options_sym"/>
          </element>
        </element>
      </element>
    </optional>
  </define>
  <define name="generic_aliased_field">
    <attribute name="material_phase_name">
      <data type="string"/>
    </attribute>
    <attribute name="field_name">
      <data type="string"/>
    </attribute>
  </define>
  <!-- Most common mesh choices -->
  <define name="mesh_choice">
    <choice>
      <element name="mesh">
        <attribute name="name">
          <data type="string"/>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>CoordinateMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>VelocityMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>PressureMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>VorticityMesh</value>
        </attribute>
      </element>
    </choice>
  </define>
  <!--
    Not really a choice, for fields that have to be on the velocity mesh
    currently that's all scalar fields, except pressure
    and of course velocity itself
    If you want to implement scalar fields on other meshes, feel free to do so
    but bare in mind you need to make sure the field stays outside RMEM.
    Currently all scalar fields are packed in RMEM with length nonods
  -->
  <define name="velocity_mesh_choice">
    <choice>
      <element name="mesh">
        <attribute name="name">
          <value>VelocityMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>PressureMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>CoordinateMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
      </element>
    </choice>
  </define>
  <define name="pressure_mesh_choice">
    <choice>
      <element name="mesh">
        <attribute name="name">
          <value>PressureMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>VelocityMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>CoordinateMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
      </element>
    </choice>
  </define>
  <define name="vorticity_mesh_choice">
    <choice>
      <element name="mesh">
        <attribute name="name">
          <value>VorticityMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>PressureMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>VelocityMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>CoordinateMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
      </element>
    </choice>
  </define>
  <!-- This is the choice of additional scalar field to be solved for -->
  <define name="scalar_field_choice">
    <!--
      The first is a generic field, which may be used for any user-defined field
      that FLUIDITY knows nothing about, or a generic diagnostic
    -->
    <choice>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <choice>
          <a:documentation>Field type</a:documentation>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="diagnostic">
            <ref name="scalar_diagnostic_algorithms"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="___Prognostic_Fields_Below___">
        <a:documentation>Prognostic scalar fields below this</a:documentation>
        <empty/>
      </element>
      <!--
        This is the long list of fields that shallow_water knows about
        - - First is a list of fields that are primarily prognostic,
           but can be set to prescribed, or aliased...
        - - The list is in order of most frequently used.
      -->
      <element name="scalar_field">
        <a:documentation>Passive Tracer</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Tracer</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <!--
        Insert new prognostic scalar fields here using the template:
               element scalar_field {
                   attribute rank { "0" },
                   attribute name { "NewFieldName" },
                   (
                      element prognostic {
                         velocity_mesh_choice,
                         prognostic_scalar_field
                      }|
                      element prescribed {
                         velocity_mesh_choice,
                         prescribed_scalar_field
                      }|
                      element aliased {
                         generic_aliased_field
                      }
                   )
               }
      -->
      <!--
        - - Second is a list of fields that are primarily prescribed,
           but can be aliased. An example is wind velocity.
        - - The list is in order of most frequently used.
      -->
      <element name="___Prescribed_fields_below___">
        <a:documentation>Prescribed scalar fields below this</a:documentation>
        <empty/>
      </element>
      <element name="scalar_field">
        <a:documentation>Prescribed vector field from commuting projection</a:documentation>
        <attribute name="name">
          <value>PrescribedLayerDepthFromProjection</value>
        </attribute>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <element name="prescribed">
          <ref name="pressure_mesh_choice"/>
          <element name="python">
            <a:documentation>Field to project from (evaluated at Gauss points)
Python function prescribing dimensional vector input. Functions should be of the form:

 def val(X, t):
    # Function code
    return # Return value

where X and the return value are tuples of length geometry dimension.</a:documentation>
            <ref name="python_code"/>
          </element>
          <ref name="prescribed_output_options"/>
          <ref name="prescribed_scalar_stat_options"/>
        </element>
      </element>
      <!--
        
        Insert new prescribed scalar fields here using the template:
               element scalar_field {
                   attribute rank { "0" },
                   attribute name { "NewFieldName" },
                   (
                      element prescribed {
                         velocity_mesh_choice,
                         prescribed_scalar_field
                      }|
                      element aliased {
                         generic_aliased_field
                      }
                   )
               }
        
        - - Last is a list of fields that are primarily diagnostic,
           but can be aliased. An example is Tidal Range.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Diagnostic_Fields_Below___">
        <a:documentation>Diagnostic scalar fields below this</a:documentation>
        <empty/>
      </element>
      <element name="scalar_field">
        <a:documentation>CFLNumber

See http://amcg.ese.ic.ac.uk/index.php?title=Local:Diagnostics#CFL_Number

Adapting to this field is not recommended</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>CFLNumber</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>ControlVolumeCFLNumber

Courant Number as defined on a control volume mesh

Adapting to this field is not recommended</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ControlVolumeCFLNumber</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>DG_CourantNumber

Courant Number as defined on a DG mesh

Adapting to this field is not recommended</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>DG_CourantNumber</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Local average mesh edge lengths</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MeshEdgeLengths</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <element name="mesh">
              <attribute name="name">
                <value>CoordinateMesh</value>
              </attribute>
            </element>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Speed:

 |u|

Limitations:
 - The Speed and Velocity fields must be on the same mesh.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Speed</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Absolute Difference between two scalar fields.

Both fields must be in this material_phase.
Assumes both fields are on the same mesh as the AbsoluteDifference field.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>AbsoluteDifference</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name_a">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <attribute name="field_name_b">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
            <optional>
              <element name="relative_to_average">
                <a:documentation>Evaluate the absolute difference once the average difference has been removed?</a:documentation>
                <empty/>
              </element>
            </optional>
            <optional>
              <element name="ignore_boundaries">
                <a:documentation>Ignore boundary nodes (i.e. zero them when calculating the difference)</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Absolute Difference between two scalar fields.

Both fields must be in this material_phase.
Assumes both fields are on the same mesh as the AbsoluteDifference field.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ScalarAbsoluteDifference</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name_a">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <attribute name="field_name_b">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
            <optional>
              <element name="relative_to_average">
                <a:documentation>Evaluate the absolute difference once the average difference has been removed?</a:documentation>
                <empty/>
              </element>
            </optional>
            <optional>
              <element name="ignore_boundaries">
                <a:documentation>Ignore boundary nodes (i.e. zero them when calculating the difference)</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Galerkin projection of one field onto another mesh.

The field must be in this material_phase.

NOTE: you need the solver options if the mesh
of this field is continuous.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>GalerkinProjection</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <element name="source_field_name">
              <data type="string" datatypeLibrary=""/>
            </element>
            <ref name="mesh_choice"/>
            <optional>
              <element name="lump_mass">
                <a:documentation>Lump the mass matrix of the galerkin projection
less accurate but faster and might give smoother result.                  </a:documentation>
                <empty/>
              </element>
            </optional>
            <optional>
              <element name="solver">
                <ref name="linear_solver_options_sym"/>
              </element>
            </optional>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Output the universal numbering of the mesh on which this field is based.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>UniversalNumber</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Output the processors which own the nodes of the mesh on which this field is based.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>NodeOwner</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Output the processors which own the elements of the mesh on which this field is based.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ElementOwner</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
    </choice>
    <!--
      Insert new diagnostic scalar fields here using the template:
             element scalar_field {
                 attribute rank { "0" },
                 attribute name { "NewFieldName" },
                 (
                    element diagnostic {
                       internal_algorithm,
                       velocity_mesh_choice,
                       diagnostic_scalar_field
                    }|
                    element aliased {
                       generic_aliased_field
                    }
                 )
             }
    -->
  </define>
  <!-- This is the choice of additional vector field to be solved for -->
  <define name="vector_field_choice">
    <!--
      The first is a generic field, which may be used for any user-defined field
      that FLUIDITY knows nothing about, or a generic diagnostic
      Prognostic vector fields are not possible (other than velocity and those known fields below).
    -->
    <choice>
      <element name="vector_field">
        <a:documentation>Generic field variable (vector)</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <optional>
          <element name="dimension">
            <a:documentation>If this is not set, the dimension of the vector field is
that set by /geometry/dimension</a:documentation>
            <ref name="integer"/>
          </element>
        </optional>
        <choice>
          <a:documentation>Field type</a:documentation>
          <element name="prescribed">
            <ref name="mesh_choice"/>
            <ref name="prescribed_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
          <element name="diagnostic">
            <ref name="vector_diagnostic_algorithms"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
        </choice>
      </element>
      <!--
        
        - - List of fields that are primarily prognostic,
           but can be aliased.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Prognostic_fields_below___">
        <a:documentation>Prescribed vector fields below this</a:documentation>
        <empty/>
      </element>
      <!--
        
        - - List of fields that are primarily prescribed,
           but can be aliased. An example is Maximum bed shear stress.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Prescribed_fields_below___">
        <a:documentation>Prescribed vector fields below this</a:documentation>
        <empty/>
      </element>
      <element name="vector_field">
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>AdvectingVelocity</value>
        </attribute>
        <element name="prescribed">
          <ref name="mesh_choice"/>
          <ref name="prescribed_vector_field"/>
          <optional>
            <element name="set_from_sphere_pullback">
              <a:documentation>Set the field from sphere pullback</a:documentation>
              <element name="sphere_radius">
                <ref name="real"/>
              </element>
            </element>
          </optional>
        </element>
      </element>
      <element name="vector_field">
        <a:documentation>Normal used for vector valued limiter at vertices
Element vector values are rotated using the orthogonal matrix
R that maps the element normal to this normal
before being limited to a convex hull</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>VertexNormal</value>
        </attribute>
        <element name="prescribed">
          <element name="mesh">
            <attribute name="name">
              <value>CoordinateMesh</value>
            </attribute>
          </element>
          <ref name="prescribed_vector_field"/>
        </element>
      </element>
      <element name="vector_field">
        <a:documentation>Tangent used for vector valued limiter at vertices
Together with VertexTangent2, this spans the tangent space
at the vertex where the convex hull limiting takes place
Must be orthonormal with VertexTangent2</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>VertexTangent1</value>
        </attribute>
        <element name="prescribed">
          <element name="mesh">
            <attribute name="name">
              <value>CoordinateMesh</value>
            </attribute>
          </element>
          <ref name="prescribed_vector_field"/>
        </element>
      </element>
      <element name="vector_field">
        <a:documentation>Tangent used for vector valued limiter at vertices
Together with VertexTangent1, this spans the tangent space
at the vertex where the convex hull limiting takes place
Must be orthonormal with VertexTangent1</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>VertexTangent2</value>
        </attribute>
        <element name="prescribed">
          <element name="mesh">
            <attribute name="name">
              <value>CoordinateMesh</value>
            </attribute>
          </element>
          <ref name="prescribed_vector_field"/>
        </element>
      </element>
      <element name="vector_field">
        <a:documentation>Prescribed vector field from commuting projection</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>PrescribedVelocityFromCommutingProjection</value>
        </attribute>
        <element name="prescribed">
          <ref name="velocity_mesh_choice"/>
          <element name="python">
            <a:documentation>Field to project from (evaluated at Gauss points)
Python function prescribing dimensional vector input. Functions should be of the form:

 def val(X, t):
    # Function code
    return # Return value

where X and the return value are tuples of length geometry dimension.</a:documentation>
            <ref name="python_code"/>
          </element>
          <ref name="prescribed_output_options"/>
          <ref name="prescribed_vector_stat_options"/>
        </element>
      </element>
      <!--
        
        Insert new prescribed vector fields here using the template:
               element vector_field {
                   attribute rank { "1" },
                   attribute name { "NewFieldName" },
                   (
                      element prescribed {
                         mesh_choice,
                         prescribed_vector_field
                      }|
                      element aliased {
                         generic_aliased_field
                      }
                   )
               }
        
        - - Last is a list of fields that are primarily diagnostic,
           but can be aliased. An example is Tidal Range.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Diagnostic_Fields_Below___">
        <a:documentation>Diagnostic vector fields below this</a:documentation>
        <empty/>
      </element>
      <element name="vector_field">
        <a:documentation>Absolute Difference between two vector fields.

Both fields must be in this material_phase.
Assumes both fields are on the same mesh as the AbsoluteDifference field.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>VectorAbsoluteDifference</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name_a">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <attribute name="field_name_b">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Galerkin projection of one field onto another mesh.

The field must be in this material_phase.

NOTE: you need the solver options if the mesh
of this field is continuous.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>GalerkinProjection</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <element name="source_field_name">
              <data type="string" datatypeLibrary=""/>
            </element>
            <ref name="mesh_choice"/>
            <optional>
              <element name="lump_mass">
                <a:documentation>Lump the mass matrix of the galerkin projection
less accurate but faster and might give smoother result.                  </a:documentation>
                <empty/>
              </element>
            </optional>
            <optional>
              <element name="solver">
                <ref name="linear_solver_options_sym"/>
              </element>
            </optional>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
    </choice>
    <!--
      Insert new diagnostic vector field here using the template:
             element vector_field {
                 attribute rank { "1" },
                 attribute name { "NewFieldName" },
                 (
                    element diagnostic {
                       internal_algorithm,
                       mesh_choice,
                       diagnostic_vector_field
                    }|
                    element aliased {
                       generic_aliased_field
                    }
                 )
             }
    -->
  </define>
  <!-- This is the choice of additional tensor fields -->
  <define name="tensor_field_choice">
    <!--
      The first is a generic field, which may be used for any user-defined field
      that FLUIDITY knows nothing about, or a generic diagnostic
      Prognostic tensor fields are not possible.
    -->
    <choice>
      <element name="tensor_field">
        <a:documentation>Generic field variable (tensor)</a:documentation>
        <attribute name="rank">
          <value>2</value>
        </attribute>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <choice>
          <a:documentation>Field type</a:documentation>
          <element name="prescribed">
            <ref name="mesh_choice"/>
            <ref name="prescribed_tensor_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
          <element name="diagnostic">
            <ref name="tensor_diagnostic_algorithms"/>
            <ref name="velocity_mesh_choice"/>
            <optional>
              <ref name="python_diagnostic_field_code"/>
            </optional>
            <ref name="diagnostic_tensor_field"/>
          </element>
        </choice>
      </element>
      <!--
        
        - - Second is a list of tensor fields that are primarily prescribed,
           but can be aliased.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Prescribed_fields_below___">
        <a:documentation>Prescribed tensor fields below this</a:documentation>
        <empty/>
      </element>
      <!--
        
        Insert new prescribed tensor fields here using the template:
               element tensor_field {
                   attribute rank { "2" },
                   attribute name { "NewFieldName" },
                   (
                      element prescribed {
                         mesh_choice,
                         prescribed_tensor_field
                      }|
                      element aliased {
                         generic_aliased_field
                      }
                   )
               }|
        
        - - Last is a list of fields that are primarily diagnostic,
           but can be aliased.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Diagnostic_Fields_Below___">
        <a:documentation>Diagnostic tensor fields below this</a:documentation>
        <empty/>
      </element>
    </choice>
    <!--
      Insert new diagnostic tensor field here using the template:
             element tensor_field {
                 attribute name { "NewFieldName" },
                 (
                    element diagnostic {
                       internal_algorithm,
                       mesh_choice,
                       diagnostic_tensor_field
                    }|
                    element aliased {
                       generic_aliased_field
                    }
                 )
             }
    -->
  </define>
  <!-- Diagnostic statistics options for meshed, with enabled by default -->
  <define name="mesh_stat_options_enabled_default">
    <ref name="include_mesh_in_stat"/>
  </define>
  <define name="mesh_stat_options_enabled_default" combine="choice">
    <ref name="exclude_mesh_from_stat"/>
  </define>
  <!-- Diagnostic statistics options for meshed, with disabled by default -->
  <define name="mesh_stat_options_disabled_default">
    <ref name="exclude_mesh_from_stat"/>
  </define>
  <define name="mesh_stat_options_disabled_default" combine="choice">
    <ref name="include_mesh_in_stat"/>
  </define>
  <define name="from_file_mesh_stat_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <ref name="mesh_stat_options_enabled_default"/>
    </element>
  </define>
  <define name="derived_mesh_stat_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <ref name="mesh_stat_options_disabled_default"/>
    </element>
  </define>
  <define name="input_choice_tensor_field">
    <choice>
      <element name="isotropic">
        <a:documentation>An isotropic tensor, i.e.
one with no directional variation.
Can be represented as a scalar real.</a:documentation>
        <ref name="input_choice_real"/>
      </element>
      <element name="anisotropic_symmetric">
        <a:documentation>A symmetric tensor, i.e.
A^T = A</a:documentation>
        <ref name="input_choice_real_dim_symmetric_tensor"/>
      </element>
      <element name="anisotropic_asymmetric">
        <a:documentation>A general asymmetric tensor.</a:documentation>
        <ref name="input_choice_real_dim_tensor"/>
      </element>
    </choice>
  </define>
  <define name="constitutive_laws">
    <choice>
      <element name="constitutive_law">
        <a:documentation>Constitutive laws for fluids</a:documentation>
        <attribute name="name">
          <value>fluid</value>
        </attribute>
      </element>
      <element name="constitutive_law">
        <a:documentation>Constitutive laws for solids</a:documentation>
        <attribute name="name">
          <value>solid</value>
        </attribute>
      </element>
    </choice>
  </define>
  <define name="region_ids">
    <optional>
      <element name="region_ids">
        <a:documentation>Optional region ids to associate different values
to different regions of the mesh.
Leave unselected if you`re not using multiple regions or
region_ids.
Currently only works with triangle files created by gmsh2triangle.</a:documentation>
        <ref name="integer_vector"/>
      </element>
    </optional>
  </define>
  <define name="temporal_control_volume_options">
    <element name="control_volumes">
      <a:documentation>Temporal discretisation options that are only relevant if a control volume or mixed control volume - continuous galerkin spatial discretisation is selected for this field.</a:documentation>
      <optional>
        <element name="number_advection_iterations">
          <a:documentation>Number of iterations within an advection solve.
This increases the accuracy of the face values and ensures that
the pivoted solution is cancelled out.
Defaults to 1 if unselected.</a:documentation>
          <ref name="integer"/>
          <optional>
            <element name="tolerance">
              <a:documentation>Cut short advection_iterations if the specified tolerance
is reached.
This only works for pure control volume discretisations.</a:documentation>
              <ref name="real"/>
              <choice>
                <element name="infinity_norm">
                  <a:documentation>Select the norm with which you want the tolerance to be tested.

The infinity norm.</a:documentation>
                  <empty/>
                </element>
                <element name="l2_norm">
                  <a:documentation>Select the norm with which you want the tolerance to be tested.

The l2 norm.</a:documentation>
                  <empty/>
                </element>
                <element name="cv_l2_norm">
                  <a:documentation>Select the norm with which you want the tolerance to be tested.

The l2 norm evaluated on a control volume mesh.</a:documentation>
                  <empty/>
                </element>
              </choice>
            </element>
          </optional>
        </element>
      </optional>
      <optional>
        <choice>
          <element name="maximum_courant_number_per_subcycle">
            <a:documentation>Use timestep subcycling to solve this equation.
Specify the maximum courant number per subcycle.
This only works for pure control volume discretisations.</a:documentation>
            <ref name="real"/>
            <ref name="field_based_cfl_number_options"/>
          </element>
          <element name="number_advection_subcycles">
            <a:documentation>Use timestep subcycling to solve this equation.
Specify the number of subcycles.
This only works for pure control volume discretisations.</a:documentation>
            <ref name="integer"/>
          </element>
        </choice>
      </optional>
      <optional>
        <element name="limit_theta">
          <a:documentation>Only works if a control volume or mixed control volume -
continuous galerkin spatial discretisation is selected.
If not active then the theta specified above will be used.
Otherwise use variable limited theta on individual faces.</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="pivot_theta">
          <a:documentation>Only works if a control volume or mixed control volume -
continuous galerkin spatial discretisation is selected.
Time discretisation of upwind discretisation off which the
higher order solution is pivotted.
 - pivot_theta = 1 - implicit pivot (default if not set and 
                     best choice if not intentionally modifying
                     scheme to be explicit)
 - pivot_theta = 0 - explicit pivot</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="spatial_control_volume_options">
    <ref name="standard_control_volume_options"/>
  </define>
  <define name="spatial_control_volume_options" combine="choice">
    <ref name="compressive_control_volume_options"/>
  </define>
  <define name="standard_control_volume_options">
    <choice>
      <element name="face_value">
        <a:documentation>First Order Upwind face value discretisation
 face_value = donor_value, 
where
 donor_value = income*val_1 + (1.-income)*val_2, 
where val_i is the value on the ith node neighbouring the face and
income = [0, 1] depending on whether the flow is coming from node 1 or 2
First order upwinding is monotonic so no limiting is ever required</a:documentation>
        <attribute name="name">
          <value>FirstOrderUpwind</value>
        </attribute>
        <empty/>
      </element>
      <element name="face_value">
        <a:documentation>Trapezoidal face value discretisation
 face_value = 0.5*(val_1 + val_2), 
where
 val_i is the value on the ith node neighbouring the face

Trapezoidal discretisation is unbounded so limiting is compulsory</a:documentation>
        <attribute name="name">
          <value>Trapezoidal</value>
        </attribute>
        <ref name="limiter_options"/>
      </element>
      <element name="face_value">
        <a:documentation>Finite Element face value discretisation
 face_value = finite element interpolation from surrounding nodes

Finite element discretisation may become unbounded so limiting is often necessary.</a:documentation>
        <attribute name="name">
          <value>FiniteElement</value>
        </attribute>
        <optional>
          <ref name="limiter_options"/>
        </optional>
      </element>
    </choice>
  </define>
  <define name="coupled_spatial_control_volume_options">
    <ref name="coupled_control_volume_options"/>
  </define>
  <define name="coupled_spatial_control_volume_options" combine="choice">
    <ref name="compressive_control_volume_options"/>
  </define>
  <!--
    coupled control volume options are the same as the standard ones (annoyingly copied and pasted)
    except that firstorderupwind gets limiter options
  -->
  <define name="coupled_control_volume_options">
    <choice>
      <element name="face_value">
        <a:documentation>First Order Upwind face value discretisation
 face_value = donor_value, 
where
 donor_value = income*val_1 + (1.-income)*val_2, 
where val_i is the value on the ith node neighbouring the face and
income = [0, 1] depending on whether the flow is coming from node 1 or 2
First order upwinding is monotonic so no limiting is ever required</a:documentation>
        <attribute name="name">
          <value>FirstOrderUpwind</value>
        </attribute>
        <optional>
          <ref name="limiter_options"/>
        </optional>
      </element>
      <element name="face_value">
        <a:documentation>Trapezoidal face value discretisation
 face_value = 0.5*(val_1 + val_2), 
where
 val_i is the value on the ith node neighbouring the face

Trapezoidal discretisation is unbounded so limiting is compulsory</a:documentation>
        <attribute name="name">
          <value>Trapezoidal</value>
        </attribute>
        <ref name="limiter_options"/>
      </element>
      <element name="face_value">
        <a:documentation>Finite Element face value discretisation
 face_value = finite element interpolation from surrounding nodes

Finite element discretisation may become unbounded so limiting is often necessary.</a:documentation>
        <attribute name="name">
          <value>FiniteElement</value>
        </attribute>
        <optional>
          <ref name="limiter_options"/>
        </optional>
      </element>
    </choice>
  </define>
  <define name="compressive_control_volume_options">
    <choice>
      <element name="face_value">
        <a:documentation>HyperC face value discretisation

face_value calculated from upper bound of explicit TVD zone of NVD diagram
Normally used for MaterialVolumeFraction fields</a:documentation>
        <attribute name="name">
          <value>HyperC</value>
        </attribute>
        <optional>
          <ref name="upwind_value_options"/>
        </optional>
        <ref name="cv_face_cfl_number_options"/>
      </element>
      <element name="face_value">
        <a:documentation>UltraC face value discretisation

face_value calculated from extended upper bound of
explicit TVD zone of NVD diagram assuming
values bounded by target_maximum and target_minimum.</a:documentation>
        <attribute name="name">
          <value>UltraC</value>
        </attribute>
        <element name="target_maximum">
          <a:documentation>Specifiy the upper bound which UltraC will use to
calculate the maximum flux.</a:documentation>
          <ref name="real"/>
        </element>
        <element name="target_minimum">
          <a:documentation>Specifiy the lower bound which UltraC will use to
calculate the minimum flux.</a:documentation>
          <ref name="real"/>
        </element>
        <optional>
          <ref name="upwind_value_options"/>
        </optional>
        <ref name="cv_face_cfl_number_options"/>
      </element>
      <element name="face_value">
        <a:documentation>**UNDER TESTING**

PotentialUltraC face value discretisation

face_value calculated from extended upper bound of
explicit TVD zone of NVD diagram if potential
value of field is sufficient (as specified by
target_maximum) to ensure the correct front advection
velocity.

If not then either switch to HyperC or use a modified flux
based on the potential function.</a:documentation>
        <attribute name="name">
          <value>PotentialUltraC</value>
        </attribute>
        <element name="target_maximum">
          <a:documentation>Specifiy the upper bound which PotentialUltraC will use
to calculate the maximum flux if the potential function
value is sufficient to maintain the correct front
advection velocity.</a:documentation>
          <ref name="real"/>
        </element>
        <element name="target_minimum">
          <a:documentation>Specifiy the lower bound which PotentialUltraC will use to calculate the minimum flux.</a:documentation>
          <ref name="real"/>
        </element>
        <choice>
          <element name="switch_to_hyperc">
            <a:documentation>Select what PotentialUltraC should do if the
potential function value does not reach the required
value specified by the target_maximum.

Switch to using HyperC face values.  This ensures
that the advection velocity is correct however may
create isolated regions beneath the target_maximum.</a:documentation>
            <empty/>
          </element>
          <element name="use_potential_flux">
            <a:documentation>Select what PotentialUltraC should do if the
potential function value does not reach the required
value specified by the target_maximum.

Modify the maximum nodal values (both downwind and
upwind) so that the fluxes are at their maximum
possible without affecting the front advection
velocity.</a:documentation>
            <empty/>
          </element>
        </choice>
        <optional>
          <ref name="upwind_value_options"/>
        </optional>
        <ref name="cv_face_cfl_number_options"/>
      </element>
    </choice>
  </define>
  <define name="field_based_cfl_number_options">
    <choice>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used.

This uses the control volume definition of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>ControlVolumeCFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>***UNDER TESTING***

Select the Courant Number definition to be used.

This uses the control volume definition of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>CVMaterialDensityCFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used.

This uses the finite element approximation of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>CFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used.</a:documentation>
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
        <empty/>
      </element>
    </choice>
  </define>
  <define name="cv_face_cfl_number_options">
    <choice>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used in the slope of
the NVD diagram upper bound.
This uses the finite difference definition of the CFL Number
consistent with the 1D version of HyperC (Leonard, 1981).
This is the default that reproduces old behaviour.
All others are under testing or construction.</a:documentation>
        <attribute name="name">
          <value>FiniteDifferenceCFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used in the slope of
the NVD diagram upper bound.
This uses the control volume definition of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>ControlVolumeCFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>***UNDER TESTING***

Select the Courant Number definition to be used in the slope of
the NVD diagram upper bound.
This uses a control volume definition of the CFL Number
that incorporates the MaterialDensity.
Requires a MaterialDensity field in this material_phase!</a:documentation>
        <attribute name="name">
          <value>CVMaterialDensityCFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>***UNDER TESTING***

Select the Courant Number definition to be used in the slope of
the NVD diagram upper bound.
This uses the finite element approximation of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>CFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>***UNDER TESTING***

Select the Courant Number definition to be used in the slope of
the NVD diagram upper bound.</a:documentation>
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
        <empty/>
      </element>
    </choice>
  </define>
  <define name="timestep_cfl_number_options">
    <choice>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used for adaptive timestepping.
This uses the finite element approximation of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>CFLNumber</value>
        </attribute>
        <ref name="velocity_mesh_choice">
          <a:documentation>Select the mesh on which you wish to evaluate the CFLNumber.</a:documentation>
        </ref>
      </element>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used for adaptive timestepping.
This uses the control volume definition of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>ControlVolumeCFLNumber</value>
        </attribute>
        <ref name="velocity_mesh_choice">
          <a:documentation>Select the mesh on which you wish to evaluate the ControlVolumeCFLNumber.</a:documentation>
        </ref>
      </element>
    </choice>
  </define>
  <define name="mixing_stats">
    <element name="include_mixing_stats">
      <a:documentation>Enable to include in the .stat file the fractions of the
scalar field contained in
bins specified by the user. This allows mixing of the field to be quantified.
Replaces and expands upon the old heaviside.dat file</a:documentation>
      <attribute name="name">
        <data type="string"/>
      </attribute>
      <choice>
        <element name="continuous_galerkin">
          <a:documentation>Select whether to evaluate the volume fraction over the finite element
(continuous galerkin) or within the control volume (control_volumes).

NOTE: continuous_galerkin only works with linear tets

NOTE: continuous_galerkin is not fully validated yet</a:documentation>
          <optional>
            <element name="normalise">
              <a:documentation>if select normalise the volume fractions will be
divided by the total volume of the domain</a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
        <element name="control_volumes">
          <a:documentation>Select whether to evaluate the volume fraction over the finite element
(continuous galerkin) or within the control volume (control_volumes).</a:documentation>
          <optional>
            <element name="normalise">
              <a:documentation>if select normalise the volume fractions will be divided by the total volume of the domain  </a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
      </choice>
      <element name="mixing_bin_bounds">
        <a:documentation>The values of the bounds of the bins 
e.g. the values 0 1 2 3 will return 4 bins 
and the fraction of the field in each bin with,
0&lt;=field&lt;1, 1&lt;=field&lt;2, 2&lt;=field&lt;3, 3&lt;=field, 
will be calculated. </a:documentation>
        <ref name="real_vector"/>
      </element>
      <optional>
        <element name="tolerance">
          <a:documentation>Define the tolerance beneath the specified bins that should be included.
Defaults to zero at machine tolerance (epsilon(0.0)) if not selected.</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="cv_stats">
    <element name="include_cv_stats">
      <a:documentation>Include statistics evaluated on the control volume mesh.</a:documentation>
      <empty/>
    </element>
  </define>
  <!-- Options for inclusion of calculations of surface integrals in the .stat file   -->
  <define name="surface_integral_stats_base.surface_integral">
    <attribute name="name">
      <data type="string"/>
    </attribute>
    <optional>
      <element name="surface_ids">
        <a:documentation>Surface IDs defining the surface over which to integrate. If disabled, integrates over the whole surface.</a:documentation>
        <ref name="integer_vector"/>
      </element>
    </optional>
    <optional>
      <element name="normalise">
        <a:documentation>Enable to normalise the integral by dividing by the surface area</a:documentation>
        <ref name="comment"/>
      </element>
    </optional>
  </define>
  <define name="surface_integral_stats_scalar">
    <element name="surface_integral">
      <a:documentation>Surface integral calculations. The following integral types are available:
 value: Integrates the field
 gradient_normal: Integrates the normal component of the gradient of the field</a:documentation>
      <ref name="surface_integral_stats_scalar.surface_integral"/>
    </element>
  </define>
  <define name="surface_integral_stats_scalar.surface_integral">
    <ref name="surface_integral_stats_base.surface_integral"/>
  </define>
  <define name="surface_integral_stats_scalar.surface_integral" combine="interleave">
    <attribute name="type">
      <choice>
        <value>value</value>
        <value>gradient_normal</value>
      </choice>
    </attribute>
  </define>
  <define name="surface_integral_stats_vector">
    <element name="surface_integral">
      <a:documentation>Surface integral calculations. The following integral types are available:
 normal: Integrates the normal component of the field</a:documentation>
      <ref name="surface_integral_stats_vector.surface_integral"/>
    </element>
  </define>
  <define name="surface_integral_stats_vector.surface_integral">
    <ref name="surface_integral_stats_base.surface_integral"/>
  </define>
  <define name="surface_integral_stats_vector.surface_integral" combine="interleave">
    <attribute name="type">
      <value>normal</value>
    </attribute>
  </define>
  <define name="velocity_equation_choice">
    <element name="equation">
      <a:documentation>Select the equation used to solve for velocity.</a:documentation>
      <attribute name="name">
        <value>ShallowWater</value>
      </attribute>
    </element>
  </define>
  <define name="scalar_equation_choice">
    <choice>
      <element name="equation">
        <a:documentation>Select the equation used to solve for this field.
Advection Diffusion is the norm for scalar fields.
Works for all discretisation types.</a:documentation>
        <attribute name="name">
          <value>AdvectionDiffusion</value>
        </attribute>
      </element>
      <element name="equation">
        <a:documentation>***UNDER TESTING***

Select the equation used to solve for this field.
Conservation of Mass equation - requires the selection of a Density field.
ONLY WORKS FOR CONTROL VOLUME DISCRETISATIONS WITHOUT A
DIFFUSIVITY, SOURCE OR ABSORPTION.</a:documentation>
        <attribute name="name">
          <value>ConservationOfMass</value>
        </attribute>
        <choice>
          <element name="density">
            <a:documentation>Select density to use in the Conservation of Mass Equation
Use the MaterialDensity - useful for multimaterial simulations
Clearly this requires a MaterialDensity field to be present</a:documentation>
            <attribute name="name">
              <value>MaterialDensity</value>
            </attribute>
          </element>
          <element name="density">
            <a:documentation>Select density to use in the Conservation of Mass Equation
Use the bulk Density
Clearly this requires a Density field to be present</a:documentation>
            <attribute name="name">
              <value>Density</value>
            </attribute>
          </element>
          <element name="density">
            <a:documentation>Select density to use in the Conservation of Mass Equation</a:documentation>
            <attribute name="name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
          </element>
        </choice>
      </element>
      <element name="equation">
        <a:documentation>***UNDER TESTING***

Select the equation used to solve for this field.
Reduced Conservation of Mass equation - requires the selection of a Density field.

ONLY WORKS FOR CONTROL VOLUME DISCRETISATIONS WITHOUT A
DIFFUSIVITY, SOURCE OR ABSORPTION.

This equation is very similar to a standard conservation of mass equation
except that the time discretisation uses only a single time level of density.
This enables consistency between the
MaterialVolumeFraction (ReducedConservationOfMass) and
MaterialDensity (Advection) equations in compressible multimaterial simulations.</a:documentation>
        <attribute name="name">
          <value>ReducedConservationOfMass</value>
        </attribute>
        <choice>
          <element name="density">
            <a:documentation>Select density to use in the Reduced Conservation of Mass Equation
Use the MaterialDensity - useful for multimaterial simulations
Clearly this requires a MaterialDensity field to be present</a:documentation>
            <attribute name="name">
              <value>MaterialDensity</value>
            </attribute>
          </element>
          <element name="density">
            <a:documentation>Select density to use in the Reduced Conservation of Mass Equation
Use the bulk Density
Clearly this requires a Density field to be present</a:documentation>
            <attribute name="name">
              <value>Density</value>
            </attribute>
          </element>
          <element name="density">
            <a:documentation>Select density to use in the Reduced Conservation of Mass Equation</a:documentation>
            <attribute name="name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
          </element>
        </choice>
      </element>
      <element name="equation">
        <a:documentation>***UNDER TESTING***

Select the equation used to solve for this field.
Internal Energy equation - requires the selection of a Density field.
ONLY WORKS FOR CONTROL VOLUME DISCRETISATIONS WITHOUT A
DIFFUSIVITY, SOURCE OR ABSORPTION.
Solve the internal energy equation for this field.
Requires pressure and velocity fields to be present.
Uses a nonconservative time discretisation.</a:documentation>
        <attribute name="name">
          <value>InternalEnergy</value>
        </attribute>
        <choice>
          <element name="density">
            <a:documentation>Select density to use in the Internal Energy Equation
Use the MaterialDensity - useful for multimaterial simulations
Clearly this requires a MaterialDensity field to be present
Whatever field is selected must be present.</a:documentation>
            <attribute name="name">
              <value>MaterialDensity</value>
            </attribute>
          </element>
          <element name="density">
            <a:documentation>Select density to use in the Internal Energy Equation
Use the bulk Density
Clearly this requires a Density field to be present
Whatever field is selected must be present.</a:documentation>
            <attribute name="name">
              <value>Density</value>
            </attribute>
          </element>
          <element name="density">
            <a:documentation>Select density to use in the Internal Energy Equation
Whatever field is selected must be present.</a:documentation>
            <attribute name="name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
          </element>
        </choice>
      </element>
      <element name="equation">
        <a:documentation>Option to solve for electrical potential from
electrokinetic, electrochemical or electrothermal sources </a:documentation>
        <attribute name="name">
          <value>ElectricalPotential</value>
        </attribute>
      </element>
    </choice>
  </define>
  <define name="recalculation_options">
    <element name="do_not_recalculate">
      <a:documentation>Prevent this field from being recalculated at every timestep.
This is cheaper especially if you are enforcing discrete properties on the field.</a:documentation>
      <empty/>
    </element>
  </define>
  <define name="discrete_properties_algorithm_scalar">
    <element name="enforce_discrete_properties">
      <a:documentation>Select discrete properties to enforce on the field
either after being prescribed or interpolated</a:documentation>
      <optional>
        <element name="solenoidal_lagrange_update">
          <a:documentation>Update this field using the lagrangian multiplier
calculated in the solenoidal projection of a
scalar field.

Note this field must be specified as the update field
underneath that vector field too.

Note also this only really makes sense for coupled
fields like velocity and pressure.</a:documentation>
          <empty/>
        </element>
      </optional>
    </element>
  </define>
  <define name="discrete_properties_algorithm_vector">
    <element name="enforce_discrete_properties">
      <a:documentation>Select discrete properties to enforce on the field
either after being prescribed or interpolated</a:documentation>
      <optional>
        <ref name="solenoidal_options"/>
      </optional>
    </element>
  </define>
  <define name="solenoidal_options">
    <element name="solenoidal">
      <a:documentation>Constrained divergence-free projection.
This adds an additional constraint that ensures that the field
is solenoidal, i.e. divergence-free.
This is equivalent in cost to a pressure solve.
This is expensive, and thus best left until
needed.

Note well: this only makes sense for nondivergent
vector fields, such as incompressible velocity!</a:documentation>
      <element name="interpolated_field">
        <a:documentation>Options for the mass matrix of the field being interpolated</a:documentation>
        <choice>
          <element name="continuous">
            <element name="lump_mass_matrix">
              <a:documentation>Lump the mass matrix for the assembly of the projection matrix
(not for the initial galerkin projection)

Required when using interpolating continuous fields</a:documentation>
              <optional>
                <element name="use_submesh">
                  <a:documentation>Lump on the submesh.
This only works for simplex meshes and is only
strictly valid on 2d meshes.</a:documentation>
                  <empty/>
                </element>
              </optional>
            </element>
          </element>
          <element name="discontinuous">
            <optional>
              <element name="lump_mass_matrix">
                <a:documentation>Lump the mass matrix for the assembly of the projection matrix
(not for the initial galerkin projection)</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
        </choice>
      </element>
      <element name="lagrange_multiplier">
        <a:documentation>Options for the lagrange multiplier

Must be on a continuous mesh!</a:documentation>
        <ref name="pressure_mesh_choice"/>
        <element name="spatial_discretisation">
          <choice>
            <element name="continuous_galerkin">
              <optional>
                <element name="remove_stabilisation_term">
                  <a:documentation>Remove the stabilisation term from the projection operator.

Automatic when not using P1P1.</a:documentation>
                  <empty/>
                </element>
              </optional>
              <optional>
                <element name="integrate_divergence_by_parts">
                  <a:documentation>Integrate the divergence operator by parts.

Automatic when projecting a discontinuous field</a:documentation>
                  <empty/>
                </element>
              </optional>
            </element>
            <element name="control_volumes">
              <empty/>
            </element>
          </choice>
        </element>
        <optional>
          <element name="reference_node">
            <ref name="integer"/>
          </element>
        </optional>
        <optional>
          <choice>
            <element name="update_scalar_field">
              <a:documentation>Update a scalar field using the lagrange multiplier from
the divergence free projection of this field.  The selected
scalar field must have solenoidal selected in its interpolation
options too and it must be on the same mesh as used for the
solenoidal projection above.

Note well: this only really makes sense for scalar fields linked to nondivergent
vector fields, such as pressure to incompressible velocity!                  </a:documentation>
              <attribute name="name">
                <value>Pressure</value>
              </attribute>
              <empty/>
            </element>
            <element name="update_scalar_field">
              <a:documentation>Update a scalar field using the lagrange multiplier from
the divergence free projection of this field.  The selected
scalar field must have solenoidal selected in its interpolation
options too and it must be on the same mesh as used for the
solenoidal projection above.

Note well: this only really makes sense for scalar fields linked to nondivergent
vector fields, such as pressure to incompressible velocity!                  </a:documentation>
              <attribute name="name">
                <data type="string" datatypeLibrary=""/>
              </attribute>
              <empty/>
            </element>
          </choice>
        </optional>
        <element name="solver">
          <a:documentation>Solver options for the linear solve.
This method requires the inversion of a projection matrix.</a:documentation>
          <ref name="linear_solver_options_sym"/>
        </element>
      </element>
    </element>
  </define>
  <define name="represcribe_before_interpolation">
    <element name="represcribe_before_interpolation">
      <a:documentation>Represcribe the field before interpolation.

This means the interpolation will not be conservative from the previous mesh so be careful what you're trying to achieve!</a:documentation>
      <empty/>
    </element>
  </define>
</grammar>
