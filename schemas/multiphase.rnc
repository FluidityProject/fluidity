include "spud_base.rnc"

include "adaptivity_options.rnc"
include "diagnostic_algorithms.rnc"
include "input_output.rnc"
include "solvers.rnc"
include "stabilisation.rnc"
include "mesh_options.rnc"
include "physical_parameters.rnc"
include "prognostic_field_options.rnc"
include "prescribed_field_options.rnc"
include "spatial_discretisation.rnc"
include "temporal_discretisation.rnc"

start =
   (
      ## The root node of the options dictionary.
      element multiphase_options {
         comment,
         ## Model output files are named according to the simulation
         ## name, e.g. [simulation_name]_0.vtu. Non-standard
         ## characters in the simulation name should be avoided.
         element simulation_name {
            anystring
         },
         geometry,
         ## Input/output options
         element io {
            (
               ## Period between dumps in time units.
               ##
               ## Specifies the period between each dump of the solution to disk.
               ## A value of 0.0 indicates that there would be a dump at every timestep.
               element dump_period {
                (
                     element constant {
                     real
                   }|
                   ## Python function prescribing real input. Functions should be of the form:
                   ##
                   ##  def val(t):
                   ##     # Function code
                   ##     return # Return value
                   ##
                   ## 
                   element python {
                     python_code
                   }
                )  
               }|                 
               ## Dump period, in timesteps.
               ## 
               ## Specifies the number of timesteps between each dump of the solution to disk.
               ## A value of 0 indicates a dump at every timestep.
               element dump_period_in_timesteps {
                 (
                     element constant {
                     integer
                   }|
                   ## Python function prescribing integer input. Functions should be of the form:
                   ##
                   ##  def val(t):
                   ##     # Function code
                   ##     return # Return value
                   ##
                   ## 
                   element python {
                     python_code
                   }
                )   
               }
            ),
            ## Disable dump at simulation start
            element disable_dump_at_start {
               comment
            }?,
            ## Disable dump at simulation end
            element disable_dump_at_end {
               comment
            }?,
            ## Number of dumps before we overwrite previous dumps.
            element max_dump_file_count {
               integer
            }?,
            (
               ## The mesh on to which all the fields will be
               ## interpolated for VTK output.
               element output_mesh {
                  attribute name { "VelocityMesh" }
               }|
               ## The mesh on to which all the fields will be
               ## interpolated for VTK output.
               element output_mesh {
                  attribute name { "PressureMesh" }
               }|
               ## The mesh on to which all the fields will be
               ## interpolated for VTK output.
               element output_mesh {
                  attribute name { "CoordinateMesh" }
               }|
               ## The mesh on to which all the fields will be
               ## interpolated for VTK output.
               element output_mesh {
                  attribute name { xsd:string }
               }
            ),
            ## Diagnostic output (.stat file) options
            element stat {
               ## Enable to write diagnostic output at simulation start
               element output_at_start {
                  comment
               }?,
               ## Enable to write diagnostic output immediately before mesh adapts
               element output_before_adapts {
                  comment
               }?,
               ## Enable to write diagnostic output immediately after mesh adapts
               element output_after_adapts {
                  comment
               }?,
               comment
            },
            ## Specification of detectors. Note that when running in parallel the detector output is in binary format even if binary_output is not enabled. When running in serial, although the output is in principle still generated in ascii format if binary_output is not enabled, it is not certain that it is working well. Hence, it is recommended to enable binary_output and work with binary files. 
            element detectors {
               (
                  ## A single static detector
                  element static_detector {
                     attribute name { xsd:string },
                     (
                        element location {
                           real_dim_vector
                     }|
                        ## File containing the detectors positions in binary form
                        element from_checkpoint_file {
                           attribute file_name { xsd:string },
                           ## The format of the input file containing field data.
                           element format {
                             element string_value {
                                 "binary"
                             }
                           }
                        }
                     )
                  }|
                  ## A single lagrangian detector
                  element lagrangian_detector {
                     attribute name { xsd:string },
                     (
                     ## This is the initial location of a detector that moves with the fluid velocity.
                        element location {
                           real_dim_vector
                     }|
                        ## File containing the detectors positions in binary form
                        element from_checkpoint_file {
                           attribute file_name { xsd:string },
                           ## The format of the input file containing field data.
                           element format {
                             element string_value {
                                 "binary"
                             }
                           }
                        }
                     )
                  }|
                  ## Detectors with their locations specified via a python function or from a file. Allows detector arrays to be added.
                  element detector_array {
                     attribute name { xsd:string },
                     ## The number of detectors prescribed by the python function.
                     element number_of_detectors {
                        integer
                     },
                     (
                        ## Create fixed detectors.
                        element static {
                           empty
                        }|
                        ## Create detectors which move with the fluid velocity.
                        element lagrangian {
                           empty
                        }
                     ),
                     (
                        ## Python function prescribing dimensional vector input. Functions should be of the form:
                        ##
                        ##  def val(t):
                        ##     # Function code
                        ##     return # Return value
                        ##
                        ## The return value must have length number_of_detectors.
                        ##
                        ## *** IMPORTANT NOTE ***
                        ##
                        ## The t argument is for future use only - currently detector locations are only set at simulation start.
                        element python {
                          python_code
                        }|
                        ## File containing the detectors positions in binary form
                        element from_file {
                           attribute file_name { xsd:string },
                           ## The format of the input file containing field data.
                           element format {
                             element string_value {
                                 "binary"
                             }
                           }
                        }|
                        ## File containing the detectors positions in binary form
                        element from_checkpoint_file {
                           attribute file_name { xsd:string },
                           ## The format of the input file containing field data.
                           element format {
                              element string_value {
                                 "binary"
                              }
                           }
                        }
                     )
                  }
               )*,
               ## Enable to write detector output in binary format
               element binary_output {
                  comment
               }?,
               element lagrangian_timestepping {
                  (
                     ## Use explicit runge kutta method with
                     ## binary search
                     element explicit_runge_kutta_guided_search {
                        ## Number of subdivisions of the timestep
                        ## increase this if you are not happy with your 
                        ## detector trajectory accuracy, or if particles
                        ## are jumping out of the domain a lot
                        element subcycles {
                           integer
                        },
                        ## Tolerance for deciding if detector is in a given
                        ## element. Recommended value 1.0e-10.
                        element search_tolerance {
                           real
                        },
                        ## Number of RK stages
                        ## For the RK4 method, it should be 4.
                        element n_stages {
                           integer
                        },
                        ## ERK stage array. This is an array
                        ## containing the lower-triangular
                        ## part of the Butcher weight matrix
                        ## A that explains how to compute the
                        ## RK stages.  See
                        ## http://en.wikipedia.org/wiki/Runge–Kutta_methods#Explicit_Runge.E2.80.93Kutta_methods
                        ## for notation.  The array is stored
                        ## in the following order:
                        ## [a_{21},a_{31},a_{32},...,a_{s1},a_{s2},a_{s(s-1)}]
                        ## and so the array has size s(s-1)/2
                        ## where s is the number of stages.
                        ## For the RK4 method, it should be
                        ## [0.5,0,0.5,0,0,1]
                        element stage_weights {
                           real_vector
                        },
                        ## ERK timestep weights. This is the
                        ## b vector that explains how to
                        ## compute the timestep from the RK
                        ## stages.  See
                        ## http://en.wikipedia.org/wiki/Runge–Kutta_methods#Explicit_Runge.E2.80.93Kutta_methods
                        ## for notation.  It should have size
                        ## s where s is the number of stages.
                        ## For the RK4 method, it should be
                        ## [1/6,1/3,1/3,1/6]
                        element timestep_weights {
                           real_vector
                        }
                     }|
                     ## Use binary search algorithm
                     element binary_search {
                        empty
                     }
                  )
               }?
            }?, 
            ## Options to create even more output in the logs:
            ##
            ## Note that the main option to control the log output is given on the command line:
            ##
            ## -v0  only output error and warnings
            ##
            ## -v1  also give "navigational information", to indicate where in the code we currently are
            ##
            ## -v2  also give any additional information (mins and maxes of fields, etc.)
            ##
            element log_output {
               ## Log all allocates and deallocates done for meshes, fields, sparsities and matrices.
               ##
               ## NOTE: Requires -v2
               element memory_diagnostics {
                  empty
               }?
            }?
         },
         ## Options dealing with time discretisation
         element timestepping {
            ## Current simulation time. At the start of the simulation this
            ## is the start time.
            element current_time {
               real
            },
            ## The time step size. If adaptive time stepping is used
            ## then this is the initial time step size.
            element timestep {
               real
            },
            ## Simulation time at which the simulation should end.
            element finish_time {
               real
            },
            ## Timestep after which the simulation should end.
            element final_timestep {
               integer
            }?,
            ## Maximum CPU time (in seconds) before the simulation terminates
            element cpu_time_limit {
               real
            }?,
            ## Maximum wall time (secs) taken up before
            ## simulation terminates writing results to disc.
            ## 
            ## This is usually disabled.
            element wall_time_limit {
               real
            }?,
            ## maximum number of non-linear iterations.
            ## 
            ## Manual suggests 2
            element nonlinear_iterations {
               integer,
               ## tolerance for non-linear iteration.
               ## Manual suggests 1.0E-12
               element tolerance {
                  real,
                  (
                      ## Select the norm with which you want the tolerance to be tested.
                      ##
                      ## The infinity norm.
                      element infinity_norm {
                        empty
                      }|
                      ## Select the norm with which you want the tolerance to be tested.
                      ##
                      ## The l2 norm.
                      element l2_norm {
                        empty
                      }|
                      ## Select the norm with which you want the tolerance to be tested.
                      ##
                      ## The l2 norm evaluated on a control volume mesh.
                      element cv_l2_norm {
                        empty
                      }
                  )
               }?,
               ## Terminate the simulation if the number of
               ## nonlinear_iterations is reached
               ## and the tolerance criterion is not met.
               ## This is mostly useful as a debugging option if you
               ## suspect the solution is not converging.
               element terminate_if_not_converged {
                  empty
               }?,
               ## Number of non-linear iterations for the first time step after adapting the mesh.
               ## This option will work only if the mesh_adaptivity is switched on.
               element nonlinear_iterations_at_adapt {
                  integer
               }?
            }?,
            ## Vary the timestep according to the courant number.
            element adaptive_timestep {
               ## The timestep will be adjusted (within the tolerance
               ## and bounds specified) to target this courant
               ## number. Timestep adapts occur at the end of each
               ## timestep and after a mesh adapt.
               element requested_cfl {
                  real
               },
               timestep_cfl_number_options,
               ## Minimum time step size.
               ## Manual suggests 0.0
               element minimum_timestep {
                  ## If enabled, signals model termination if a timestep less
                  ## than or equal to the minimum_timestep is requested. The
                  ## model will stop at the end of the timestep in order to
                  ## allow for the latest output to be written. 
                  element terminate_if_reached {
                     comment
                  }?,
                  real
               }?,
               ## Maximum time step size.
               ## Manual suggests 1.E+10
               element maximum_timestep {
                  real
               }?,
               ## The maximum ratio by which the timestep is allowed
               ## to increase in a timestep adapt. e.g., a value of
               ## 1.1 indicates that the timestep may be increased by
               ## at most 10%.
               element increase_tolerance {
                  real
               }?,
               ## Specify whether you want to calculate a new timestep
               ## at the first timestep or not.
               element at_first_timestep {
                  empty
               }?
            }?
         },
         physical_parameter_options?,
         ## The material or phase options
         element material_phase {
            attribute name { xsd:string },
            ## The equation of state
            element equation_of_state {
               (
                  (
                     ## Equations of state
                     element incompressible {
                        (
                           ## Incompressible linear equation of state
                           ## 
                           ## (DEN = EOS_COEFS( 1 ) + EOS_COEFS( 2 ) * P + EOS_COEFS( 3 ) * T + EOS_COEFS( 4 ) * P * T
                           ## + EOS_COEFS( 5 ) * ( P **2 )     + EOS_COEFS( 6 ) * ( T **2 ) + EOS_COEFS( 7 ) * ( P **2 ) * T 
                           ## + EOS_COEFS( 8 ) * P * ( T **2 ) + EOS_COEFS( 9 ) * (( P * T ) **2 )
                           element linear {
                              (
                                 ## All eos_coefficients equal as in most of
                                 ## the test cases (=1)
                                 element all_equal {
                                    real
                                 }|
                                 ## Specify the coefficients separately
                                 ## There should probably be at least 9
                                 ## see multi_eos.F90 lines 132-140
                                 element specify_all {
                                    real_vector
                                 }
                              ),
                              ## The reference or background density
                              element reference_density {
                                 real
                              }?,
                              ## Enable to add temperature dependency
                              ## to the equation of state.
                              element temperature_dependency {
                                 ## The reference or background
                                 ## temperature (actual temperature =
                                 ## calculated temperature plus this
                                 ## value).
                                 element reference_temperature {
                                    real
                                 },
                                 ## The thermal expansion coefficient
                                 element thermal_expansion_coefficient {
                                    real
                                 }
                              }?,
                              ## Enable to add salinity dependency to
                              ## the equation of state.
                              element salinity_dependency {
                                 ## The reference or background
                                 ## salinity (actual salinity =
                                 ## calculated salinity plus this
                                 ## value).
                                 element reference_salinity {
                                    real
                                 },
                                 ## The haline contraction coefficient
                                 element saline_contraction_coefficient {
                                    real
                                 }
                              }?,
                              ## Enable this option to subtract out
                              ## the hydrostatic level
                              element subtract_out_hydrostatic_level {
                                 empty
                              }?
                           }
                        )
                     }|
                     ## Equations of state for compressible applications
                     element compressible {
                        ## Stiffened Gas EoS
                        ##
                        ## Used with compressible simulations
                        ##
                        ## DEN = ( P + EOS_COEFS( 1 )) * EOS_COEFS( 2 ) / T
                        element stiffened_gas {
                           element eos_option1 { real },
                           element eos_option2 { real },
                           ## reference uncompressed density
                           ##
                           ## if activated then either Liquid EoS or
                           ## full Stiffened Gas EoS
                           element reference_density {
                              real
                           }?,
                           ## Ratio of specific heats at constant
                           ## pressure to that at constant volume
                           ##
                           ## Requires an energy field.
                           ## If activated then a full Stiffened Gas EoS 
                           element ratio_specific_heats {
                              real
                           }?,
                           ## bulk_sound_speed_squared = isothermal_bulk_modulus/reference_density
                           ##
                           ## if activated then either full or partial Liquid EoS or full
                           ## Stiffened Gas EoS
                           element bulk_sound_speed_squared {
                              real
                           }?
                        }  
                     }
                  )
               )
            }?,
            ## Pressure
            element scalar_field {
               attribute rank { "0" },
               attribute name { "Pressure" },
               ## Field type
               (
                  element prognostic {
                     # mesh choice with PressureMesh as first option
                     pressure_mesh_choice,
                     prognostic_pressure_field
                  }|
                  element prescribed {
                     # mesh choice with PressureMesh as first option
                     pressure_mesh_choice,
                     prescribed_scalar_field
                  }|
                  ## Compute pressure from Density and InternalEnergy
                  ## via a compressible equation of state.
                  element diagnostic {
                     # mesh choice with PressureMesh as first option
                     pressure_mesh_choice,
                     internal_algorithm,
                     diagnostic_scalar_field
                  }|
                  element aliased {
                     attribute material_phase_name { xsd:string },
                     attribute field_name {"Pressure" }
                  }
               )
            }?,
            ## Density
            element scalar_field {
               attribute rank { "0" },
               attribute name { "Density" },
               ## Field type
               (
                  element diagnostic {
                     internal_algorithm,
                     velocity_mesh_choice,
                     diagnostic_scalar_field
                  }|
                  element prognostic {
                     pressure_mesh_choice,
                     prognostic_density_field
                  }|
                  element aliased {
                     attribute material_phase_name { xsd:string },
                     attribute field_name {"Density" }
                  }
               )
            }?,
            ## Velocity vector and momentum options
            element vector_field {
               attribute rank { "1" },
               attribute name { "Velocity" },
               ## Field type
               (
                  element prognostic {
                     velocity_mesh_choice,
                     prognostic_velocity_field
                  }|
                  element prescribed {
                     velocity_mesh_choice,
                     prescribed_vector_field
                  }|
                  element diagnostic {
                     velocity_mesh_choice,
                     vector_python_diagnostic_algorithm,
                     diagnostic_vector_field
                  }|                  
                  element aliased {
                     attribute material_phase_name { xsd:string },
                     attribute field_name {"Velocity" }
                  }
               )
            },
            scalar_field_choice*,
            vector_field_choice*,
            tensor_field_choice*,
            ## Parameters required to model multiphase flow
            element multiphase_properties {
               ## Option for rel perms in prototype code
               ## Usually 3 except for the CompModel Non-equilibrium
               ## test cases where it is 6
               element relperm_option {integer},
               ## Relative permeability end point relperm_max
               ## in eq: relperm_max*(saturation/porosity)**(-relperm_exponent)
               ## Value between 0 and 1
               element relperm_max {real}?,
               ## Relative permeability exponent relperm_exponent
               ## in eq: relperm_max*(saturation/porosity)**(-relperm_exponent)
               element relperm_exponent {real}?,
               ## Capillary pressure multiplier cp_A
               ## in eq: cp_A*((Phase1_saturation+0.00001)**(-cp_expo))
               element cp_A {real}?,
               ## Capillary pressure exponent cp_expo
               ## in eq: cp_A*((Phase1_saturation+0.00001)**(-cp_expo))
               element cp_expo {real}?,
               ## Immobile volume of fluid phase
               element immobile_fraction {real}?
            }?
         }+,
         mesh_adaptivity_options?,
         ## Porous Media
         element porous_media {
            ## Specify scalar field Porosity
            element scalar_field {
               attribute name { "Porosity" },
               (
                  element prescribed {
                     velocity_mesh_choice,
                     prescribed_scalar_field
                  }|
                  element aliased {
                     generic_aliased_field
                  }
               )
            },
            ## Specify field Permeability
            (
               element scalar_field {
                  attribute name { "Permeability" },
                  (
                     element prescribed {
                        velocity_mesh_choice,
                        prescribed_scalar_field
                     }|
                     element aliased {
                        generic_aliased_field
                     }
                  )
               }|
               element vector_field {
                  attribute name { "Permeability" },
                  element prescribed {
                     velocity_mesh_choice,
                     prescribed_vector_field
                  }
               }|
               element tensor_field {
                  attribute name { "Permeability" },
                  element prescribed { 
                     velocity_mesh_choice,
                     prescribed_tensor_field
                  }
               }
            )
         }?
      }
   )

prognostic_density_field =
   (
      scalar_equation_choice?,
      ## Spatial discretisation options
      element spatial_discretisation {
         (
            ## Continuous Galerkin formulation.
            element continuous_galerkin {
               advection_stabilisation_options,
               ## Discretisation options for the advection terms.
               element advection_terms {
                  ## Integrate the advection terms of the momentum equation by
                  ## parts.
                  element integrate_advection_by_parts {
                     comment
                  }?
               },
               ## Discretisation options for the mass terms.
               element mass_terms {
                  ## Lump the mass matrix
                  element lump_mass_matrix {
                     empty
                  }?
               },
               comment
            }|
            ## Use a control volume discretisation.
            element control_volumes {
              spatial_control_volume_options
            }
         ),
         ## Conservative discretisation of field advection equation
         ##  TBETA=1. -- conservative (divergence form)
         ##  TBETA=0. -- non-conservative
         ##  0. < TBETA < 1.
         element conservative_advection {
           real
         }
      },
      element temporal_discretisation {
         ## Implicit/explicit control (TTHETA)
         ##  =0.  -- explicit
         ##  =0.5 -- Crank-Nicholson
         ##  =1.  -- implicit
         element theta {
            real
         },
         temporal_control_volume_options?
      },
      (
         ## Solver
         element solver {
            linear_solver_options_asym
         }|
         ## Assume this field is being solved explicitly and skip the solver.
         ##
         ## ONLY AVAILABLE FOR PURE CONTROL VOLUME SPATIAL DISCRETISATIONS.
         ##
         ## Assumes lhs matrix only has diagonal lumped mass (times
         ## density if appropriate for equation)
         ## and divides the rhs by this.
         element explicit {
            empty
         }
      )?,
      (
         ## Initial condition for WholeMesh
         ##
         ## Only specify one condition if not using mesh regions.
         ## Otherwise select other initial_condition option, specify region_ids
         ## and distinct names.  Then add extra intial conditions for other regions.
         element initial_condition {
            attribute name { "WholeMesh" },
            input_choice_initial_condition_real
         }|
         ## Multiple initial_conditions are allowed if specifying
         ## different values in different
         ## regions of the mesh (defined by region_ids).  In this case
         ## each initial_condition
         ## requires a distinct name for the options dictionary.
         element initial_condition {
            attribute name { string },
            region_ids?,
            input_choice_initial_condition_real
         }
      )+,
      ## Boundary conditions
      element boundary_conditions {
         attribute name { string },
         ## Surface id:
         element surface_ids {
            integer_vector
         },
         ## Type
         (
            element type {
               attribute name { "dirichlet" },
               ## Apply the dirichlet bc weakly.  Available
               ## automatically with discontinuous_galerkin,
               ## and control_volume spatial_discretisations.
               ## If not selected boundary conditions are applied strongly.
               element apply_weakly {
                  ## If the initial condition and boundary conditions
                  ## differ, setting this option will cause the initial
                  ## condition on the boundary to be overwritten with
                  ## the boundary condition. Since you are applying the
                  ## boundary condition weakly, you probably do *not*
                  ## want this.
                  element boundary_overwrites_initial_condition {
                     empty
                  }?
               }?,
               input_choice_real
            }
         )
      }*,
      ## source term
      element scalar_field {
         attribute name { "Source" },
         attribute rank { "0" },
         (
            element prescribed {
               prescribed_scalar_field_no_adapt,
               recalculation_options?
            }|
            ## This only works for traffic modelling
            element diagnostic {
              internal_algorithm,
              diagnostic_scalar_field_no_adapt
            } 
         )
      }?,
      ## Absorption term
      element scalar_field {
         attribute name { "Absorption" },
         attribute rank { "0" },
         element prescribed {
            prescribed_scalar_field_no_adapt
         }
      }?,
      prognostic_scalar_output_options,
      prognostic_scalar_stat_options,
      scalar_convergence_options,
      prognostic_detector_options,
      scalar_steady_state_options,
      adaptivity_options_prognostic_scalar_field,
      interpolation_algorithm_scalar,
      discrete_properties_algorithm_scalar?,
      ## Set the priority of this field
      ## This determines the order in which scalar_fields are solved for:
      ##  - higher numbers have the highest priority
      ##  - lower numbers (including negative) have the lowest priority
      ##  - default if not set is 0
      element priority {
         integer
      }?
   )

geometry = 
   (
      ## Options dealing with the specification of geometry
      element geometry {
         ## Dimension of the problem.
         ## <b>This can only be set once</b>
         element dimension {
            element integer_value {
               attribute rank {"0"},
               ("3"|"2"|"1")
            }
         },
         ## The position mesh
         element mesh {
            attribute name { "CoordinateMesh" },
            mesh_info
         },
         ## The velocity mesh
         element mesh {
            attribute name { "VelocityMesh" },
            mesh_info
         }?,
         ## The pressure mesh
         element mesh {
            attribute name { "PressureMesh" },
            mesh_info
         }?,
         element mesh {
            attribute name { xsd:string },
            mesh_info,
            element exclude_from_mesh_adaptivity{empty}?
         }*,
         ## Quadrature
         element quadrature {
            ## Quadrature degree
            ## 
            ## note: this specifies the degree of quadrature,
            ## not the number of gauss points
            element degree {
               integer
            },
            ## Surface quadrature degree
            ## 
            ## note: this specifies the degree of surface
            ## quadrature not the number of surface gauss points
            element surface_degree {
               integer
            }?,
            ## Sets the degree of quadrature on each quadrilateral
            ## face of the control volume. 
            ##
            ## Defaults to 1 if
            ## unselected which is the same as pre-new options
            ## behaviour.
            element controlvolume_surface_degree {
               integer
            }?,
            ## Select which family of quadrature rules to use.
            ## The default is family_cools.
            ## family_wandzura allows for degree up to 30
            ## on triangular meshes.
            ## family_grundmann_moeller allows for degree up to
            ## 29 on simplicial meshes in arbitrary dimension.
            element quadrature_family {
               element string_value {
                  ( "family_cools" | "family_grundmann_moeller" | "family_wandzura" ) 
               }
            }?
         }
      }
   )


# Default child of diagnostic scalar field
diagnostic_scalar_field =
   (
      diagnostic_output_options,
      diagnostic_scalar_stat_options,
      scalar_convergence_options,
      diagnostic_detector_options,
      scalar_steady_state_options,
      adaptivity_options_scalar_field,
      recalculation_options?,
      interpolation_algorithm_scalar?
   )
   
# Default child of diagnostic scalar field without adaptivity options
diagnostic_scalar_field_no_adapt =
   (
      diagnostic_output_options,
      diagnostic_scalar_stat_options,
      diagnostic_detector_options
   )

# Default child of diagnostic vector field
# Currently, this is empty, but in future this might include
# options that are general to all diagnostic vector fields
diagnostic_vector_field =
   (
      diagnostic_output_options,
      diagnostic_vector_stat_options,
      vector_convergence_options,      
      diagnostic_detector_options,
      vector_steady_state_options,
      adaptivity_options_vector_field,
      recalculation_options?,
      interpolation_algorithm_vector?
   )

# Default child of diagnostic tensor field
# Currently, this is empty, but in future this might include
# options that are general to all diagnostic tensor fields
diagnostic_tensor_field =
   (
      diagnostic_output_options,
      diagnostic_tensor_stat_options,
      adaptivity_options_tensor_field,
      interpolation_algorithm_vector?
   )

diagnostic_cv_gradient_vector_field =
   (
      ## Choose whether the mass matrix is lumped or not
      element lump_mass_matrix {
            empty
      }?,
      ## Solver options are necessary if you're not lumping your mass or if you're field isn't dg
      element solver {
         linear_solver_options_sym
      }?,
      ## Normalise the gradient by its magnitude
      element normalise {
        empty
      }?,
      diagnostic_output_options,
      diagnostic_vector_stat_options,
      vector_convergence_options,
      diagnostic_detector_options,
      adaptivity_options_vector_field,
      recalculation_options?
   )

diagnostic_gradient_vector_field =
   (
      ## Solver
      element solver {
         linear_solver_options_sym
      },
      diagnostic_output_options,
      diagnostic_vector_stat_options,
      vector_convergence_options,
      diagnostic_detector_options,
      adaptivity_options_vector_field,
      recalculation_options?
   )

diagnostic_cv_divergence_scalar_field =
   (
      # No solver options because it can be solved directly!
      diagnostic_output_options,
      diagnostic_scalar_stat_options,
      scalar_convergence_options,
      diagnostic_detector_options,
      adaptivity_options_scalar_field,
      recalculation_options?
   )

diagnostic_fe_divergence_scalar_field =
   (
      ## Solver
      element solver {
         linear_solver_options_sym
      },
      diagnostic_output_options,
      diagnostic_scalar_stat_options,
      scalar_convergence_options,
      diagnostic_detector_options,
      adaptivity_options_scalar_field,
      recalculation_options?
   )

# three optional input vectors for user-specified rotation matrix
rotation_matrix_components =
   (
      ## Select if you want to specify the normal direction
      ## of the rotation matrix.
      ## If off then fluidity computes the normal
      ## If on the tangents vectors must also be specified.
      element normal_direction {
         input_choice_real_dim_vector
      }?,
      ## specify first unit tangent vector to boundary
      element tangent_direction_1 {
         input_choice_real_dim_vector
      }?,
      ## specify second (if exists, i.e. if 3d) unit tangent vector to boundary
      element tangent_direction_2 {
         input_choice_real_dim_vector
      }?
   )

velocity_components_choice =
   (
      (
         element align_bc_with_surface {
            element normal_component {
               input_choice_real
            }?,
            element tangent_component_1 {
               input_choice_real
            }?,
            element tangent_component_2 {
               input_choice_real
            }?,
            rotation_matrix_components,
            ## this will calculate the determinant of the
            ## rotation matrix for every boundary node
            ## and dump a vtu with the node 
            ## normals and tangenials 1/2
            element debugging_mode{empty}?
         }|
         element align_bc_with_cartesian {
            element x_component {
               input_choice_real_bc_component
            }?,
            element y_component {
               input_choice_real_bc_component
            }?,
            element z_component {
               input_choice_real_bc_component
            }?
         }
      )
   )

velocity_boundary_conditions =
   (
      (
         element type {
            attribute name { "dirichlet" },
            ## Apply the dirichlet bc weakly.  Available automatically
            ## with a discontinuous_galerkin Velocity
            ## spatial_discretisation.  Available if you
            ## integrate_continuity_by_parts with a
            ## continuous_galerkin Pressure or use a control_volume
            ## Pressure spatial_discretisation and/or
            ## integrate_advection_by_parts under Velocity
            ## spatial_discretisation with continuous_galerkin.
            ##
            ## If not selected boundary conditions are applied strongly.
            element apply_weakly {
               ## If the initial condition and boundary conditions
               ## differ, setting this option will cause the initial
               ## condition on the boundary to be overwritten with
               ## the boundary condition. Since you are applying the
               ## boundary condition weakly, you probably do *not*
               ## want this.
               element boundary_overwrites_initial_condition {
                  empty
               }?
            }?,
            velocity_components_choice
         }|
         element type {
            attribute name { "neumann" },
            velocity_components_choice
         }|
         ## Add a bulk formulae boundary condition. Only makes sense
         ## on the Velocity field.
         element type {
            attribute name { "bulk_formulae" },
               empty
         }|
         element type {
           attribute name { "free_surface" },
           (
              ## This options adds a surface stabilisation term to the free surface. Works only for cg velocity so far. 
              ## Note: Once activated, the stabilisation term will occur in all free surface areas in the domain. 
              ## IN DEVELOPMENT
              element surface_stabilisation {
                  ## Scale factor for the surface stabilisation.
                  element scale_factor{
                    real
                  }
              }?
           )
         }|
         ## Apply quadratic drag. Specify drag coefficient. If you
         ## want to exactly replicate results from using the OCEDRA
         ## option, set this to 0.003 and remember to apply to both
         ## bottom and sides.
         element type {
            attribute name { "drag" },
            input_choice_real,
            (
              ## Use a quadratic drag.
              ##
              ## This means that the drag coefficient is nondimensional.
              element quadratic_drag {
                ## Use the Manning-Strickler formulation:
                ## n^2*g*|u|*u/H^(1/3)
                ## where n is the Manning coefficient, g is gravity, u is the velocity vector and H is the water heigth at that point.
                ##
                ## The coefficient given above defines the Manning coefficient [s/m^(1/3)] (a typical value for sand is 0.02)
                element manning-strickler {
                   empty
                }?
              }|
              ## Use a linear drag (basically just a surface absorption term).
              ##
              ## This means that the drag coefficient has units of momentum.
              element linear_drag {
                empty
              }
            )
         }|


         ## Apply wind forcing specified by stress or wind velocity.
         ## Replaces windy.dat and windy.py
         element type {
            attribute name { "wind_forcing" },
            (
               ## Wind forcing with user specified wind stress
               ##
               ## <b> Note that the stress needs to be specified
               ## using the same density units as the reference_density 
               ## under equation of state.</b>So if you use the recommended
               ## non-dimensional value of 1.0 for reference_density and
               ## your calculated stress is in kg m^-1s^-2 and the dimensional
               ## reference_density is 1000.0 kg m^-3, you need to divide
               ## the calculated stress in SI units by 1000.0.
               element wind_stress {
                  input_choice_real_dim_minus_one_vector|
                  element from_netcdf {
                     ## The format of this file should conform to NetCDF CF 1.x
                     ## (http://cf-pcmdi.llnl.gov/).
                     attribute file_name { xsd:string },
                     attribute east_west { xsd:string },
                     attribute north_south { xsd:string },
                     comment
                  }
               }|
               ## Wind forcing with user specified 10m wind velocity
               element wind_velocity {
                  ## Specify wind drag coefficient (dimensionless)
                  ## Suggested value: 4.0e-4
                  element wind_drag_coefficient {
                     input_choice_real
                  },
                  ## Density of air. 
                  ##
                  ## <b>Note that you have to specify
                  ## this density in the same units as the 
                  ## reference_density under equation of state.</b>
                  ## So with a typicial value of rho_air=1.3 kgm^-3
                  ## and rho_water=1000 kgm^-3, if you fill in the 
                  ## recommended (non-dimensional) value of 1.0 for 
                  ## reference_density, this field needs to be 1.3e-3.
                  element density_air {
                     real
                  },
                  ## Specify wind velocity
                  element wind_velocity {
                     input_choice_real_dim_minus_one_vector|
                     element from_netcdf {
                        ## The format of this file should conform to NetCDF CF 1.x
                        ## (http://cf-pcmdi.llnl.gov/)
                        attribute file_name { xsd:string },
                        attribute east_west { xsd:string },
                        attribute north_south { xsd:string },
                        comment
                     }
                  }
               }
            )
         }|

         ## When using control_volumes under Pressure
         ## spatial_discretisation or when using
         ## integrate_continuity_by_parts with continuous_galerkin
         ## Pressure and continuous_galerkin Velocity this
         ## boundary condition type imposes a weak no normal flow
         ## boundary condition on the surface_ids specified.
         element type {
            attribute name { "no_normal_flow" },
            empty
         }|

         ## Implements a penalty function for the near wall region.
         ## Using this option coarse meshes can
         ## be used in the near wall region.
         ##
         ## Should be used in combination with a no_normal_flow condition. 
         ##
         ## See Bazilevs et al. 2007
         element type{
            attribute name { "near_wall_treatment" },
            element tolerance {real},
            ## if not set then Cb=2*h, where h is the element size
            element Cb {real}?
         }|
         ## Log law of the wall
         ##
         ## Should be used in combination with a no_normal_flow condition. 
         element type{
            attribute name { "log_law_of_wall" },
            element surface_roughness {real}
         }|
         ## Dummy BC
         ##
         ## Should be used in combination with the near_wall_treatment condition.
         ## When activated wall treatment is not applied on the wall-outflow edge.
         element type{
            attribute name { "outflow" }
         }
      )
   )
   
# Output options for prognostic fields
prognostic_scalar_output_options =
   (
      ## Specify what is written to vtu dump files.
      element output {
         ## Exclude this field from dump files.
         element exclude_from_vtu {
            empty
         }?,
         ## Select this option to also write the values of this field
         ## on the previous timestep.
         ## (included under the name: Old<field_name> )
         element include_previous_time_step {
            empty
         }?,
         ## Select this option to also write the values of this field
         ## used in the nonlinear iteration.
         ## (included under the name: Nonlinear<field_name> )
         element include_nonlinear_field {
            empty
         }?,
         ## Output a file details the convergence (or otherwise) of
         ## this field with every advective nonlinear
         ## iteration.
         ## ONLY WORKS FOR PURE CONTROL VOLUME DISCRETISATIONS.
         element convergence_file {
            comment
         }?
      }
   )

# Output options for pressure (can't have a convergence file)
pressure_output_options =
   (
      ## Specify what is written to vtu dump files.
      element output {
         ## Exclude this field from dump files.
         element exclude_from_vtu {
            empty
         }?,
         ## Select this option to also write the values of this field
         ## on the previous timestep.
         ## (included under the name: Old<field_name> )
         element include_previous_time_step {
            empty
         }?,
         ## Select this option to also write the values of this field
         ## used in the nonlinear iteration.
         ## (included under the name: Nonlinear<field_name> )
         element include_nonlinear_field {
            empty
         }?,
         ## Write out some extra debugging vtu files that can be used
         ## to analyse what goes on in the pressure projection steps.
         ## WARNING: this may create a huge amount of vtu files, as 
         ## multiple files are written per nonlinear iteration.
         element debugging_vtus {
            empty
         }?
      }
   )

# Output options for prognostic fields
prognostic_vector_output_options =
   (
      ## Specify what is written to dump files.
      element output {
         ## Exclude this field from dump files.
         element exclude_from_vtu {
            empty
         }?,
         ## Select this option to also write the values of this field
         ## on the previous timestep.
         ## (included under the name: Old<field_name> )
         element include_previous_time_step {
            empty
         }?,
         ## Select this option to also write the values of this field
         ## used in the nonlinear iteration.
         ## (included under the name: Nonlinear<field_name> )
         element include_nonlinear_field {
            empty
         }?
      }
   )
   
# Field output options for all other fields
field_output_options =
   (
      ## Specify what is written to dump files.
      element output {
         ## Exclude this field from dump files.
         element exclude_from_vtu {
            comment
         }?,
         ## To be used with time-averaged diagnostic fields so that they can be checkpointed.
         element checkpoint {
            empty
         }?
      }
   )
field_output_options_disabled =
   (
      ## Specify what is written to vtu dump files.
      element output {
         (
            ## Exclude this field from dump files.
            element exclude_from_vtu {
               comment
            }|
            ## Include this field in dump files.
            element include_in_vtu {
               comment
            }
         )
      }
   )
   
diagnostic_output_options = field_output_options
prescribed_output_options = field_output_options

# Options for inclusion/exclusion of standard field statistics from the .stat
# file
include_stat =
   (
      ## Include this field in the .stat file (magnitude and components)
      element include_in_stat {
         comment
      }
   )
exclude_components_from_stat =
   (
      ## Include just the magnitude of this field in the .stat file
      ## (excluding the components)
      element exclude_components_from_stat {
         comment
      }
   )
exclude_stat =
   (
      ## Exclude this field from the .stat file.
      element exclude_from_stat {
         comment
      }
   )

# Diagnostic statistics options for prognostic scalar fields
prognostic_scalar_stat_options = 
   (
      ## Specify what is added to .stat files
      element stat {
        prognostic_scalar_stat_options.stat
      }
   )
  
# Diagnostic statistics for all other scalar fields
prognostic_scalar_stat_no_old_or_nonlinear_options =
   (
      ## Specify what is added to .stat files
      element stat {
         prognostic_scalar_stat_no_old_or_nonlinear_options.stat
         
      }
   )

diagnostic_scalar_stat_options = prognostic_scalar_stat_no_old_or_nonlinear_options
prescribed_scalar_stat_options = prognostic_scalar_stat_no_old_or_nonlinear_options

# Combining of stat elements for scalar fields
prognostic_scalar_stat_options.stat = prognostic_scalar_stat_no_old_or_nonlinear_options.stat
prognostic_scalar_stat_options.stat &=
   (
      ## Enable to include the previous timestep value of this field in the .stat file.
      element include_previous_time_step {
         comment
      }?,
      ## Enable to include the values of this field in the nonlinear
      ## iteration in the .stat file.
      element include_nonlinear_field {
         comment
      }?
   )
prognostic_scalar_stat_no_old_or_nonlinear_options.stat = 
   (
      exclude_stat?,
      cv_stats?,
      surface_integral_stats_scalar*,
      mixing_stats*
   )   
   
# Diagnostic statistics options for vector fields, with enabled by default
vector_field_stat_options_enabled_default = include_stat
vector_field_stat_options_enabled_default |= exclude_components_from_stat
vector_field_stat_options_enabled_default |= exclude_stat

# Diagnostic statistics options for vector fields, with enabled by default
vector_field_stat_options_disabled_default = exclude_stat
vector_field_stat_options_disabled_default |= exclude_components_from_stat
vector_field_stat_options_disabled_default |= include_stat

# Diagnostic statistics options for tensor fields, with enabled by default
tensor_field_stat_options_enabled_default = include_stat
tensor_field_stat_options_enabled_default |= exclude_components_from_stat
tensor_field_stat_options_enabled_default |= exclude_stat

# Diagnostic statistics options for tensor fields, with enabled by default
tensor_field_stat_options_disabled_default = exclude_stat
tensor_field_stat_options_disabled_default |= exclude_components_from_stat
tensor_field_stat_options_disabled_default |= include_stat

# Diagnostic statistics for prognostic vector fields
prognostic_velocity_stat_options =
   (
      ## Specify what is added to .stat files
      element stat {
         (
            prognostic_velocity_stat_options.stat
         )
      }      
   )

# Diagnostic statistics for all other vector fields
prognostic_vector_stat_no_old_or_nonlinear_options =
   (
      ## Specify what is added to .stat files
      element stat {
         prognostic_vector_stat_no_old_or_nonlinear_options.stat
      }
   )
diagnostic_vector_stat_options = prognostic_vector_stat_no_old_or_nonlinear_options
prescribed_vector_stat_options = prognostic_vector_stat_no_old_or_nonlinear_options

# Diagnostic statistics for tensor fields
prognostic_tensor_stat_no_old_or_nonlinear_options =
   (
      ## Specify what is added to .stat files
      element stat {
         prognostic_tensor_stat_no_old_or_nonlinear_options.stat
      }
   )
diagnostic_tensor_stat_options = prognostic_tensor_stat_no_old_or_nonlinear_options
prescribed_tensor_stat_options = prognostic_tensor_stat_no_old_or_nonlinear_options

# Combining of stat elements for vector fields
prognostic_velocity_stat_options.stat = prognostic_vector_stat_no_old_or_nonlinear_options.stat
prognostic_velocity_stat_options.stat &=
   (
      ## Specify how the previous timestep value of this field is added to the .stat file.
      element previous_time_step {
         vector_field_stat_options_disabled_default
      },
      ## Specify how the values of this field used in the nonlinear iteration are added to the .stat file.
      element nonlinear_field {
         vector_field_stat_options_disabled_default
      },
      ## What surface IDs do you want to do the calculation over?
      element compute_body_forces_on_surfaces {
         ## Enable to output the pressure and viscous terms separately (as well
         ## as the total force)
         element output_terms {
            comment
         }?,
         integer_vector
      }?,
      ## Compute the divergence of this field at the Gauss points
      ## and return its stats.  This is a direct measure of the
      ## divergence at the gauss points rather than a discrete measure
      ## at the nodes (provided by several other diagnostic fields).
      element divergence_stats {
        empty
      }?,
      ## Calculate the error in the conservation of momentum
      ## IN PROGRESS - Does not include all terms!
      element calculate_momentum_conservation_error {
         empty
      }?
   )
prognostic_vector_stat_no_old_or_nonlinear_options.stat =
   (
      vector_field_stat_options_enabled_default,
      surface_integral_stats_vector*
   )

# Combining of stat elements for tensor fields
prognostic_tensor_stat_no_old_or_nonlinear_options.stat =
   (
      tensor_field_stat_options_enabled_default
   )

# Convergence options for prognostic scalar fields
scalar_convergence_options =
   (
      ## Decide whether this field is tested for convergence
      ## during nonlinear iterations
      ## (if /timestepping/nonlinear_iterations and
      ## /timestepping/nonlinear_iterations/tolerance are
      ## enabled).
      ## Also specifies whether the field is added to the 
      ## convergence file (if /io/convergence_file is enabled).
      element convergence {
         (
            ## Include this field in convergence testing
            ## (if /timestepping/nonlinear_iterations and
            ## /timestepping/nonlinear_iterations/tolerance are
            ## enabled) and file (if /io/convergence_file is enabled)
            element include_in_convergence {
               comment
            }|
            ## Exclude this field from convergence testing and file 
            element exclude_from_convergence {
               comment
            }
         )
      }
   )

# Convergence statistics options for prognostic vector fields (velocity)
vector_convergence_options =
   (
      ## Decide whether this field is tested for convergence
      ## during nonlinear iterations
      ## (if /timestepping/nonlinear_iterations and
      ## /timestepping/nonlinear_iterations/tolerance are
      ## enabled).
      ## Also specifies whether the field is added to the 
      ## convergence file (if /io/convergence_file is enabled).
      element convergence {
         (
            ## Include this field (magnitude and components)
            ## in convergence testing
            ## (if /timestepping/nonlinear_iterations and
            ## /timestepping/nonlinear_iterations/tolerance are
            ## enabled) and file (if /io/convergence_file is enabled)
            element include_in_convergence {
               comment
            }|
            ## Include just the magnitude of this field 
            ## in convergence testing
            ## (if /timestepping/nonlinear_iterations and
            ## /timestepping/nonlinear_iterations/tolerance are
            ## enabled) and file (if /io/convergence_file is enabled)
            ## i.e. excluding the components
            element exclude_components_from_convergence {
               comment
            }|
            ## Exclude this field entirely from convergence testing and file 
            element exclude_from_convergence {
               comment
            }
         )
      }
   )

# Steady state options for prognostic scalar fields
scalar_steady_state_options =
   (
      ## Decide whether this field is tested for a steady state
      ## between timesteps
      ## (if /timestepping/steady_state is
      ## enabled).
      element steady_state {
         (
            ## Include this field in steady state testing
            ## (if /timestepping/steady_state is
            ## enabled)
            element include_in_steady_state {
               comment
            }|
            ## Exclude this field from steady state testing
            element exclude_from_steady_state {
               comment
            }
         )
      }
   )

# Steady state statistics options for prognostic vector fields (velocity)
vector_steady_state_options =
   (
      ## Decide whether this field is tested for a steady state
      ## between timesteps
      ## (if /timestepping/steady_state is
      ## enabled).
      element steady_state {
         (
            ## Include this field (magnitude and components)
            ## in steady state testing
            ## (if /timestepping/steady_state is enabled)
            element include_in_steady_state {
               comment
            }|
            ## Include just the magnitude of this field 
            ## in steady state testing
            ## (if /timestepping/steady_state is
            ## enabled)
            ## i.e. excluding the components
            element exclude_components_from_steady_state {
               comment
            }|
            ## Exclude this field entirely from convergence testing and file 
            element exclude_from_steady_state {
               comment
            }
         )
      }
   )

# Options for whether a field is to be included in detector output.
detector_options_enabled_default = 
   (
      ## Specify what is added to detector files
      element detectors {
         (
            ## This field is output at each detector location.
            element include_in_detectors {
               comment
            }|
            ## This field is not output at detector locations.
            element exclude_from_detectors {
               comment
            }
         )
      }
   )

# Options for whether a field is to be included in detector output.
detector_options_disabled_default = 
   (
      ## Specify what is added to detector files
      element detectors {
         (
            ## This field is not output at detector locations.
            element exclude_from_detectors {
               comment
            }|
            ## This field is output at each detector location.
            element include_in_detectors {
               comment
            }
         )
      }
   )

# Detector output defaults on for prognostic and diagnostic fields, 
# off for prescribed.
prognostic_detector_options = detector_options_enabled_default
diagnostic_detector_options = detector_options_enabled_default
prescribed_detector_options = detector_options_disabled_default

generic_aliased_field =
   (
      attribute material_phase_name { xsd:string },
      attribute field_name { xsd:string }
   )

# This is the choice of additional scalar field to be solved for
scalar_field_choice =
   (
# The first is a generic field, which may be used for any user-defined field
# that FLUIDITY knows nothing about, or a generic diagnostic
      (
         element scalar_field {
            attribute rank { "0" },
            attribute name { xsd:string },
            ## Field type
            (
               element prognostic {
                  velocity_mesh_choice,
                  prognostic_scalar_field
               }|
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }|
               element diagnostic {
                  scalar_diagnostic_algorithms,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Prognostic scalar fields below this
         element ___Prognostic_Fields_Below___ {
            empty
         }|

# This is the long list of fields that FLUIDITY knows about
# -- First is a list of fields that are primarily prognostic,
#    but can be set to prescribed, or aliased...
# -- The list is in order of most frequently used.

         ## Salinity
         element scalar_field {
            attribute rank { "0" },
            attribute name { "Salinity" },
            (
               element prognostic {
                  velocity_mesh_choice,
                  prognostic_scalar_field
               }|
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Temperature
         element scalar_field {
            attribute rank { "0" },
            attribute name { "Temperature" },
            (
               element prognostic {
                  velocity_mesh_choice,
                  prognostic_scalar_field
               }|
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Background Temperature
         element scalar_field {
            attribute rank { "0" },
            attribute name { "BackgroundTemperature" },
            (
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }
            )
         }|
         ## Passive Tracer
         element scalar_field {
            attribute rank { "0" },
            attribute name { "Tracer" },
            (
               element prognostic {
                  velocity_mesh_choice,
                  prognostic_scalar_field
               }|
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## CopiedField - This field copies the previous timesteps
         ## values from another (specified) field at every iteration
         ## and then solves the field using different (again, specified)
         ## scheme and solution options.
         ## For instance, this field can be used to create a diffused
         ## field to adapt to.
         ## Unless someone requests otherwise this is only currently possible
         ## for fields within the same material_phase.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "CopiedField" },
            (
               element prognostic {
                  velocity_mesh_choice,
                  attribute copy_from_field { string },
                  prognostic_scalar_field
               }
            )
         }|
         ## Calculate the stream function of 2D incompressible flow. Note 
         ## that this *only* makes sense for proper 2D (not pseudo-2D) simulations.
         ## Requires a continuous mesh.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "StreamFunction" },
            (
               element prognostic {
                  mesh_choice,
                  prognostic_stream_function_field
               }
            )
         }|
         ## PhaseVolumeFraction
         ## Required in porous_media and multiphase problem types
         element scalar_field {
            attribute rank { "0" },
            attribute name { "PhaseVolumeFraction" },
            (
               element prognostic {
                  velocity_mesh_choice,
                  prognostic_scalar_field,
                  cap_option?
               }|
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }|
               element diagnostic {
                  velocity_mesh_choice,
                  internal_algorithm,
                  diagnostic_scalar_field_no_adapt,
                  cap_option?
               }
            )
         }|
         # Insert new prognostic scalar fields here using the template:
         #        element scalar_field {
         #            attribute rank { "0" },
         #            attribute name { "NewFieldName" },
         #            (
         #               element prognostic {
         #                  velocity_mesh_choice,
         #                  prognostic_scalar_field
         #               }|
         #               element prescribed {
         #                  velocity_mesh_choice,
         #                  prescribed_scalar_field
         #               }|
         #               element aliased {
         #                  generic_aliased_field
         #               }
         #            )
         #        }
         
# -- Second is a list of fields that are primarily prescribed,
#    but can be aliased. An example is wind velocity.
# -- The list is in order of most frequently used.

         ## Prescribed scalar fields below this
         element ___Prescribed_fields_below___ {
            empty
         }|
#
# Insert new prescribed scalar fields here using the template:
#        element scalar_field {
#            attribute rank { "0" },
#            attribute name { "NewFieldName" },
#            (
#               element prescribed {
#                  velocity_mesh_choice,
#                  prescribed_scalar_field
#               }|
#               element aliased {
#                  generic_aliased_field
#               }
#            )
#        }
#
# -- Last is a list of fields that are primarily diagnostic,
#    but can be aliased. An example is Tidal Range.
# -- The list is in order of most frequently used.
#
         ## Diagnostic scalar fields below this
         element ___Diagnostic_Fields_Below___ {
            empty
         }|
         ## ControlVolumeDivergence:
         ##
         ## div field
         ##
         ## Divergence of the velocity field where
         ## the divergence operator is defined using
         ## the control volume C^T matrix.
         ## This assumes that the test space is discontinuous
         ## control volumes.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "ControlVolumeDivergence" },
            (
               element diagnostic {
                  internal_algorithm,
                  attribute field_name { string },
                  velocity_mesh_choice,
                  diagnostic_cv_divergence_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|

         ## FiniteElementDivergence:
         ##
         ## div field
         ##
         ## Divergence of the velocity field where
         ## the divergence operator is defined using
         ## the finite element C^T matrix.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "FiniteElementDivergence" },
            (
               element diagnostic {
                  legacy_internal_algorithm,
                  attribute field_name { string },
                  velocity_mesh_choice,
                  element integrate_divergence_by_parts {
                     empty
                  }?,
                  diagnostic_fe_divergence_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## CFLNumber
         ##
         ## See http://amcg.ese.ic.ac.uk/index.php?title=Local:Diagnostics#CFL_Number
         ##
         ## Adapting to this field is not recommended
         element scalar_field {
            attribute rank { "0" },
            attribute name { "CFLNumber" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## ControlVolumeCFLNumber
         ##
         ## Courant Number as defined on a control volume mesh
         ##
         ## Adapting to this field is not recommended
         element scalar_field {
            attribute rank { "0" },
            attribute name { "ControlVolumeCFLNumber" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## DG_CourantNumber
         ##
         ## Courant Number as defined on a DG mesh
         ##
         ## Adapting to this field is not recommended
         element scalar_field {
            attribute rank { "0" },
            attribute name { "DG_CourantNumber" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Grid Reynolds number
         element scalar_field {
            attribute rank { "0" },
            attribute name { "GridReynoldsNumber" },
            (element diagnostic {
               internal_algorithm,
               velocity_mesh_choice,
               diagnostic_scalar_field
            }
            | element aliased { generic_aliased_field })
         }|
         ## GridPecletNumber
         ##
         ## Peclet Number Pe = U*dx/2*diffusivity
         ##
         ## Also see the test case 'grid_peclet_number'
         ## if you wish to see the effect of changing the 
         ## diffusivity on a 1D, cg-discretised tracer-field
         ##
         ## Adapting to this field is not recommended
         element scalar_field {
            attribute rank { "0" },
            attribute name { "GridPecletNumber" },
            (
               element diagnostic {
                  internal_algorithm,
                  ## Mesh on which to calculate dx
                  mesh_choice,
                  ## This is the name of the scalar field
                  ## to calculate the Peclet number for
                  ## Note this field needs to have a diffusivity
                  element field_name { string },
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Horizontal velocity divergence:
         ##
         ## div_H velocity
         ##
         ## Uses the gravity field direction to determine the horizontal plane.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HorizontalVelocityDivergence" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|

         ## Velocity divergence:
         ##
         ## div velocity
         ##
         element scalar_field {
            attribute rank { "0" },
            attribute name { "VelocityDivergence" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|

         ## Vorticity for a 2D field:
         ##
         ##  du   dv
         ##  -- - --
         ##  dy   dx
         element scalar_field {
            attribute rank { "0" },
            attribute name { "Vorticity2D" },
            (
               element diagnostic {
                  vorticity_2d_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         
         ## Gravitational potential energy density:
         ##
         ## -rho*(g dot (r - r_0))
         ##
         ## where rho is the Density scalar field
         ## r_0 is the potential energy zero point
         ## and g is the gravity vector
         ##
         ## BE AWARE OF WHAT IS IN THE DENSITY SCALAR FIELD
         ##
         ## Limitations:
         ##  - Requires a constant gravity direction.
         ##  - The Density and GravitationalPotentialEnergyDensity fields must be on the same mesh.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "GravitationalPotentialEnergyDensity" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field,
                  ## Coordinate of a point with a potential energy of zero.
                  element zero_point {
                     real_dim_vector
                  }
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Local average mesh edge lengths
         element scalar_field {
          attribute rank { "0" },
            attribute name { "MeshEdgeLengths" },
            (
              element diagnostic {
                  scalar_edge_lengths_algorithm,
                  element mesh {
                     attribute name { "CoordinateMesh" }
                  },
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Calculate the horizontal stream function psi where:
         ##   \partial_x \psi = -v
         ##   \partial_y \psi = u
         ## where u and v are perpendicular to the gravity direction. Applies a
         ## strong Dirichlet boundary condition of 0 on all boundaries.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HorizontalStreamFunction" },
            attribute depends { "Velocity" },
            (
              element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  ## Solver
                  element solver {
                     linear_solver_options_sym
                  },
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Speed:
         ##
         ##  |u|
         ##
         ## Limitations:
         ##  - The Speed and Velocity fields must be on the same mesh.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "Speed" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|

         ## Absolute Difference between two scalar fields.
         ##
         ## Both fields must be in this material_phase.
         ## Assumes both fields are on the same mesh as the AbsoluteDifference field.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "AbsoluteDifference" },
            (
               element diagnostic {
                  internal_algorithm,
                  attribute field_name_a { string },
                  attribute field_name_b { string },
                  mesh_choice,
                  diagnostic_scalar_field,
                  ## Evaluate the absolute difference once the average difference has been removed?
                  element relative_to_average {
                    empty
                  }?,
                  ## Ignore boundary nodes (i.e. zero them when calculating the difference)
                  element ignore_boundaries {
                    empty
                  }?
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|

         ## Absolute Difference between two scalar fields.
         ##
         ## Both fields must be in this material_phase.
         ## Assumes both fields are on the same mesh as the AbsoluteDifference field.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "ScalarAbsoluteDifference" },
            (
               element diagnostic {
                  internal_algorithm,
                  attribute field_name_a { string },
                  attribute field_name_b { string },
                  mesh_choice,
                  diagnostic_scalar_field,
                  ## Evaluate the absolute difference once the average difference has been removed?
                  element relative_to_average {
                    empty
                  }?,
                  ## Ignore boundary nodes (i.e. zero them when calculating the difference)
                  element ignore_boundaries {
                    empty
                  }?
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Galerkin projection of one field onto another mesh.
         ##
         ## The field must be in this material_phase.
         ## 
         ## NOTE: you need the solver options if the mesh
         ## of this field is continuous.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "GalerkinProjection" },
            (
               element diagnostic {
                  legacy_internal_algorithm,
                  element source_field_name { string },
                  mesh_choice,
                  ## Lump the mass matrix of the galerkin projection
                  ## less accurate but faster and might give smoother result.                  
                  element lump_mass {
                     empty
                  }?,
                  element solver {
                    linear_solver_options_sym
                  }?,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Output the processors which own the nodes of the mesh on which this field is based.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "NodeOwner" },
            (
               element diagnostic {
                  legacy_internal_algorithm,
                  mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## An estimate of the edge wieghts whilst adapting using Zoltan
         ## Note: you *must* turn on inteprolation otherwise this field
         ## will be emptied by an adapt.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "MaxEdgeWeightOnNodes" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|

         ## SumVelocityDivergence
         ##
         ## Diagnostic field used in multiphase simulations.
         ## Sums up the divergence of each phase's bulk velocity, i.e. \sum{ div(vfrac*u) }
         element scalar_field {
            attribute rank { "0" },
            attribute name { "SumVelocityDivergence" },
            (
               element diagnostic {
                  velocity_mesh_choice,
                  internal_algorithm,
                  element integrate_divergence_by_parts {
                     empty
                  }?,
                  diagnostic_scalar_field_no_adapt,
                  element solver {
                     linear_solver_options_sym
                  }
               }
            )
         }              

# Insert new diagnostic scalar fields here using the template:
#        element scalar_field {
#            attribute rank { "0" },
#            attribute name { "NewFieldName" },
#            (
#               element diagnostic {
#                  internal_algorithm,
#                  velocity_mesh_choice,
#                  diagnostic_scalar_field
#               }|
#               element aliased {
#                  generic_aliased_field
#               }
#            )
#        }
      )
   )

# This is the choice of additional vector field to be solved for
vector_field_choice =
   (
# The first is a generic field, which may be used for any user-defined field
# that FLUIDITY knows nothing about, or a generic diagnostic
# Prognostic vector fields are not possible (other than velocity and those known fields below).
      (
         ## Generic field variable (vector)
         element vector_field {
            attribute rank { "1" },
            attribute name { xsd:string },
            ## Field type
            (
               element prescribed {
                  mesh_choice,
                  prescribed_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }|
               element diagnostic {
                  vector_diagnostic_algorithms,
                  velocity_mesh_choice,
                  diagnostic_vector_field
               }
            )
         }|
#
# -- List of fields that are primarily prognostic,
#    but can be aliased.
# -- The list is in order of most frequently used.
#
         ## Prescribed vector fields below this
         element ___Prognostic_fields_below___ {
            empty
         }|
#
# -- List of fields that are primarily prescribed,
#    but can be aliased.
# -- The list is in order of most frequently used.
#
         ## Prescribed vector fields below this
         element ___Prescribed_fields_below___ {
            empty
         }|

#
# Insert new prescribed vector fields here using the template:
#        element vector_field {
#            attribute rank { "1" },
#            attribute name { "NewFieldName" },
#            (
#               element prescribed {
#                  mesh_choice,
#                  prescribed_vector_field
#               }|
#               element aliased {
#                  generic_aliased_field
#               }
#            )
#        }
#
# -- Last is a list of fields that are primarily diagnostic,
#    but can be aliased. An example is Tidal Range.
# -- The list is in order of most frequently used.
#
         ## Diagnostic vector fields below this
         element ___Diagnostic_Fields_Below___ {
            empty
         }|

         ## Gradient of a scalar field evaluated using the C gradient
         ## matrix constructed using finite elements.
         ## Field must be in this material_phase.
         element vector_field {
            attribute rank { "1" },
            attribute name { "FiniteElementGradient" },
            (
               element diagnostic {
                  internal_algorithm,
                  attribute field_name { string },
                  mesh_choice,
                  element integrate_gradient_by_parts {
                     empty
                  }?,
                  diagnostic_gradient_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|

         ## Gradient of a scalar field evaluated using the transpose
         ## of the C^T divergence matrix constructed using finite
         ## elements.
         ## Field must be in this material_phase.
         element vector_field {
            attribute rank { "1" },
            attribute name { "FiniteElementDivergenceTransposed" },
            (
               element diagnostic {
                  legacy_internal_algorithm,
                  attribute field_name { string },
                  mesh_choice,
                  element integrate_divergence_by_parts {
                     empty
                  }?,
                  diagnostic_gradient_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|

         ## Gradient of a scalar field evaluated using the transpose
         ## of the C^T matrix constructed using control volumes.
         ## Field must be in this material_phase.
         element vector_field {
            attribute rank { "1" },
            attribute name { "ControlVolumeDivergenceTransposed" },
            (
               element diagnostic {
                  internal_algorithm,
                  attribute field_name { string },
                  velocity_mesh_choice,
                  diagnostic_cv_gradient_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## LinearMomentum field.
         ##  p = \rho*u 
         ## (where p is the linear momentum, \rho the density and u the velocity)
         element vector_field {
             attribute rank { "1" },
             attribute name { "LinearMomentum" },
             (
                element diagnostic {
                   internal_algorithm,
                   velocity_mesh_choice,
                   diagnostic_vector_field
                }|
                element aliased {
                   generic_aliased_field
                }
             )
         }|
         ## Calculate the control volume auxiliary gradient for a particular field.
         ## The related field must be a scalar field in this material_phase.
         element vector_field {
            attribute rank { "0" },
            attribute name { "ControlVolumeAuxiliaryGradient" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  attribute gradient_of_field { string },
                  diagnostic_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Calculate the dg (Bassi Rebay) auxiliary gradient for a particular field.
         ## The related field must be a scalar field in this material_phase.
         element vector_field {
            attribute rank { "0" },
            attribute name { "DGAuxiliaryGradient" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  attribute gradient_of_field { string },
                  diagnostic_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|

         ## Absolute Difference between two vector fields.
         ##
         ## Both fields must be in this material_phase.
         ## Assumes both fields are on the same mesh as the AbsoluteDifference field.
         element vector_field {
            attribute rank { "1" },
            attribute name { "AbsoluteDifference" },
            (
               element diagnostic {
                  internal_algorithm,
                  attribute field_name_a { string },
                  attribute field_name_b { string },
                  mesh_choice,
                  diagnostic_vector_field,
                  ## Evaluate the absolute difference once the average difference has been removed?
                  element relative_to_average {
                    empty
                  }?
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|

         ## Absolute Difference between two vector fields.
         ##
         ## Both fields must be in this material_phase.
         ## Assumes both fields are on the same mesh as the AbsoluteDifference field.
         element vector_field {
            attribute rank { "1" },
            attribute name { "VectorAbsoluteDifference" },
            (
               element diagnostic {
                  internal_algorithm,
                  attribute field_name_a { string },
                  attribute field_name_b { string },
                  mesh_choice,
                  diagnostic_vector_field,
                  ## Evaluate the absolute difference once the average difference has been removed?
                  element relative_to_average {
                    empty
                  }?
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|

         ## Coordinate field remapped to the mesh of your choice.
         element vector_field {
             attribute rank { "1" },
             attribute name { "DiagnosticCoordinate" },
             (
                element diagnostic {
                   internal_algorithm,
                   mesh_choice,
                   diagnostic_vector_field
                }|
                element aliased {
                   generic_aliased_field
                }
             )
         }|

         ## Galerkin projection of one field onto another mesh.
         ##
         ## The field must be in this material_phase.
         ## 
         ## NOTE: you need the solver options if the mesh
         ## of this field is continuous.
         element vector_field {
            attribute rank { "1" },
            attribute name { "GalerkinProjection" },
            (
               element diagnostic {
                  legacy_internal_algorithm,
                  element source_field_name { string },
                  mesh_choice,
                  ## Lump the mass matrix of the galerkin projection
                  ## less accurate but faster and might give smoother result.                  
                  element lump_mass {
                     empty
                  }?,                  
                  element solver {
                  linear_solver_options_sym
                  }?,
                  diagnostic_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }
# Insert new diagnostic vector field here using the template:
#        element vector_field {
#            attribute rank { "1" },
#            attribute name { "NewFieldName" },
#            (
#               element diagnostic {
#                  internal_algorithm,
#                  mesh_choice,
#                  diagnostic_vector_field
#               }|
#               element aliased {
#                  generic_aliased_field
#               }
#            )
#        }
      )
   )  

# This is the choice of additional tensor fields
tensor_field_choice =
   (
# The first is a generic field, which may be used for any user-defined field
# that FLUIDITY knows nothing about, or a generic diagnostic
# Prognostic tensor fields are not possible.
      (
         ## Generic field variable (tensor)
         element tensor_field {
            attribute rank { "2" },
            attribute name { xsd:string },
            ## Field type
            (
               element prescribed {
                  mesh_choice,
                  prescribed_tensor_field
               }|
               element aliased {
                  generic_aliased_field
               }|
               element diagnostic {
                  tensor_diagnostic_algorithms,
                  velocity_mesh_choice,
                  diagnostic_tensor_field
               }
            )
         }|
#
# -- Second is a list of tensor fields that are primarily prescribed,
#    but can be aliased.
# -- The list is in order of most frequently used.
#
         ## Prescribed scalar fields below this
         element ___Prescribed_fields_below___ {
            empty
         }|

#
# Insert new prescribed tensor fields here using the template:
#        element tensor_field {
#            attribute rank { "2" },
#            attribute name { "NewFieldName" },
#            (
#               element prescribed {
#                  mesh_choice,
#                  prescribed_tensor_field
#               }|
#               element aliased {
#                  generic_aliased_field
#               }
#            )
#        }|
#
# -- Last is a list of fields that are primarily diagnostic,
#    but can be aliased.
# -- The list is in order of most frequently used.
#
         ## Diagnostic tensor fields below this
         element ___Diagnostic_Fields_Below___ {
            empty
         }

# Insert new diagnostic tensor field here using the template:
#        element tensor_field {
#            attribute name { "NewFieldName" },
#            (
#               element diagnostic {
#                  internal_algorithm,
#                  mesh_choice,
#                  diagnostic_tensor_field
#               }|
#               element aliased {
#                  generic_aliased_field
#               }
#            )
#        }
      )
   )

cap_option =
   (
      ## Cap the min and max values of this field when using
      ## it as a volume fraction to work out bulk material
      ## properties.
      ## No capping used if not selected.
      element cap_values {
         ## Set the upper bound on the field.
         ## Defaults to huge(0.0)*epsilon(0.0) if not set.
         element upper_cap {
            real
         }?,
         ## Set the lower bound on the field.
         ## Defaults to -huge(0.0)*epsilon(0.0) if not set.
         element lower_cap {
            real
         }?
      }
   )

limiter_options =
  (
      (
        ## Limit the face value to satisfy a boundedness criterion.
        element limit_face_value{
          (
            sweby_limiter|
            ultimate_limiter
          )
        }|
        ## Do not limit the face value
        element do_not_limit_face_value{
          empty
        }
      )
  )

sweby_limiter = 
  ## See "High-Resolution Schemes Using Flux Limiters for
  ## Hyperbolic Conservation-Laws", P. K. Sweby, 1984, Siam
  ## Journal on Numerical Analysis, 21, 995-1011
  element limiter {
    attribute name {"Sweby"},
    slope_options?,
    upwind_value_options?
  }

ultimate_limiter =
  ## See "The Ultimate Conservative Difference Scheme Applied
  ## to Unsteady One-Dimensional Advection", B. P. Leonard,
  ## 1991, Computer Methods in Applied Mechanics and
  ## Engineering, 88, 17-74
  element limiter {
    attribute name {"Ultimate"},
    field_based_cfl_number_options,
    upwind_value_options?
  }

slope_options =
   (
      ## Control the upper and lower slopes of the NVD limiter
      element slopes {
         ## Defaults to Sweby, 1984 limiter (= 1.0) if unselected
         element lower {
            real
         }?,
         ## Defaults to Sweby, 1984 limiter (= 2.0) if unselected
         element upper {
            real
         }?
      }
   )

upwind_value_options =
   (
      (
         ## Select the method to be used for calculating the upwind value.
         ## If not selected will default to project_upwind_value_from_point for
         ## simplex element meshes and to a locally_bound_upwind_value for cube
         ## element meshes.
         ##
         ## This method projects the upwind value from a point in the element just
         ## upwind of the node pair straddling the face.  It is otherwise known as 
         ## anisotropic limiting.
         ## This is only available on simplex meshes as it involes a search around
         ## the donor node to find the upwind element.
         element project_upwind_value_from_point {
            ## When the donor node is on a domain boundary reflect the projection
            ## back into the mesh.
            element reflect_off_domain_boundaries {
               empty
            }?,
            ## Constrain the projected value to be between the min and max of the
            ## element values which it was found from.
            element bound_projected_value_locally {
               empty
            }?,
            ## Store the locations of the elements where the upwind values
            ## are projected from for each node pair.
            ## This inserts an integer csr matrix into state so is memory expensive but
            ## saves a significant amount of time (searching around the neighbouring elements).
            ## This is unsafe for moving meshes but should be ok for adaptive meshes.
            element store_upwind_elements {
               ## Store the quadrature locations within the elements
               ## where the upwind values
               ## are projected from for each node pair.
               ## This inserts a real block csr matrix into state so is even more memory
               ## expensive than just storing the upwind elements and
               ## only saves a comparitively
               ## marginal amount of time (as actually searching the
               ## neighbouring elements is the
               ## slowest bit, finding the quadrature is relatively easy).
               element store_upwind_quadrature {
                  empty
               }?
            }?
         }|
         ## Select the method to be used for calculating the upwind value.
         ## If not selected will default to project_upwind_value_from_point for
         ## simplex element meshes and to a locally_bound_upwind_value for cube
         ## element meshes.
         ##
         ## Projects the value of the advected variable from the downwind or donor node
         ## using the interpolated gradient at the donor node in the
         ## direction of the vector
         ## connecting the node pair straddling the face.
         ## This is available on all meshes (except if bounding the values).
         element project_upwind_value_from_gradient {
            (
               ## Select which node to project from:
               ## Project from the downwind node (Jasak et al., 1999) so that:
               ## upwind_value = downwind_value - 2*gradient.vector
               element project_from_downwind_value {
                  comment
               }|
               ## Select which node to project from:
               ## Project from the donor node so that:
               ## upwind_value = donor_value - gradient.vector
               element project_from_donor_value {
                  comment
               }
            ),
            ## When the donor node is on a domain boundary reflect the projection
            ## back into the mesh.
            element reflect_off_domain_boundaries {
               empty
            }?,
            ## Constrain the projected value to be between the min and max of the
            ## element values which surround it.
            ## This is only available on simplex meshes as it involes a search around
            ## the donor node to find the upwind element.
            element bound_projected_value_locally {
               ## Store the locations of the elements closest to the project value.
               ## This inserts an integer csr matrix into state so is
               ## memory expensive but
               ## saves a significant amount of time (searching around
               ## the neighbouring elements).
               ## This is unsafe for moving meshes but should be ok for adaptive meshes.
               element store_upwind_elements {
                  comment
               }?
            }?
         }|
         ## Select the method to be used for calculating the upwind value.
         ## If not selected will default to project_upwind_value_from_point for
         ## simplex element meshes and to a locally_bound_upwind_value for cube
         ## element meshes.
         ##
         ## Chooses an upwind value by selecting the maximum or minimum of the neighbouring
         ## nodes depending on the local slope of the donor and downwind values.
         ## Otherwise known as isotropic limiting.
         ## This is available on all meshes except periodic domains.
         element locally_bound_upwind_value {
            empty
         }|
         ## Select the method to be used for calculating the upwind value.
         ## If not selected will default to project_upwind_value_from_point for
         ## simplex element meshes and to a locally_bound_upwind_value for cube
         ## element meshes.
         ##
         ## Chooses an upwind value by selecting the value at the node most directy
         ## upwind from the vector connecting the donor and downwind nodes.
         ## This is available on all meshes.
         element pseudo_structured_upwind_value {
            empty
         }
      )
   )

field_based_cfl_number_options =
   (
      (
         ## Select the Courant Number definition to be used.
         ##
         ## This uses the control volume definition of the CFL Number.
         element courant_number {
            attribute name { "ControlVolumeCFLNumber" },
            empty
         }|
         ## ***UNDER TESTING***
         ##
         ## Select the Courant Number definition to be used.
         ##
         ## This uses the control volume definition of the CFL Number.
         element courant_number {
            attribute name { "CVMaterialDensityCFLNumber" },
            empty
         }|
         ## Select the Courant Number definition to be used.
         ##
         ## This uses the finite element approximation of the CFL Number.
         element courant_number {
            attribute name { "CFLNumber" },
            empty
         }|
         ## Select the Courant Number definition to be used.
         element courant_number {
            attribute name { string },
            empty
         }
      )
   )

cv_face_cfl_number_options =
   (
      (
         ## Select the Courant Number definition to be used in the slope of
         ## the NVD diagram upper bound.
         ## This uses the control volume definition of the CFL Number.
         element courant_number {
            attribute name { "ControlVolumeCFLNumber" },
            empty
         }|
         ## ***UNDER TESTING***
         ##
         ## Select the Courant Number definition to be used in the slope of
         ## the NVD diagram upper bound.
         ## This uses a control volume definition of the CFL Number
         ## that incorporates the MaterialDensity.
         ## Requires a MaterialDensity field in this material_phase!
         element courant_number {
            attribute name { "CVMaterialDensityCFLNumber" },
            empty
         }|
         ## ***UNDER TESTING***
         ##
         ## Select the Courant Number definition to be used in the slope of
         ## the NVD diagram upper bound.
         ## This uses the finite element approximation of the CFL Number.
         element courant_number {
            attribute name { "CFLNumber" },
            empty
         }|
         ## ***UNDER TESTING***
         ##
         ## Select the Courant Number definition to be used in the slope of
         ## the NVD diagram upper bound.
         element courant_number {
            attribute name { string },
            empty
         }
      )
   )

timestep_cfl_number_options =
   (
      (
         ## Select the Courant Number definition to be used for adaptive timestepping.
         ## This uses the finite element approximation of the CFL Number.
         element courant_number {
            attribute name { "CFLNumber" },
              ## Select the mesh on which you wish to evaluate the CFLNumber.
              velocity_mesh_choice
         }|
         ## Select the Courant Number definition to be used for adaptive timestepping.
         ## This uses the control volume definition of the CFL Number.
         element courant_number {
            attribute name { "ControlVolumeCFLNumber" },
              ## Select the mesh on which you wish to evaluate the ControlVolumeCFLNumber.
              velocity_mesh_choice
         }
      )
   )

mixing_stats =
   (
      ## Enable to include in the .stat file the fractions of the
      ## scalar field contained in
      ## bins specified by the user. This allows mixing of the field to be quantified.
      ## Replaces and expands upon the old heaviside.dat file
      element include_mixing_stats{
         attribute name { xsd:string },
         (
            ## Select whether to evaluate the volume fraction over the finite element
            ## (continuous galerkin) or within the control volume (control_volumes).
            ##
            ## NOTE: continuous_galerkin only works with linear tets
            ##
            ## NOTE: continuous_galerkin is not fully validated yet
            element continuous_galerkin {
               ## if select normalise the volume fractions will be
               ## divided by the total volume of the domain
               element normalise {
                  empty
               }?
            }|
            ## Select whether to evaluate the volume fraction over the finite element
            ## (continuous galerkin) or within the control volume (control_volumes).
            element control_volumes {
               ## if select normalise the volume fractions will be divided by the total volume of the domain  
               element normalise {
                  empty
               }?
            }
         ),
         ## The values of the bounds of the bins 
         ## e.g. the values -1.5 0.0 1.5 2.0 will return 4 bins 
         ## and the fraction of the field in each bin with,
         ## -1.5<=field<0.0, 0.0<=field<1.5, 1.5<=field<2.0, 2.0<=field, 
         ## will be calculated.  
         element mixing_bin_bounds { 
            (
                 ## list of bin bounds
                 element constant { 
                     real_vector
                 }|
                 ## Python function prescribing bin bounds. Functions should be of the form:
                 ##
                 ##  def val(t):
                 ##     # Function code
                 ##     return # Return value that should be an array of reals
                 ##
                 ## 
                 element python {
                     python_code
                   }
              )
         },
         ## Define the tolerance beneath the specified bins that should be included.
         ## Defaults to zero at machine tolerance (epsilon(0.0)) if not selected.
         element tolerance {
            real
         }?
      }
   )

cv_stats =
   (
      ## Include statistics evaluated on the control volume mesh.
      element include_cv_stats {
         empty
      }
   )

# Options for inclusion of calculations of surface integrals in the .stat file   
surface_integral_stats_base.surface_integral =
   (
      attribute name { xsd:string },
      ## Surface IDs defining the surface over which to integrate. If disabled, integrates over the whole surface.
      element surface_ids {
         integer_vector
      }?,
      ## Enable to normalise the integral by dividing by the surface area
      element normalise {
         comment
      }?
   )
surface_integral_stats_scalar =
   (
      ## Surface integral calculations. The following integral types are available:
      ##  value: Integrates the field
      ##  gradient_normal: Integrates the normal component of the gradient of the field
      element surface_integral {
         surface_integral_stats_scalar.surface_integral
      }
   )
surface_integral_stats_scalar.surface_integral = surface_integral_stats_base.surface_integral
surface_integral_stats_scalar.surface_integral &=
   (
      attribute type { "value" | "gradient_normal" }
   )
surface_integral_stats_vector =
   (
      ## Surface integral calculations. The following integral types are available:
      ##  normal: Integrates the normal component of the field
      element surface_integral {
         surface_integral_stats_vector.surface_integral
      }
   )
surface_integral_stats_vector.surface_integral = surface_integral_stats_base.surface_integral
surface_integral_stats_vector.surface_integral &=
   (
      attribute type { "normal" }
   )

recalculation_options =
   (
      ## Prevent this field from being recalculated at every timestep.
      ## This is cheaper especially if you are enforcing discrete properties on the field.
      element do_not_recalculate {
        empty
      }
   )

discrete_properties_algorithm_scalar =
   (
      ## Select discrete properties to enforce on the field
      ## either after being prescribed or interpolated
      element enforce_discrete_properties {
        ## Update this field using the lagrangian multiplier
        ## calculated in the solenoidal projection of a
        ## scalar field.
        ##
        ## Note this field must be specified as the update field
        ## underneath that vector field too.
        ##
        ## Note also this only really makes sense for coupled
        ## fields like velocity and pressure.
        element solenoidal_lagrange_update {
          empty
        }?
      }
   )

discrete_properties_algorithm_vector =
   (
      ## Select discrete properties to enforce on the field
      ## either after being prescribed or interpolated
      element enforce_discrete_properties {
        solenoidal_options?
      }
   )

solenoidal_options =
    ## Constrained divergence-free projection.
    ## This adds an additional constraint that ensures that the field
    ## is solenoidal, i.e. divergence-free.
    ## This is equivalent in cost to a pressure solve.
    ## This is expensive, and thus best left until
    ## needed.
    ##
    ## Note well: this only makes sense for nondivergent
    ## vector fields, such as incompressible velocity!
    element solenoidal {
      ## Options for the mass matrix of the field being interpolated
      element interpolated_field {
        (
          element continuous {
            ## Lump the mass matrix for the assembly of the projection matrix
            ## (not for the initial galerkin projection)
            ##
            ## Required when using interpolating continuous fields
            element lump_mass_matrix {
              ## Lump on the submesh.
              ## This only works for simplex meshes and is only
              ## strictly valid on 2d meshes.
              element use_submesh {
                empty
              }?
            }
          }|
          element discontinuous {
            ## Lump the mass matrix for the assembly of the projection matrix
            ## (not for the initial galerkin projection)
            element lump_mass_matrix {
              empty
            }?
          }
        )
      },
      ## Options for the lagrange multiplier
      ##
      ## Must be on a continuous mesh!
      element lagrange_multiplier {
        pressure_mesh_choice,
        element spatial_discretisation {
          (
            element continuous_galerkin {
              ## Remove the stabilisation term from the projection operator.
              ##
              ## Automatic when not using P1P1.
              element remove_stabilisation_term {
                empty
              }?,
              ## Integrate the divergence operator by parts.
              ##
              ## Automatic when projecting a discontinuous field
              element integrate_divergence_by_parts {
                empty
              }?
            }|
            element control_volumes {
              empty
            }
          )
        },
        element reference_node {
          integer
        }?,
        ## **UNDER DEVELOPMENT**
        ## This searches the CMC matrix diagonal looking for nodes that are less than the maximum value time epsilon(0.0) (i.e. nodes that are effectively zero).
        ## It then zeros that row and column and places a one on the diagonal and a zero on the rhs.
        ## At a debug level of 2 it also prints out the value and the sum of the row values.
        ## This is useful as a debugging tool if PETSc complains about zeros on the diagonal (i.e. if you have a stiff node in your mesh) but doesn't necessary produce nice answers at the end.
        element repair_stiff_nodes {
           empty
        }?,
        (
          ## Update a scalar field using the lagrange multiplier from
          ## the divergence free projection of this field.  The selected
          ## scalar field must have solenoidal selected in its interpolation
          ## options too and it must be on the same mesh as used for the
          ## solenoidal projection above.
          ##
          ## Note well: this only really makes sense for scalar fields linked to nondivergent
          ## vector fields, such as pressure to incompressible velocity!                  
          element update_scalar_field {
            attribute name { "Pressure" },
            empty
          }|
          ## Update a scalar field using the lagrange multiplier from
          ## the divergence free projection of this field.  The selected
          ## scalar field must have solenoidal selected in its interpolation
          ## options too and it must be on the same mesh as used for the
          ## solenoidal projection above.
          ##
          ## Note well: this only really makes sense for scalar fields linked to nondivergent
          ## vector fields, such as pressure to incompressible velocity!                  
          element update_scalar_field {
            attribute name { string },
            empty
          }
        )?,
        ## Solver options for the linear solve.
        ## This method requires the inversion of a projection matrix.
        element solver {
          linear_solver_options_sym
        }
      }
    }

represcribe_before_interpolation =
    ## Represcribe the field before interpolation.
    ##
    ## This means the interpolation will not be conservative from the previous mesh so be careful what you're trying to achieve!
    element represcribe_before_interpolation {
      empty
    } 
