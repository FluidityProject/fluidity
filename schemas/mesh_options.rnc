mesh_info =
   (
      ## Read mesh from file.
      element from_file {
         (
            ## Triangle mesh format.
            ##
            ## Enter the base name without the .edge .ele, .face or
            ## .node extensions, and without process numbers.
            element format {
              attribute name { "triangle" },
              comment
            }|
            ## Read the mesh from a vtu. Note that the mesh will have no 
            ## surface or region IDs.
            element format {
              attribute name { "vtu" },
              comment
            }|
            ## GMSH mesh format
            element format {
               attribute name { "gmsh" },
               comment
            }|
            ## ExodusII mesh format.
            ##
            ##<b>Note: Only works for serial mesh files and 
            ## Checkpoints are dumped in the GMSH file format.</b>
            element format {
               attribute name { "exodusii" },
               comment
            }
         ),
         attribute file_name { xsd:string },
         element dimension {
            integer
         }?,
         from_file_mesh_stat_options,
         comment
      }|
      ## Make mesh from existing mesh. 
      element from_mesh {
         mesh_choice,
         element mesh_shape {
            element polynomial_degree {
               integer
            }?,
            element element_type {
               ## Select the element type. "lagrangian" means the usual
               ## Pn element type. "bubble" adds bubble functions that
               ## vanish on the element boundaries, and
               ## trace defines an element that is only defined on faces
               ## and is undefined on the element interior (used for 
               ## enforcing continuity by Lagrange multipliers).
              element string_value{
                 "lagrangian" | "bubble" | "trace"
              }
            }?
         }?,
         element mesh_continuity {
            element string_value{
               "continuous" | "discontinuous"
            }
         }?,
         element constraint_type {
            ## Set the constraint type. This is used to implement
            ## div-conforming elements such as RT0 in a hybridised
            ## solver.
            element string_value{
               "BDM" | "BDFM" | "RT"
            },
            element solver {
               ## Solver is used to apply projections to div-conforming
               ## space, and in elliptic solvers
               linear_solver_options_sym
            }
         }?,
         ## Make mesh periodic
         element periodic_boundary_conditions {
            attribute name { xsd:string },
            ## List of boundary ids that are aliased to
            element physical_boundary_ids {
               integer_vector
            },
            ## List of boundary ids that are aliased
            element  aliased_boundary_ids {
               integer_vector
            },
            ## Python code which takes coordinate of an aliased
            ## boundary node and returns the coordinate of a physical
            ## boundary node.
            ## Note that in adaptive simulations this will be applied to
            ## arbitrary points in space, not just those on the original aliased
            ## boundary.
            ## Python function prescribing real input. Functions should be of the form:
            ##
            ##  def val(X, t):
            ##     # Function code
            ##     return # Return value
            ##
            ## where X is a tuple of length geometry dimension and t is time
            element coordinate_map {
               python_code
            },
            ## Python code which takes coordinate of a physical
            ## boundary node and returns the coordinate of an aliased
            ## boundary node. This is used in adaptive simulations to
            ## keep the adapted domain inside the bounding box of the
            ## original domain.
            ## Python function prescribing real input. Functions should be of the form:
            ##
            ##  def val(X, t):
            ##     # Function code
            ##     return # Return value
            ##
            ## where X is a tuple of length geometry dimension and t is time
            element inverse_coordinate_map {
               python_code
            }?,
            ## <b>Don't turn this on by hand!</b>
            ## This option gets set by the periodise tool, to indicate
            ## that this mesh should have the periodic boundary conditions
            ## <b>removed</b>. See the discussion on the wiki about 
            ## parallel periodic boundary conditions.
            element remove_periodicity {
               empty
            }?
         }*,
         ## Extrude a horizontal (1D or 2D) mesh in the vertical
         element extrude {
            (
              ## Extrusion options for WholeMesh
              ##
              ## Only specify one set of parameters if not using mesh regions.
              ## Otherwise select other regions option, specify region_ids
              ## and distinct names.  Then add extra regions for other regions.
              element regions {
                attribute name { "WholeMesh" },
                extrusion_options
              }|
              ## Multiple extrusion options are allowed if specifying
              ## different values in different
              ## regions of the mesh (defined by region_ids).  In this case
              ## each set of options
              ## requires a distinct name for the options dictionary.
              element regions {
                attribute name { string },
                region_ids?,
                extrusion_options
              }
            )+,
            ## This is an internal option used by checkpointing. The 
            ## option is switched on automatically in writing a 
            ## checkpoint, so that when starting from the checkpoint .flml
            ## fluidity picks up the extruded mesh from file. After the next
            ## adapt the extrusion is again done as specified in the other
            ## extrusion options and under the adaptivity options.
            element checkpoint_from_file {
               (
                  ## Triangle mesh format.
                  ##
                  ## Enter the base name without the .edge .ele, .face or
                  ## .node extensions, and without process numbers.
                  element format {
                     attribute name { "triangle" },
                     comment
                  }|

                  ## GMSH mesh format
                  element format {
                     attribute name { "gmsh" },
                     comment
                  }
               ),
               attribute file_name { xsd:string },
               comment
            }?
         }?,
         derived_mesh_stat_options,
         comment
      }
   )

# Options for inclusion/exclusion of mesh statistics from the .stat file
include_mesh_in_stat =
   (
      ## Include this mesh in the .stat file
      element include_in_stat {
         comment
      }
   )
exclude_mesh_from_stat =
   (
      ## Exclude this mesh from the .stat file
      element exclude_from_stat {
         comment
      }
   )

# Diagnostic statistics options for meshed, with enabled by default
mesh_stat_options_enabled_default =
   (
      include_mesh_in_stat|
      exclude_mesh_from_stat
   )

# Diagnostic statistics options for meshed, with disabled by default
mesh_stat_options_disabled_default = 
   (
      exclude_mesh_from_stat|
      include_mesh_in_stat
   )

from_file_mesh_stat_options =
   (
      ## Specify what is added to .stat files
      element stat {
         mesh_stat_options_enabled_default
      }
   )
derived_mesh_stat_options =
   (
      ## Specify what is added to .stat files
      element stat {
         mesh_stat_options_disabled_default
      }
   )

extrusion_options = 
   (
      ## Bottom bathymetry to extrude down to. 
      ## If top_position is not defined, the 
      ## extrude originates from the surface
      ## z = 0.0.  The extrude develops the mesh
      ## down to z = - bottom_depth
      ## (Note the sign convention)
      element bottom_depth {
          input_choice_real_plus_map
      },
      ## Optional surface from which to develop
      ## the extrusion from.  Default is z = 0.0.
      ## This follows the same sign convention as
      ## bottom_depth above, so a positive value
      ## represents a negative deviation from the
      ## z = 0.0 geoid.
      element top_position {
          input_choice_real_plus_map,
          ## Ensure layers are aligned with geoids.
          ## Note that boundary representation is maintained
          ## and takes precedence, so although nodes within
          ## the domain will lie on geoids, nodes on bondaries
          ## may not.  This is the best option if nodes are to
          ## be kept vertically-aligned.
          ##
          ## Note that this option is fundamentally incompatible
          ## with sigma layers, and both cannot be applied in the 
          ## same region.
          element align_with_geoids {
            empty
          }?,
          ## By default the layers are positioned from the
          ## topmost point for each region and partition, or
          ## with align_with_geoids, this is from the topmost
          ## point in the entire domain.
          ## This value will displace the position of layers.
          ## A positive value displaces in positive z or r.
          ## Note this is not an absolute displacement, the
          ## functions to determine layer thickness etc are
          ## still evaluated at the new layer positions.
          ## Note also that the absolute value is used.
          element displace_layer_position {
            real
          }?
      }?,
      ## Constant or function to specify the depth of the
      ## layers. The function is a function of all coordinates
      ## (so in 2+1D: x,y and z) to specify a layer depth that
      ## varies both in the horizontal as in the vertical.
      element sizing_function {
          input_choice_real_plus_list,
      ## If your sizing function only varies in z enable this options.
      ## Do not use if your function depends on x and/or y as it takes a column of z values and re-uses it. 
          element varies_only_in_z {empty}?
      },
      ## To prevent infinitesimally-thin boundary layers if the 
      ## sizing function is an integer multiple of total depth,
      ## the bottom and top layers need to have at least this 
      ## fraction of the layer depth above it.
      ##
      ## Note that in the case of the top surface, this option
      ## only has an effect if /top_position/align_with_geoids
      ## is selected.
      ##
      ## Default is 1e-3.
      element minimum_layer_fraction {
          real
      }?,
      ## surface_id to assign to the top of the extruded mesh
      element top_surface_id {
          integer
      }?,
      ## surface_id to assign to the bottom of the extruded mesh
      element bottom_surface_id {
          integer
      }?
   )

# Most common mesh choices
mesh_choice = 
   (
      element mesh {
         attribute name { xsd:string }
      }|
      element mesh {
         attribute name { "CoordinateMesh" }
      }|
      element mesh {
         attribute name { "VelocityMesh" }
      }|
      element mesh {
         attribute name { "PressureMesh" }
      }
   )

# Same choices, but with VelocityMesh offered first
velocity_mesh_choice =
   (
      element mesh {
         attribute name { "VelocityMesh" }
      }|
      element mesh {
         attribute name { "PressureMesh" }
      }|
      element mesh {
         attribute name { "CoordinateMesh" }
      }|
      element mesh {
         attribute name { string }
      }
   )

# Same choices, but with PressureMesh offered first
pressure_mesh_choice =
   (
      element mesh {
         attribute name { "PressureMesh" }
      }|
      element mesh {
         attribute name { "VelocityMesh" }
      }|
      element mesh {
         attribute name { "CoordinateMesh" }
      }|
      element mesh {
         attribute name { string }
      }
   )

# Same choices, but with CoordinateMesh offered first
coordinate_mesh_choice =
   (
      element mesh {
         attribute name { "CoordinateMesh" }
      }|
      element mesh {
         attribute name { "VelocityMesh" }
      }|
      element mesh {
         attribute name { "PressureMesh" }
      }|
      element mesh {
         attribute name { string }
      }
   )
