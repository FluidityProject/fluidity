<?xml version="1.0" encoding="UTF-8"?>
<grammar xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0" xmlns="http://relaxng.org/ns/structure/1.0" datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes">
  <!-- these are the options under the solver/ block for the prognostic fields -->
  <!--
    the only difference between the _asym and _sym versions
    is the order of cg and gmres. Not providing cg for _asym is
    not possible as in some cases the asymmetric equation is in fact symmetric
    (e.g. momentum with no advection or coriolis).
  -->
  <define name="linear_solver_options_asym">
    <choice>
      <a:documentation>Iterative (Krylov) method to solve the linear discretised equation
Given are the most frequently used methods. The solution is done
by the PETSc library. Many more methods are provided.
</a:documentation>
      <ref name="kspgmres_options"/>
      <ref name="kspcg_options"/>
      <ref name="ksppreonly_options"/>
      <ref name="ksprichardson_options"/>
      <ref name="kspother_options"/>
    </choice>
    <choice>
      <a:documentation>Preconditioner to be used in combination with the iterative method.</a:documentation>
      <ref name="pcsor_options"/>
      <ref name="pceisenstat_options"/>
      <ref name="pcilu_options"/>
      <ref name="pclu_options"/>
      <ref name="pcmg_options_no_lumping"/>
      <ref name="pcprometheus_options"/>
      <ref name="pchypre_options"/>
      <ref name="pcbjacobi_options"/>
      <ref name="pcasm_options"/>
      <ref name="pcother_options"/>
    </choice>
    <ref name="generic_solver_options"/>
  </define>
  <define name="linear_solver_options_sym">
    <choice>
      <a:documentation>Iterative (Krylov) method to solve the linear discretised equation
Given are the most frequently used methods. The solution is done
by the PETSc library. Many more methods are provided.
</a:documentation>
      <ref name="kspcg_options"/>
      <ref name="kspgmres_options"/>
      <ref name="ksppreonly_options"/>
      <ref name="ksprichardson_options"/>
      <ref name="kspother_options"/>
    </choice>
    <choice>
      <a:documentation>Preconditioner to be used in combination with the iterative method.</a:documentation>
      <ref name="pcsor_options"/>
      <ref name="pceisenstat_options"/>
      <ref name="pcilu_options"/>
      <ref name="pcicc_options"/>
      <ref name="pclu_options"/>
      <ref name="pcmg_options"/>
      <ref name="pcprometheus_options"/>
      <ref name="pchypre_options"/>
      <ref name="pcbjacobi_options"/>
      <ref name="pcasm_options"/>
      <ref name="pcksp_options"/>
      <ref name="pcother_options"/>
    </choice>
    <ref name="generic_solver_options"/>
  </define>
  <!--
    ####################################################################
    
    options for the different iterative ksp methods
    
    ####################################################################
  -->
  <define name="kspgmres_options">
    <element name="iterative_method">
      <a:documentation>GMRES

Your safest bet for non-symmetric systems.</a:documentation>
      <attribute name="name">
        <value>gmres</value>
      </attribute>
      <element name="restart">
        <a:documentation>Restart value for gmres iteration
Higher values give better convergence but require more memory.
Suggested value: 30</a:documentation>
        <ref name="integer"/>
      </element>
    </element>
  </define>
  <define name="kspcg_options">
    <element name="iterative_method">
      <a:documentation>Conjugate gradient method

Only works for symmetric systems.</a:documentation>
      <attribute name="name">
        <value>cg</value>
      </attribute>
    </element>
  </define>
  <define name="ksppreonly_options">
    <element name="iterative_method">
      <a:documentation>Direct method

This is for non-iterative methods
Only makes sense in combination with preconditioners that do a complete solve, e.g. lu.</a:documentation>
      <attribute name="name">
        <value>preonly</value>
      </attribute>
    </element>
  </define>
  <define name="ksprichardson_options">
    <element name="iterative_method">
      <a:documentation>Richardson iteration

Only apply preconditioner each iteration, no krylov acceleration</a:documentation>
      <attribute name="name">
        <value>richardson</value>
      </attribute>
    </element>
  </define>
  <define name="kspother_options">
    <element name="iterative_method">
      <a:documentation>Other methods

Any method provided by the PETSc library
http://www-unix.mcs.anl.gov/petsc/petsc-2/snapshots/petsc-dev/docs/manualpages/KSP/KSPType.html
(available methods may depend on the PETSc library installed on your system)</a:documentation>
      <attribute name="name">
        <data type="string"/>
      </attribute>
    </element>
  </define>
  <!--
    ####################################################################
    
    options for the different preconditioners
    
    ####################################################################
  -->
  <define name="pcsor_options">
    <element name="preconditioner">
      <a:documentation>Succesive Over-Relaxation

This includes SSOR (symmetric sor)</a:documentation>
      <attribute name="name">
        <value>sor</value>
      </attribute>
    </element>
  </define>
  <define name="pceisenstat_options">
    <element name="preconditioner">
      <a:documentation>The Eisenstat method

This preconditioner is equivalent to SOR but only uses
half the number of flops,
i.e. same convergence rate but twice as fast per
iteration. Because it computes
a different preconditioned residual the convergence in
practice may be quite different though.
It does not work in parallel!</a:documentation>
      <attribute name="name">
        <value>eisenstat</value>
      </attribute>
    </element>
  </define>
  <define name="pcilu_options">
    <element name="preconditioner">
      <a:documentation>Incomplete LU decomposition</a:documentation>
      <attribute name="name">
        <value>ilu</value>
      </attribute>
    </element>
  </define>
  <define name="pcicc_options">
    <element name="preconditioner">
      <a:documentation>Incomplete Cholesky decomposition (only works for symmetric matrices)</a:documentation>
      <attribute name="name">
        <value>icc</value>
      </attribute>
    </element>
  </define>
  <define name="pclu_options">
    <element name="preconditioner">
      <a:documentation>LU direct solver

This performs a complete, direct solve of the equation and should only be used in combination with preonly as iterative method.</a:documentation>
      <attribute name="name">
        <value>lu</value>
      </attribute>
    </element>
  </define>
  <define name="pcmg_options">
    <element name="preconditioner">
      <a:documentation>Fluidity`s own multigrid method

Especially suited for ill-conditioned, large aspect ratio problems.</a:documentation>
      <attribute name="name">
        <value>mg</value>
      </attribute>
      <optional>
        <element name="vertical_lumping">
          <a:documentation>apply vertical lumping from the full mesh to the surface mesh
as the first coarsening step instead of the default
aggregation method.</a:documentation>
          <optional>
            <element name="internal_smoother">
              <a:documentation>Does additional smoothing by solving the equation but with
a dirichilet boundary condition on top given by the last iteration
of the multigrid cycle. May be quite expensive per iteration
but improves the solution quite a lot for difficult meshes.</a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
      </optional>
    </element>
  </define>
  <define name="pcmg_options_no_lumping">
    <element name="preconditioner">
      <a:documentation>Fluidity`s own multigrid method

Especially suited for ill-conditioned, large aspect ratio problems.</a:documentation>
      <attribute name="name">
        <value>mg</value>
      </attribute>
    </element>
  </define>
  <define name="pcprometheus_options">
    <element name="preconditioner">
      <a:documentation>Prometheus multigrid method</a:documentation>
      <attribute name="name">
        <value>prometheus</value>
      </attribute>
    </element>
  </define>
  <define name="pchypre_options">
    <element name="preconditioner">
      <a:documentation>Hypre preconditioners (includes boomeramg)</a:documentation>
      <attribute name="name">
        <value>hypre</value>
      </attribute>
      <choice>
        <element name="hypre_type">
          <a:documentation>BoomerAMG multigrid method</a:documentation>
          <attribute name="name">
            <value>boomeramg</value>
          </attribute>
        </element>
        <element name="hypre_type">
          <a:documentation>Other Hypre preconditioners</a:documentation>
          <attribute name="name">
            <data type="string" datatypeLibrary=""/>
          </attribute>
        </element>
      </choice>
    </element>
  </define>
  <define name="pcbjacobi_options">
    <element name="preconditioner">
      <a:documentation>Block Jacobi

This option is for parallel runs. A preconditioner is applied
locally within each domain. This means within the domain you can
choose whatever preconditioner you would choose in serial. Because
there is no coupling between the domains in the preconditioning
the performance may be less than in serial and degrade with 
increasing number of processors/decreasing local domain size.</a:documentation>
      <attribute name="name">
        <value>bjacobi</value>
      </attribute>
      <ref name="subpc_options"/>
    </element>
  </define>
  <define name="pcasm_options">
    <element name="preconditioner">
      <a:documentation>Additive Schwartz Method

This option is for parallel runs. A preconditioner is applied
locally within each domain (like bjacobi) only the local domains
are extended a bit to overlap. This increases the coupling between
the domain and thus improves the convergence. This does of course
increase the communication cost, so iterations may be more expensive
than with bjacobi.</a:documentation>
      <attribute name="name">
        <value>asm</value>
      </attribute>
      <ref name="subpc_options"/>
    </element>
  </define>
  <!-- sub preconditioner to choose for bjacobi or asm -->
  <define name="subpc_options">
    <choice>
      <a:documentation>Preconditioner to apply within the local domains</a:documentation>
      <ref name="pcsor_options"/>
      <ref name="pceisenstat_options"/>
      <ref name="pcilu_options"/>
      <ref name="pcicc_options"/>
      <ref name="pclu_options"/>
      <ref name="pcmg_options"/>
      <ref name="pcprometheus_options"/>
      <ref name="pchypre_options"/>
      <ref name="pcother_options"/>
    </choice>
  </define>
  <define name="pcother_options">
    <element name="preconditioner">
      <a:documentation>Other preconditioners

Any preconditioner provided by the PETSc library
http://www-unix.mcs.anl.gov/petsc/petsc-2/snapshots/petsc-dev/docs/manualpages/PC/PCType.html
(available preconditiors may depend on the PETSc library installed on your system)</a:documentation>
      <attribute name="name">
        <data type="string" datatypeLibrary=""/>
      </attribute>
    </element>
  </define>
  <define name="pcksp_options">
    <element name="preconditioner">
      <a:documentation>This only makes sense for solves where a different approximated preconditioner
matrix is provided. For instance when solving pressure with the 
option full_schur_complement and using a masslumped schur complement
as preconditioner matrix.

NOTE: If you are using a krylov method (cg/gmres) for this preconditioner 
solve you either need to set your tolerances much stricter for it
than in the outer solve (so that the preconditioner is close to an
exact matrix inversion), or use fgmres in the outer solve.</a:documentation>
      <attribute name="name">
        <value>ksp</value>
      </attribute>
      <element name="solver">
        <a:documentation>Solver options for the full solve done by this preconditioner</a:documentation>
        <ref name="pc_ksp_solver_options"/>
      </element>
    </element>
  </define>
  <!--
    this is a copy linear_solver_options_sym, but with preconditioner "ksp"
    removed to avoid infinite recursion
  -->
  <define name="pc_ksp_solver_options">
    <choice>
      <a:documentation>Iterative (Krylov) method to solve the linear discretised equation
Given are the most frequently used methods. The solution is done
by the PETSc library. Many more methods are provided.
</a:documentation>
      <ref name="kspcg_options"/>
      <ref name="kspgmres_options"/>
      <ref name="ksppreonly_options"/>
      <ref name="ksprichardson_options"/>
      <ref name="kspother_options"/>
    </choice>
    <choice>
      <a:documentation>Preconditioner to be used in combination with the iterative method.</a:documentation>
      <ref name="pcsor_options"/>
      <ref name="pceisenstat_options"/>
      <ref name="pclu_options"/>
      <ref name="pcicc_options"/>
      <ref name="pcmg_options"/>
      <ref name="pcprometheus_options"/>
      <ref name="pchypre_options"/>
      <ref name="pcbjacobi_options"/>
      <ref name="pcasm_options"/>
      <ref name="pcother_options"/>
    </choice>
    <ref name="generic_solver_options"/>
  </define>
  <!--
    ####################################################################
    
    all the other solver options
    
    ####################################################################
  -->
  <define name="generic_solver_options">
    <element name="relative_error">
      <a:documentation>Relative error

The solver finishes if the preconditioned error becomes smaller than the original preconditioned error times this value.
Suggested value: 1.0e-7</a:documentation>
      <ref name="real"/>
    </element>
    <optional>
      <element name="absolute_error">
        <a:documentation>Absolute error bound

The solver finishes if the preconditioned error becomes smaller than this value.</a:documentation>
        <ref name="real"/>
      </element>
    </optional>
    <element name="max_iterations">
      <a:documentation>Maximum number of iterations allowed in the linear solver
before giving up.</a:documentation>
      <ref name="integer"/>
    </element>
    <optional>
      <element name="start_from_zero">
        <a:documentation>Switch on to not use an initial guess from a previous solve but
start with a zero vector. Note that some of the solves always
start at zero in which case this switch will have no effect (see the log output).</a:documentation>
        <empty/>
      </element>
    </optional>
    <optional>
      <element name="remove_null_space">
        <a:documentation>Remove Null-space from residual after applying preconditioner.
This often leads to better convergence rates, when compared to
imposing a reference_node to pin the solution.</a:documentation>
        <empty/>
      </element>
    </optional>
    <choice>
      <element name="never_ignore_solver_failures">
        <a:documentation>Solver failures are always treated as fatal errors. The
model stops at the end of the time step in order to allow
for the latest output to be written.</a:documentation>
        <empty/>
      </element>
      <element name="ignore_non_convergence_during_spin_up">
        <a:documentation>Allow for an initial period in which solver failures
caused by non-convergence in the maximum number of
iterations are ignored.</a:documentation>
        <element name="spin_up_time">
          <a:documentation>As long as current_time &lt; spin_up_time, solver failures
due to non-convergence in the maximum number of
iterations are ignored. This might be used for spinning
up the model. As there is no guarantee we're actually
solving the flow equations to any accuracy, the results
in this period should not be trusted.</a:documentation>
          <ref name="real"/>
        </element>
      </element>
      <element name="ignore_all_solver_failures">
        <a:documentation>Ignore all solver failures. This is a dangerous option
that should only be used in exceptional cases.</a:documentation>
        <empty/>
      </element>
    </choice>
    <optional>
      <element name="cache_solver_context">
        <a:documentation>Retain the data created during the setup phase of the solve.
This may give some speedup, in particular in combination with
a multigrid preconditioner, as the data doesn't have to be
recreated every solve, but at the cost of increased memory usage.
This option is only useful for solves where the matrix doesn't
change between time steps, e.g. the pressure solve (only for 
incompressible flow and without mesh movement) or solving
balance pressure.</a:documentation>
        <empty/>
      </element>
    </optional>
    <optional>
      <choice>
        <element name="reordering">
          <a:documentation>Use Reverse Cuthill-McKee reordering to improve cache performance</a:documentation>
          <attribute name="name">
            <value>rcm</value>
          </attribute>
        </element>
        <element name="reordering">
          <a:documentation>Use one way dissecting reordering to improve cache performance</a:documentation>
          <attribute name="name">
            <value>1wd</value>
          </attribute>
        </element>
        <element name="reordering">
          <a:documentation>Use natural ordering as reordering, i.e. change nothing.
Only useful for debugging purposes.</a:documentation>
          <attribute name="name">
            <value>natural</value>
          </attribute>
        </element>
        <element name="reordering">
          <a:documentation>Specify any other reordering mechanism supported by PETSc
see http://www-unix.mcs.anl.gov/petsc/petsc-as/snapshots/petsc-current/docs/manualpages/MatOrderings/MatGetOrdering.html</a:documentation>
          <attribute name="name">
            <data type="string"/>
          </attribute>
        </element>
      </choice>
    </optional>
    <element name="diagnostics">
      <a:documentation>Extra diagnostics to help debug solver problems</a:documentation>
      <optional>
        <element name="print_norms">
          <a:documentation>Print out the norm of vectors and matrices before the
solve, and that of the solution vector afterwards.
Norms are printed at verbosity level 2, so run fluidity with -v2 or -v3</a:documentation>
          <empty/>
        </element>
      </optional>
      <element name="monitors">
        <a:documentation>Options to give extra information for each iteration of the
the solve. Some of those may really slow down your computation!</a:documentation>
        <optional>
          <element name="preconditioned_residual">
            <a:documentation>Prints the preconditioned residual for each iteration of the solve.
This is the error estimation PETSc uses during the solve.</a:documentation>
            <empty/>
          </element>
        </optional>
        <optional>
          <element name="true_residual">
            <a:documentation>Prints the "true" residual for each iteration of the solve,
i.e. PETSc computes the L2-norm of r=A-bx. This may mean
PETSc has to do extra computations.</a:documentation>
            <empty/>
          </element>
        </optional>
        <optional>
          <element name="preconditioned_residual_graph">
            <a:documentation>Draws a graph over the convergence of the preconditioned residual
during the solve. This option only works for systems where PETSc
has been linked with the X library.</a:documentation>
            <empty/>
          </element>
        </optional>
        <optional>
          <element name="true_error">
            <a:documentation>Prints the error by computing the difference with the provided
exact solution each time step.</a:documentation>
            <attribute name="exact_solution_field">
              <a:documentation>Give the field name of the field that contains the exact
solution to be compared with each iteration</a:documentation>
              <data type="string" datatypeLibrary=""/>
            </attribute>
          </element>
        </optional>
      </element>
    </element>
  </define>
  <define name="galerkin_projection_mass_options">
    <choice>
      <element name="lump_mass">
        <a:documentation>Lump the mass matrix</a:documentation>
        <ref name="comment"/>
      </element>
      <element name="solver">
        <a:documentation>Solver options. Required for a continuous consistent mass
projection.</a:documentation>
        <ref name="linear_solver_options_sym"/>
      </element>
    </choice>
  </define>
  <define name="galerkin_projection_mass_options_submesh">
    <choice>
      <element name="lump_mass">
        <a:documentation>Lump the mass matrix</a:documentation>
        <optional>
          <element name="use_submesh">
            <a:documentation>Lump on the submesh.
This only works for simplex meshes and is only
strictly valid on 2d meshes.</a:documentation>
            <ref name="comment"/>
          </element>
        </optional>
        <ref name="comment"/>
      </element>
      <element name="solver">
        <a:documentation>Solver options. Required for a continuous consistent mass
projection.</a:documentation>
        <ref name="linear_solver_options_sym"/>
      </element>
    </choice>
  </define>
</grammar>
