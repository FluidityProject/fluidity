<?xml version="1.0" encoding="UTF-8"?>
<grammar xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0" xmlns="http://relaxng.org/ns/structure/1.0" datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes">
  <include href="spud_base.rng"/>
  <include href="adaptivity_options.rng"/>
  <include href="diagnostic_algorithms.rng"/>
  <include href="input_output.rng"/>
  <include href="solvers.rng"/>
  <include href="stabilisation.rng"/>
  <start>
    <element name="shallow_water_options">
      <a:documentation>The root node of the options dictionary.</a:documentation>
      <ref name="comment"/>
      <element name="simulation_name">
        <a:documentation>Model output files are named according to the simulation
name, e.g. [simulation_name]_0.vtu. Non-standard
characters in the simulation name should be avoided.</a:documentation>
        <ref name="anystring"/>
      </element>
      <element name="geometry">
        <a:documentation>Options dealing with the specification of geometry</a:documentation>
        <element name="dimension">
          <a:documentation>Dimension of the problem.
&lt;b&gt;This can only be set once&lt;/b&gt;</a:documentation>
          <attribute name="replaces">
            <value>NDIM</value>
          </attribute>
          <element name="integer_value">
            <attribute name="rank">
              <value>0</value>
            </attribute>
            <choice>
              <value>2</value>
              <value>1</value>
            </choice>
          </element>
        </element>
        <element name="mesh">
          <a:documentation>The position mesh</a:documentation>
          <attribute name="name">
            <value>CoordinateMesh</value>
          </attribute>
          <ref name="mesh_info"/>
        </element>
        <element name="mesh">
          <a:documentation>The velocity mesh</a:documentation>
          <attribute name="name">
            <value>VelocityMesh</value>
          </attribute>
          <ref name="mesh_info"/>
        </element>
        <element name="mesh">
          <a:documentation>The pressure mesh</a:documentation>
          <attribute name="name">
            <value>PressureMesh</value>
          </attribute>
          <ref name="mesh_info"/>
        </element>
        <zeroOrMore>
          <element name="mesh">
            <attribute name="name">
              <data type="string"/>
            </attribute>
            <ref name="mesh_info"/>
            <optional>
              <element name="exclude_from_mesh_adaptivity">
                <empty/>
              </element>
            </optional>
          </element>
        </zeroOrMore>
        <element name="quadrature">
          <a:documentation>Quadrature</a:documentation>
          <element name="degree">
            <a:documentation>Quadrature degree

note: this specifies the degree of quadrature,
not the number of gauss points</a:documentation>
            <attribute name="replaces">
              <value>NGI</value>
            </attribute>
            <ref name="integer"/>
          </element>
          <optional>
            <element name="surface_degree">
              <a:documentation>Surface quadrature degree

note: this specifies the degree of surface
quadrature not the number of surface gauss points</a:documentation>
              <attribute name="replaces">
                <value>SNGI</value>
              </attribute>
              <ref name="integer"/>
            </element>
          </optional>
          <optional>
            <element name="quadrature_family">
              <a:documentation>Select which family of quadrature rules to use.
The default is family_cools.
family_wandzura allows for degree up to 30
on triangular meshes.
family_grundmann_moeller allows for degree up to
29 on simplicial meshes in arbitrary dimension.</a:documentation>
              <choice>
                <value>family_cools</value>
                <value>family_grundmann_moeller</value>
                <value>family_wandzura</value>
              </choice>
            </element>
          </optional>
        </element>
      </element>
      <element name="io">
        <a:documentation>Input/output options</a:documentation>
        <element name="dump_format">
          <a:documentation>Format for dump files. Only vtk for now.</a:documentation>
          <element name="string_value">
            <value>vtk</value>
          </element>
        </element>
        <choice>
          <element name="dump_period">
            <a:documentation>Period between dumps in time units.

Specifies the period between each dump of the solution to disk.
A value of 0.0 indicates that there would be a dump at every timestep.</a:documentation>
            <choice>
              <element name="constant">
                <attribute name="replaces">
                  <value>TIMDUM</value>
                </attribute>
                <ref name="real"/>
              </element>
              <element name="python">
                <a:documentation>Python function prescribing real input. Functions should be of the form:

 def val(t):
    # Function code
    return # Return value

</a:documentation>
                <attribute name="replaces">
                  <value>TIMDUM</value>
                </attribute>
                <ref name="python_code"/>
              </element>
            </choice>
          </element>
          <element name="dump_period_in_timesteps">
            <a:documentation>Dump period, in timesteps.

Specifies the number of timesteps between each dump of the solution to disk.
A value of 0 indicates a dump at every timestep.</a:documentation>
            <choice>
              <element name="constant">
                <ref name="integer"/>
              </element>
              <element name="python">
                <a:documentation>Python function prescribing integer input. Functions should be of the form:

 def val(t):
    # Function code
    return # Return value

</a:documentation>
                <ref name="python_code"/>
              </element>
            </choice>
          </element>
        </choice>
        <optional>
          <!-- every CPUDUM seconds write results to disc. -->
          <element name="cpu_dump_period">
            <a:documentation>This is usually disabled.</a:documentation>
            <attribute name="replaces">
              <value>CPUDUM</value>
            </attribute>
            <ref name="real"/>
          </element>
        </optional>
        <optional>
          <element name="wall_time_dump_period">
            <a:documentation>The period between dumps in walltime seconds. This is usually disabled.</a:documentation>
            <attribute name="replaces">
              <value>WTIDUM</value>
            </attribute>
            <ref name="real"/>
          </element>
        </optional>
        <choice>
          <element name="output_mesh">
            <a:documentation>The mesh on to which all the fields will be
interpolated for VTK output.</a:documentation>
            <attribute name="name">
              <value>VelocityMesh</value>
            </attribute>
          </element>
          <element name="output_mesh">
            <a:documentation>The mesh on to which all the fields will be
interpolated for VTK output.</a:documentation>
            <attribute name="name">
              <value>PressureMesh</value>
            </attribute>
          </element>
          <element name="output_mesh">
            <a:documentation>The mesh on to which all the fields will be
interpolated for VTK output.</a:documentation>
            <attribute name="name">
              <value>CoordinateMesh</value>
            </attribute>
          </element>
          <element name="output_mesh">
            <a:documentation>The mesh on to which all the fields will be
interpolated for VTK output.</a:documentation>
            <attribute name="name">
              <data type="string"/>
            </attribute>
          </element>
        </choice>
      </element>
      <element name="timestepping">
        <a:documentation>Options dealing with time discretisation</a:documentation>
        <element name="current_time">
          <a:documentation>Current simulation time. At the start of the simulation this
is the start time.</a:documentation>
          <attribute name="replaces">
            <value>ACCTIM</value>
          </attribute>
          <ref name="real"/>
          <optional>
            <element name="time_units">
              <a:documentation>The following excerpt from the Udunits
documentation explains the time unit encoding by
example:

The specification:

seconds since 1992-10-8 15:15:42.5 -6:00

indicates seconds since October 8th, 1992 at 3
hours, 15 minutes and 42.5 seconds in the afternoon
in the time zone which is six hours to the west of
Coordinated Universal Time (i.e.  Mountain Daylight
Time). The time zone specification can also be
written without a colon using one or two-digits
(indicating hours) or three or four digits
(indicating hours and minutes).

Time units are particularly required in situations
where the problem (time-varying) boundary conditions
and/ initial conditions are a function of time as
defined by a calendar.  Examples include atmospheric
forcing and climatology. The current time, specified
above, is zero at the reference data/time.</a:documentation>
              <attribute name="date">
                <data type="string"/>
              </attribute>
            </element>
          </optional>
        </element>
        <element name="timestep">
          <a:documentation>The time step size. If adaptive time stepping is used
then this is the initial time step size.</a:documentation>
          <attribute name="replaces">
            <value>DT</value>
          </attribute>
          <ref name="real"/>
        </element>
        <element name="nonlinear_iterations">
          <a:documentation>How many nonlinear iterations in the timestepping loop</a:documentation>
          <attribute name="replaces">
            <value>ITINOI</value>
          </attribute>
          <ref name="integer"/>
        </element>
        <element name="finish_time">
          <a:documentation>Simulation time at which the simulation should end.</a:documentation>
          <attribute name="replaces">
            <value>LTIME</value>
          </attribute>
          <ref name="real"/>
        </element>
        <optional>
          <element name="final_timestep">
            <a:documentation>Timestep after which the simulation should end.</a:documentation>
            <ref name="integer"/>
          </element>
        </optional>
        <optional>
          <element name="cpu_time_limit">
            <a:documentation>Maximum CPU time (secs) taken up before
simulation terminates writing results to disc.

Manual suggests 1.E+20</a:documentation>
            <attribute name="replaces">
              <value>CPULIM</value>
            </attribute>
            <ref name="real"/>
          </element>
        </optional>
        <optional>
          <element name="wall_time_limit">
            <a:documentation>Maximum wall time (secs) taken up before
simulation terminates writing results to disc.

This is usually disabled.</a:documentation>
            <attribute name="replaces">
              <value>WATIME</value>
            </attribute>
            <ref name="real"/>
          </element>
        </optional>
      </element>
      <element name="physical_parameters">
        <a:documentation>The physical parameters</a:documentation>
        <optional>
          <element name="gravity">
            <a:documentation>Set a gravity to be included in the buoyancy term.</a:documentation>
            <element name="magnitude">
              <a:documentation>Acceleration due to gravity. 9.8 m/s^2 on earth.</a:documentation>
              <attribute name="replaces">
                <value>GRAVTY</value>
              </attribute>
              <ref name="real"/>
            </element>
          </element>
        </optional>
        <optional>
          <element name="coriolis">
            <attribute name="replaces">
              <value>OPTOME</value>
            </attribute>
            <choice>
              <element name="f_plane">
                <a:documentation>f-plane approximation
This means the Coriolis force looks like:
  f k x u
where k is the z unit vector
   and u the velocity vector
   and f is constant</a:documentation>
                <attribute name="replaces">
                  <value>OPTOME = 0</value>
                </attribute>
                <element name="f">
                  <a:documentation>f-plane approximation
This means the Coriolis force looks like:
  f k x u
where k is the z unit vector
   and u the velocity vector
   and f is constant</a:documentation>
                  <attribute name="replaces">
                    <value>OMEGA</value>
                  </attribute>
                  <ref name="real"/>
                </element>
              </element>
              <element name="beta_plane">
                <a:documentation>Beta-plane approximation
This means the Coriolis force looks like:
  f k x u
where k is the z unit vector
   and u the velocity vector
   and f=f_0+beta . (x,y,z)</a:documentation>
                <attribute name="replaces">
                  <value>OPTOME = 1</value>
                </attribute>
                <element name="f_0">
                  <a:documentation>Beta-plane approximation
This means the Coriolis force looks like:
  f k x u
where k is the z unit vector
   and u the velocity vector
   and f=f_0+beta . (x,y,z)</a:documentation>
                  <attribute name="replaces">
                    <value>OMEGA</value>
                  </attribute>
                  <ref name="real"/>
                </element>
                <element name="beta">
                  <a:documentation>Beta-plane approximation
This means the Coriolis force looks like:
  f k x u
where k is the z unit vector
   and u the velocity vector
   and f=f_0+beta . (x,y,z)
usually only the y-component of beta is non-zero</a:documentation>
                  <attribute name="replaces">
                    <value>OMEGA1 OMEGA2 OMEGA3</value>
                  </attribute>
                  <ref name="real_dim_vector"/>
                </element>
              </element>
            </choice>
          </element>
        </optional>
      </element>
      <element name="material_phase">
        <a:documentation>The material or phase options</a:documentation>
        <attribute name="name">
          <value>Fluid</value>
        </attribute>
        <group>
          <element name="vector_field">
            <a:documentation>Velocity vector and momentum options</a:documentation>
            <attribute name="rank">
              <value>1</value>
            </attribute>
            <attribute name="name">
              <value>Velocity</value>
            </attribute>
            <choice>
              <a:documentation>Field type</a:documentation>
              <element name="prognostic">
                <element name="mesh">
                  <attribute name="name">
                    <value>VelocityMesh</value>
                  </attribute>
                </element>
                <ref name="prognostic_velocity_field"/>
              </element>
              <element name="prescribed">
                <element name="mesh">
                  <attribute name="name">
                    <value>VelocityMesh</value>
                  </attribute>
                </element>
                <ref name="prescribed_vector_field"/>
              </element>
              <element name="aliased">
                <attribute name="material_phase_name">
                  <data type="string"/>
                </attribute>
                <attribute name="field_name">
                  <value>Velocity</value>
                </attribute>
              </element>
            </choice>
          </element>
          <element name="scalar_field">
            <a:documentation>Free surface elevation</a:documentation>
            <attribute name="rank">
              <value>0</value>
            </attribute>
            <attribute name="name">
              <value>LayerThickness</value>
            </attribute>
            <element name="prognostic">
              <ref name="pressure_mesh_choice"/>
              <ref name="prognostic_layerthickness_field"/>
            </element>
          </element>
          <zeroOrMore>
            <ref name="scalar_field_choice"/>
          </zeroOrMore>
          <zeroOrMore>
            <ref name="vector_field_choice"/>
          </zeroOrMore>
        </group>
        <!-- tensor_field_choice* -->
      </element>
      <optional>
        <element name="mesh_adaptivity">
          <choice>
            <ref name="hr_adaptivity"/>
            <ref name="prescribed_adaptivity"/>
          </choice>
        </element>
      </optional>
      <optional>
        <element name="debug">
          <a:documentation>Debugging options</a:documentation>
          <optional>
            <element name="check_inverse_coriolis_matrix">
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="check_wave_matrix">
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="check_solution">
              <empty/>
            </element>
          </optional>
        </element>
      </optional>
    </element>
  </start>
  <define name="scalar_field_choice">
    <!--
      The first is a generic field, which may be used for any user-defined field
      that FLUIDITY knows nothing about, or a generic diagnostic
    -->
    <choice>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <choice>
          <a:documentation>Field type</a:documentation>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="diagnostic">
            <ref name="scalar_diagnostic_algorithms"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Passive Tracer</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Tracer</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = 666</value>
        </attribute>
        <element name="prognostic">
          <ref name="velocity_mesh_choice"/>
          <ref name="prognostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>CFLNumber

See http://amcg.ese.ic.ac.uk/index.php?title=Local:Diagnostics#CFL_Number

Adapting to this field is not recommended</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>CFLNumber</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -601</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
    </choice>
  </define>
  <!-- Choice of input method, e.g. for boundary conditions -->
  <define name="input_choice_real">
    <ref name="input_choice_real_contents"/>
  </define>
  <define name="input_choice_real_plus_boundary_forcing">
    <choice>
      <ref name="input_choice_real_contents"/>
      <element name="from_file">
        <oneOrMore>
          <element name="tidal">
            <attribute name="file_name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <attribute name="variable_name_amplitude">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <attribute name="variable_name_phase">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <attribute name="name">
              <a:documentation>See E.W. Schwiderski - Rev. Geophys. Space
Phys. Vol. 18 No. 1 pp. 243--268, 1980
for details of these constituent.</a:documentation>
              <choice>
                <value>M2</value>
                <value>S2</value>
                <value>N2</value>
                <value>K2</value>
                <value>K1</value>
                <value>O1</value>
                <value>P1</value>
                <value>Q1</value>
                <value>Mf</value>
                <value>Mm</value>
                <value>Ssa</value>
              </choice>
            </attribute>
          </element>
        </oneOrMore>
      </element>
    </choice>
  </define>
  <define name="input_choice_real_plus_file">
    <choice>
      <ref name="input_choice_real_contents"/>
      <element name="from_file">
        <a:documentation>Initialise the field from an existing file (indended primarily for picking up prescribed fields from previously run prognostic simulations). The file mesh must match the mesh of this field (except for piecewise constant fields which will be remapped back from the discontinuous nodal values).

THIS WILL NOT WORK FOR PRESCRIBED FIELDS NOT DIRECTLY UNDERNEATH /material_phase</a:documentation>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
        <ref name="vtu_input_format"/>
        <ref name="comment"/>
      </element>
    </choice>
  </define>
  <define name="input_choice_real_contents">
    <choice>
      <element name="constant">
        <a:documentation>Constant value</a:documentation>
        <ref name="real"/>
      </element>
      <element name="generic_function">
        <a:documentation>Generic function prescribing real input</a:documentation>
        <ref name="anystring"/>
      </element>
      <element name="python">
        <a:documentation>Python function prescribing real input. Functions should be of the form:

 def val(X, t):
    # Function code
    return # Return value

where X is a tuple of length geometry dimension.</a:documentation>
        <ref name="python_code"/>
      </element>
    </choice>
  </define>
  <!--
    Choice of input method for initial conditions
    Note: combine = "choice" should be used here to combine with input_choice_real, but Diamond doesn't support it
  -->
  <define name="input_choice_initial_condition_real">
    <choice>
      <element name="constant">
        <a:documentation>Constant value</a:documentation>
        <ref name="real"/>
      </element>
      <element name="generic_function">
        <a:documentation>Generic function prescribing real input</a:documentation>
        <ref name="anystring"/>
      </element>
      <element name="python">
        <a:documentation>Python function prescribing real input. Functions should be of the form:

 def val(X, t):
    # Function code
    return # Return value

where X is a tuple of length geometry dimension.</a:documentation>
        <ref name="python_code"/>
      </element>
      <element name="from_file">
        <a:documentation>Initialise the field from an existing file (indended
primarily for use in checkpointing). The file mesh must match
the mesh of this field  (except for piecewise constant fields 
which will be remapped back from the discontinuous nodal values). 
In parallel the process number is
appended to the filename, e.g. if the file_name attribute is
set to "input.vtu", process 0 reads from "input-0.vtu".</a:documentation>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
        <choice>
          <ref name="vtu_input_format"/>
          <ref name="netcdf_input_format"/>
        </choice>
        <ref name="comment"/>
      </element>
    </choice>
  </define>
  <!-- Choice of input method, e.g. for boundary conditions -->
  <define name="input_choice_real_dim_vector">
    <ref name="input_choice_real_dim_vector_contents"/>
  </define>
  <!-- Choice of input method, e.g. for prescribed fields -->
  <define name="input_choice_real_dim_vector_plus_file">
    <choice>
      <ref name="input_choice_real_dim_vector_contents"/>
      <element name="from_file">
        <a:documentation>Initialise the field from an existing file (indended primarily for picking up prescribed fields from previously run prognostic simulations). The file mesh must match the mesh of this field (except for piecewise constant fields which will be remapped back from the discontinuous nodal values).

THIS WILL NOT WORK FOR PRESCRIBED FIELDS NOT DIRECTLY UNDERNEATH /material_phase</a:documentation>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
        <ref name="vtu_input_format"/>
        <ref name="comment"/>
      </element>
    </choice>
  </define>
  <define name="input_choice_real_dim_vector_contents">
    <choice>
      <element name="constant">
        <a:documentation>Constant value</a:documentation>
        <ref name="real_dim_vector"/>
      </element>
      <element name="python">
        <a:documentation>Python function prescribing dimensional vector input. Functions should be of the form:

 def val(X, t):
    # Function code
    return # Return value

where X and the return value are tuples of length geometry dimension.</a:documentation>
        <ref name="python_code"/>
      </element>
    </choice>
  </define>
  <!--
    Choice of input method, e.g. for boundary conditions
    this one specifies a vector field of dim minus one
  -->
  <define name="input_choice_real_dim_minus_one_vector">
    <choice>
      <element name="constant">
        <a:documentation>Constant value</a:documentation>
        <ref name="real_dim_minus_one_vector"/>
      </element>
      <!--
        ## Generic function prescribing dimensional vector input
        element generic_function {
           anystring
        }|
      -->
      <element name="python">
        <a:documentation>Python function prescribing dimensional vector input. Functions should be of the form:

 def val(X, t):
    # Function code
    return # Return value

where X and the return value are tuples of length geometry dimension.</a:documentation>
        <ref name="python_code"/>
      </element>
    </choice>
  </define>
  <define name="input_choice_netcdf">
    <a:documentation>Import data from NetCDF CF-1.x file.</a:documentation>
    <element name="from_file">
      <attribute name="file_name">
        <a:documentation>The format of this file should conform to NetCDF CF 1.x
(http://cf-pcmdi.llnl.gov/)</a:documentation>
        <data type="string"/>
      </attribute>
      <ref name="comment"/>
    </element>
  </define>
  <!--
    Choice of input method for initial conditions
    Note: combine = "choice" should be used here to combine with input_choice_real, but Diamond doesn't support it
  -->
  <define name="input_choice_initial_condition_vector">
    <choice>
      <element name="constant">
        <a:documentation>Constant value</a:documentation>
        <ref name="real_dim_vector"/>
      </element>
      <!--
        ## Generic function prescribing dimensional vector input
        element generic_function {
           anystring
        }|
      -->
      <element name="python">
        <a:documentation>Python function prescribing dimensional vector input. Functions should be of the form:

 def val(X, t):
    # Function code
    return # Return value

where X and the return value are tuples of length geometry dimension.</a:documentation>
        <ref name="python_code"/>
      </element>
      <element name="from_file">
        <a:documentation>Initialise the field from an existing file (indended primarily for use in checkpointing). The file mesh must match the mesh of this field (except for piecewise constant fields which will be remapped back from the discontinuous nodal values).</a:documentation>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
        <ref name="vtu_input_format"/>
        <ref name="comment"/>
      </element>
      <element name="balanced">
        <a:documentation>Set balanced velocity from height field</a:documentation>
        <empty/>
      </element>
    </choice>
  </define>
  <!--
    Choice of input method for initial/boundary conditions
    version for real symmetric tensor
  -->
  <define name="input_choice_real_dim_symmetric_tensor">
    <choice>
      <element name="constant">
        <a:documentation>Constant symmetric tensor</a:documentation>
        <ref name="real_dim_symmetric_tensor"/>
      </element>
      <!--
             ## Generic function prescribing symmetric tensor input
             element generic_function {
                anystring
             }|
      -->
      <element name="python">
        <a:documentation>Python command prescribing symmetric tensor input.

Note that it is for the python function to determine 
that the results it produces are, in fact, symmetric.

An example that returns the three-dimensional identity:

 def val(X, t):
   return [[1, 0, 0],
               [0, 1, 0],
               [0, 0, 1]]</a:documentation>
        <ref name="python_code"/>
      </element>
    </choice>
  </define>
  <!--
    Choice of input method for initial/boundary conditions
    version for real tensor
  -->
  <define name="input_choice_real_dim_tensor">
    <choice>
      <element name="constant">
        <a:documentation>Constant tensor</a:documentation>
        <ref name="real_dim_tensor"/>
      </element>
      <!--
             }|
             ## Generic function prescribing tensor input
             element generic_function {
                anystring
             }|
      -->
      <element name="python">
        <a:documentation>Python command prescribing tensor input.

An example that returns the three-dimensional identity:

 def val(X, t):
   return [[1, 0, 0],
               [0, 1, 0],
               [0, 0, 1]]</a:documentation>
        <ref name="python_code"/>
      </element>
    </choice>
  </define>
  <define name="prognostic_velocity_field">
    <ref name="velocity_equation_choice"/>
    <element name="spatial_discretisation">
      <a:documentation>Spatial discretisation options</a:documentation>
      <choice>
        <element name="continuous_galerkin">
          <a:documentation>A new version of continuous galerkin assembly.</a:documentation>
          <element name="stabilisation">
            <a:documentation>Stabilisation options for the galerkin discretisation</a:documentation>
            <choice>
              <ref name="no_stabilisation"/>
              <ref name="su_stabilisation"/>
              <ref name="supg_stabilisation"/>
            </choice>
          </element>
          <element name="mass_terms">
            <a:documentation>Discretisation options for the mass terms in the velocity equation.</a:documentation>
            <optional>
              <element name="lump_mass_matrix">
                <a:documentation>Lump the mass matrix - currently required if solving for pressure</a:documentation>
                <optional>
                  <element name="use_submesh">
                    <a:documentation>Lump on the submesh.
This only works for simplex meshes and is only
strictly valid on 2d meshes.</a:documentation>
                    <empty/>
                  </element>
                </optional>
              </element>
            </optional>
            <optional>
              <element name="exclude_mass_terms">
                <a:documentation>Remove the mass terms from the equation.</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
          <element name="advection_terms">
            <a:documentation>Discretisation options for the advection terms in the velocity equation.</a:documentation>
            <optional>
              <element name="integrate_advection_by_parts">
                <a:documentation>Integrate the advection terms of the momentum equation by parts.
This allows for the imposition of weak boundary conditions.
If activated the element advection matrix takes the form:
   /                                            /
 - | (grad N_A dot nu) N_B rho dV - (1. - beta) | N_A ( div nu ) N_B rho dV
   /                                            /
otherwise it takes the standard form:
   /                                     /
   | N_A (nu dot grad N_B) rho dV + beta | N_A ( div nu ) N_B rho dV
   /                                     /
where beta is set in conservative_advection, N is
a shape function and nu is the relative nonlinear
velocity.</a:documentation>
                <empty/>
              </element>
            </optional>
            <optional>
              <element name="exclude_advection_terms">
                <a:documentation>Remove the advection terms (u.grad u rho + beta
div u rho u) from the equation.
This overrides any other advection term options
(including conservative_advection below).</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
        </element>
        <element name="discontinuous_galerkin">
          <a:documentation>Discontinuous galerkin formulation. This causes Momentum_DG to be
called instead of diff3d. Confusingly it is not necessary to provide
a discontinuous velocity field for this to work!</a:documentation>
          <attribute name="replaces">
            <value>DISOPT</value>
          </attribute>
          <element name="advection_scheme">
            <choice>
              <element name="none">
                <a:documentation>Disable advection</a:documentation>
                <empty/>
              </element>
              <element name="upwind">
                <a:documentation>Straightforward upwinding of the nonlinear velocity</a:documentation>
                <empty/>
              </element>
            </choice>
          </element>
        </element>
      </choice>
    </element>
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options_asym"/>
    </element>
    <oneOrMore>
      <choice>
        <element name="initial_condition">
          <a:documentation>Initial condition for WholeMesh

Only specify one condition if not using mesh regions.
Otherwise select other initial_condition option, specify region_ids
and distinct names.  Then add extra intial conditions for other regions.</a:documentation>
          <attribute name="name">
            <value>WholeMesh</value>
          </attribute>
          <ref name="input_choice_initial_condition_vector"/>
        </element>
        <element name="initial_condition">
          <a:documentation>Multiple initial_conditions are allowed if specifying
different values in different
regions of the mesh (defined by region_ids).  In this case
each initial_condition
requires a distinct name for the options dictionary.</a:documentation>
          <attribute name="name">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <ref name="region_ids"/>
          <ref name="input_choice_initial_condition_vector"/>
        </element>
      </choice>
    </oneOrMore>
    <zeroOrMore>
      <element name="boundary_conditions">
        <a:documentation>Boundary conditions</a:documentation>
        <attribute name="replaces">
          <value>boundary, TMPER1 TMPER2 TMPERI</value>
        </attribute>
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
        <element name="surface_ids">
          <a:documentation>Surface id:</a:documentation>
          <ref name="integer_vector"/>
        </element>
        <ref name="velocity_boundary_conditions"/>
      </element>
    </zeroOrMore>
    <ref name="prognostic_vector_output_options"/>
    <ref name="prognostic_vector_stat_options"/>
    <ref name="vector_convergence_options"/>
    <ref name="prognostic_detector_options"/>
    <ref name="vector_steady_state_options"/>
    <ref name="adaptivity_options_prognostic_vector_field"/>
    <ref name="interpolation_algorithm_vector"/>
    <optional>
      <ref name="discrete_properties_algorithm_vector"/>
    </optional>
  </define>
  <define name="prognostic_layerthickness_field">
    <element name="spatial_discretisation">
      <a:documentation>Spatial discretisation options</a:documentation>
      <element name="continuous_galerkin">
        <a:documentation>Development continuous Galerkin formulation. This causes
Advection_Diffusion_CG to be used instead of hart3d.</a:documentation>
        <element name="advection_terms">
          <a:documentation>Discretisation options for the advection terms.</a:documentation>
          <optional>
            <element name="exclude_advection_terms">
              <a:documentation>Remove the advection terms from the equation.
This overrides any other advection term options (including
conservative_advection below).</a:documentation>
              <ref name="comment"/>
            </element>
          </optional>
        </element>
        <ref name="comment"/>
      </element>
    </element>
    <element name="temporal_discretisation">
      <a:documentation>Temporal discretisation options</a:documentation>
      <element name="theta">
        <a:documentation>Implicit/explicit control (THETA)
 =0.  -- explicit
 =0.5 -- Crank-Nicolson
 =1.  -- implicit</a:documentation>
        <attribute name="replaces">
          <value>THETA</value>
        </attribute>
        <ref name="real"/>
      </element>
      <element name="relaxation">
        <a:documentation>Non-linear relaxation term
 =0.  -- previous timestep velocity solution used in non-linear terms of momentum equations
 =1.  -- previous iteration velocity solution used in non-linear terms of momentum equations
 0. &lt; ITHETA &lt; 1.</a:documentation>
        <attribute name="replaces">
          <value>ITHETA</value>
        </attribute>
        <ref name="real"/>
      </element>
    </element>
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options_asym"/>
    </element>
    <choice>
      <element name="initial_condition">
        <a:documentation>Initial condition for WholeMesh

Only specify one condition if not using mesh regions.
Otherwise select other initial_condition option, specify region_ids
and distinct names.  Then add extra intial conditions for other regions.</a:documentation>
        <attribute name="name">
          <value>WholeMesh</value>
        </attribute>
        <ref name="input_choice_initial_condition_real"/>
      </element>
      <element name="initial_condition">
        <a:documentation>Multiple initial_conditions are allowed if specifying
different values in different
regions of the mesh (defined by region_ids).  In this case
each initial_condition
requires a distinct name for the options dictionary.</a:documentation>
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
        <ref name="region_ids"/>
        <ref name="input_choice_initial_condition_real"/>
      </element>
    </choice>
    <element name="mean_layer_thickness">
      <a:documentation>Mean value of thickness to use in wave equation solver
Will be replaced by a field in due course</a:documentation>
      <ref name="real"/>
    </element>
    <ref name="prognostic_scalar_output_options"/>
    <ref name="prognostic_scalar_stat_options"/>
    <ref name="adaptivity_options_prognostic_scalar_field"/>
    <ref name="interpolation_algorithm_scalar"/>
  </define>
  <define name="prognostic_scalar_field">
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options_sym"/>
    </element>
    <choice>
      <element name="initial_condition">
        <a:documentation>Initial condition for WholeMesh

Only specify one condition if not using mesh regions.
Otherwise select other initial_condition option, specify region_ids
and distinct names.  Then add extra intial conditions for other regions.</a:documentation>
        <attribute name="name">
          <value>WholeMesh</value>
        </attribute>
        <ref name="input_choice_initial_condition_real"/>
      </element>
      <element name="initial_condition">
        <a:documentation>Multiple initial_conditions are allowed if specifying
different values in different
regions of the mesh (defined by region_ids).  In this case
each initial_condition
requires a distinct name for the options dictionary.</a:documentation>
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
        <ref name="region_ids"/>
        <ref name="input_choice_initial_condition_real"/>
      </element>
    </choice>
    <optional>
      <element name="tensor_field">
        <a:documentation>Diffusivity for field</a:documentation>
        <attribute name="name">
          <value>Diffusivity</value>
        </attribute>
        <attribute name="rank">
          <value>2</value>
        </attribute>
        <attribute name="replaces">
          <value>TMUXX TMUYY TMUZZ TMUYZ TMUXZ TMUXY TALLMU TCONMU</value>
        </attribute>
        <element name="prescribed">
          <optional>
            <ref name="mesh_choice"/>
          </optional>
          <ref name="prescribed_values_tensor_field"/>
        </element>
      </element>
    </optional>
    <ref name="prognostic_scalar_output_options"/>
    <ref name="prognostic_scalar_stat_options"/>
  </define>
  <!-- Default child of diagnostic scalar field -->
  <define name="diagnostic_scalar_field">
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_scalar_stat_options"/>
    <ref name="scalar_convergence_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="scalar_steady_state_options"/>
    <ref name="adaptivity_options_scalar_field"/>
    <optional>
      <ref name="recalculation_options"/>
    </optional>
  </define>
  <!-- Default child of diagnostic scalar field without adaptivity options -->
  <define name="diagnostic_scalar_field_no_adapt">
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_scalar_stat_options"/>
    <ref name="diagnostic_detector_options"/>
  </define>
  <!-- Default child of diagnostic scalar field -->
  <define name="diagnostic_scalar_field_tidal_range">
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_scalar_stat_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="adaptivity_options_scalar_field"/>
    <element name="spin_up_time">
      <ref name="real"/>
    </element>
  </define>
  <!--
    Default child of prescribed scalar field
    This is a choice of ways of inputing the prescribed field
  -->
  <define name="prescribed_scalar_field">
    <ref name="prescribed_scalar_field_no_adapt"/>
    <ref name="adaptivity_options_scalar_field"/>
    <optional>
      <ref name="interpolation_algorithm_scalar"/>
    </optional>
    <optional>
      <ref name="discrete_properties_algorithm_scalar"/>
    </optional>
    <optional>
      <ref name="recalculation_options"/>
    </optional>
  </define>
  <!--
    Default child of prescribed scalar field without adaptivity options
    This is a choice of ways of inputing the prescribed field
  -->
  <define name="prescribed_scalar_field_no_adapt">
    <ref name="prescribed_values_scalar_field"/>
    <ref name="prescribed_output_options"/>
    <ref name="prescribed_scalar_stat_options"/>
    <ref name="prescribed_detector_options"/>
  </define>
  <define name="prescribed_values_scalar_field">
    <oneOrMore>
      <choice>
        <element name="value">
          <a:documentation>Value for WholeMesh
Only specify one value if not using mesh regions.
Otherwise select other value option, specify region_ids
and distinct names.  Then add extra values for other regions.</a:documentation>
          <attribute name="name">
            <value>WholeMesh</value>
          </attribute>
          <ref name="input_choice_real_plus_file"/>
        </element>
        <element name="value">
          <a:documentation>Multiple values are now allowed if using different value assignments
in different regions of the mesh (specified by region_ids).
In this case each value requires a distinct name for the options dictionary.</a:documentation>
          <attribute name="name">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <ref name="region_ids"/>
          <ref name="input_choice_real_plus_file"/>
        </element>
      </choice>
    </oneOrMore>
  </define>
  <!--
    Default child of diagnostic vector field
    Currently, this is empty, but in future this might include
    options that are general to all diagnostic vector fields
  -->
  <define name="diagnostic_vector_field">
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_vector_stat_options"/>
    <ref name="vector_convergence_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="vector_steady_state_options"/>
    <ref name="adaptivity_options_vector_field"/>
    <optional>
      <ref name="recalculation_options"/>
    </optional>
  </define>
  <define name="diagnostic_vector_field_bed_shear_stress">
    <element name="density">
      <ref name="real"/>
    </element>
    <element name="drag_coefficient">
      <ref name="real"/>
    </element>
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_vector_stat_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="adaptivity_options_vector_field"/>
  </define>
  <!--
    Default child of prescribed vector field
    This is a choice of ways of inputing the prescribed field
  -->
  <define name="prescribed_vector_field">
    <ref name="prescribed_vector_field_no_adapt"/>
    <ref name="adaptivity_options_vector_field"/>
    <optional>
      <ref name="interpolation_algorithm_vector"/>
    </optional>
    <optional>
      <ref name="discrete_properties_algorithm_vector"/>
    </optional>
    <optional>
      <ref name="recalculation_options"/>
    </optional>
  </define>
  <!--
    Default child of prescribed vector field without adaptivity options
    This is a choice of ways of inputing the prescribed field
  -->
  <define name="prescribed_vector_field_no_adapt">
    <ref name="prescribed_values_vector_field"/>
    <ref name="prescribed_output_options"/>
    <ref name="prescribed_vector_stat_options"/>
    <ref name="prescribed_detector_options"/>
  </define>
  <define name="prescribed_values_vector_field">
    <oneOrMore>
      <choice>
        <element name="value">
          <a:documentation>Value for WholeMesh

Only specify one value if not using mesh regions.
Otherwise select other value option, specify region_ids
and distinct names.  Then add extra values for other regions.</a:documentation>
          <attribute name="name">
            <value>WholeMesh</value>
          </attribute>
          <ref name="input_choice_real_dim_vector_plus_file"/>
        </element>
        <element name="value">
          <a:documentation>Multiple values are now allowed if using different value assignments
in different regions of the mesh (specified by region_ids).
In this case each value requires a distinct name for the options dictionary.</a:documentation>
          <attribute name="name">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <ref name="region_ids"/>
          <ref name="input_choice_real_dim_vector_plus_file"/>
        </element>
      </choice>
    </oneOrMore>
  </define>
  <!--
    Default child of diagnostic tensor field
    Currently, this is empty, but in future this might include
    options that are general to all diagnostic tensor fields
  -->
  <define name="diagnostic_tensor_field">
    <ref name="diagnostic_output_options"/>
    <ref name="adaptivity_options_tensor_field"/>
  </define>
  <!--
    Default child of prescribed vector field
    This is a choice of ways of inputing the prescribed tensor field
    If the field is constant then a symmetric, or asymmetric tensor may be entered
  -->
  <define name="prescribed_tensor_field">
    <ref name="prescribed_values_tensor_field"/>
    <ref name="adaptivity_options_tensor_field"/>
  </define>
  <define name="prescribed_values_tensor_field">
    <oneOrMore>
      <choice>
        <element name="value">
          <a:documentation>Value for WholeMesh

Only specify one value if not using mesh regions.
Otherwise select other value option, specify region_ids
and distinct names.  Then add extra values for other regions.</a:documentation>
          <attribute name="name">
            <value>WholeMesh</value>
          </attribute>
          <ref name="input_choice_tensor_field"/>
        </element>
        <element name="value">
          <a:documentation>Multiple values are now allowed if using different value assignments
in different regions of the mesh (specified by region_ids).
In this case each value requires a distinct name for the options dictionary.</a:documentation>
          <attribute name="name">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <ref name="region_ids"/>
          <ref name="input_choice_tensor_field"/>
        </element>
      </choice>
    </oneOrMore>
  </define>
  <define name="velocity_components_choice">
    <!--
      rotated bcs are not implemented... this is where they should go when they are
              element align_bc_with_surface {
                 element normal_component {
                    input_choice_real
                 }?,
                 element tangent_component_1 {
                    input_choice_real
                 }?,
                 element tangent_component_2 {
                    input_choice_real
                 }?,
                 rotation_matrix_components
              }|
    -->
    <element name="align_bc_with_cartesian">
      <optional>
        <element name="x_component">
          <ref name="input_choice_real_bc_component"/>
        </element>
      </optional>
      <optional>
        <element name="y_component">
          <ref name="input_choice_real_bc_component"/>
        </element>
      </optional>
      <optional>
        <element name="z_component">
          <ref name="input_choice_real_bc_component"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="input_choice_real_bc_component">
    <choice>
      <ref name="input_choice_real"/>
      <element name="synthetic_eddy_method">
        <element name="number_of_eddies">
          <a:documentation>use a large number to ensure Gaussian 
behaviour of the fluctuating component</a:documentation>
          <ref name="integer"/>
        </element>
        <element name="turbulence_lengthscale">
          <ref name="input_choice_real"/>
        </element>
        <element name="mean_profile">
          <a:documentation>mean profile

usually a function of height,
for ABL simulations use a log profile</a:documentation>
          <ref name="input_choice_real"/>
        </element>
        <element name="Re_stresses_profile">
          <a:documentation>Reynolds stresses profile

usually a function of height,
assumes that the remaining stresses are negligible </a:documentation>
          <ref name="input_choice_real"/>
        </element>
      </element>
    </choice>
  </define>
  <!-- and again for robin b.c.s -->
  <define name="robin_velocity_components_choice">
    <!--
              element align_bc_with_surface {
                 element normal_component {
                    element order_zero_coefficient {
                       input_choice_real
                    },
                    element order_one_coefficient {
                       input_choice_real
                    }
                 }?,
                 element tangent_component_1 {
                    element order_zero_coefficient {
                       input_choice_real
                    },
                    element order_one_coefficient {
                       input_choice_real
                    }
                 }?,
                 element tangent_component_2 {
                    element order_zero_coefficient {
                       input_choice_real
                    },
                    element order_one_coefficient {
                       input_choice_real
                    }
                 }?,
                 rotation_matrix_components
              }|
    -->
    <element name="align_bc_with_cartesian">
      <optional>
        <element name="x_component">
          <element name="order_zero_coefficient">
            <ref name="input_choice_real"/>
          </element>
          <element name="order_one_coefficient">
            <ref name="input_choice_real"/>
          </element>
        </element>
      </optional>
      <optional>
        <element name="y_component">
          <element name="order_zero_coefficient">
            <ref name="input_choice_real"/>
          </element>
          <element name="order_one_coefficient">
            <ref name="input_choice_real"/>
          </element>
        </element>
      </optional>
      <optional>
        <element name="z_component">
          <element name="order_zero_coefficient">
            <ref name="input_choice_real"/>
          </element>
          <element name="order_one_coefficient">
            <ref name="input_choice_real"/>
          </element>
        </element>
      </optional>
    </element>
  </define>
  <define name="velocity_boundary_conditions">
    <choice>
      <element name="type">
        <attribute name="name">
          <value>dirichlet</value>
        </attribute>
        <optional>
          <element name="apply_weakly">
            <a:documentation>Apply the dirichlet bc weakly.  Available automatically
with a discontinuous_galerkin Velocity
spatial_discretisation.  Available if you
integrate_continuity_by_parts with a
continuous_galerkin Pressure or use a control_volume
Pressure spatial_discretisation and/or
integrate_advection_by_parts under Velocity
spatial_discretisation with continuous_galerkin.

If not selected boundary conditions are applied strongly.</a:documentation>
            <optional>
              <element name="boundary_overwrites_initial_condition">
                <a:documentation>If the initial condition and boundary conditions
differ, setting this option will cause the initial
condition on the boundary to be overwritten with
the boundary condition. Since you are applying the
boundary condition weakly, you probably do *not*
want this.</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
        </optional>
        <ref name="velocity_components_choice"/>
      </element>
      <element name="type">
        <attribute name="name">
          <value>neumann</value>
        </attribute>
        <ref name="velocity_components_choice"/>
      </element>
      <element name="type">
        <attribute name="name">
          <value>robin</value>
        </attribute>
        <ref name="robin_velocity_components_choice"/>
      </element>
      <element name="type">
        <attribute name="name">
          <value>free_surface</value>
        </attribute>
      </element>
      <element name="type">
        <a:documentation>Apply quadratic drag. Specify drag coefficient. If you
want to exactly replicate results from using the OCEDRA
option, set this to 0.003 and remember to apply to both
bottom and sides.</a:documentation>
        <attribute name="name">
          <value>drag</value>
        </attribute>
        <ref name="input_choice_real"/>
        <choice>
          <element name="quadratic_drag">
            <a:documentation>Use a quadratic drag.

This means that the drag coefficient is nondimensional.</a:documentation>
            <empty/>
          </element>
          <element name="linear_drag">
            <a:documentation>Use a linear drag (basically just a surface absorption term).

This means that the drag coefficient has units of momentum.</a:documentation>
            <empty/>
          </element>
        </choice>
      </element>
      <element name="type">
        <a:documentation>Apply wind forcing specified by stress or wind velocity.
Replaces windy.dat and windy.py</a:documentation>
        <attribute name="name">
          <value>wind_forcing</value>
        </attribute>
        <choice>
          <element name="wind_stress">
            <a:documentation>Wind forcing with user specified wind stress

&lt;b&gt; Note that the stress needs to be specified
using the same density units as the reference_density 
under equation of state.&lt;/b&gt;So if you use the recommended
non-dimensional value of 1.0 for reference_density and
your calculated stress is in kg m^-1s^-2 and the dimensional
reference_density is 1000.0 kg m^-3, you need to divide
the calculated stress in SI units by 1000.0.</a:documentation>
            <choice>
              <ref name="input_choice_real_dim_minus_one_vector"/>
              <element name="from_netcdf">
                <attribute name="file_name">
                  <a:documentation>The format of this file should conform to NetCDF CF 1.x
(http://cf-pcmdi.llnl.gov/).</a:documentation>
                  <data type="string"/>
                </attribute>
                <attribute name="east_west">
                  <data type="string"/>
                </attribute>
                <attribute name="north_south">
                  <data type="string"/>
                </attribute>
                <ref name="comment"/>
              </element>
            </choice>
          </element>
          <element name="wind_velocity">
            <a:documentation>Wind forcing with user specified 10m wind velocity</a:documentation>
            <element name="wind_drag_coefficient">
              <a:documentation>Specify wind drag coefficient (dimensionless)
Suggested value: 4.0e-4</a:documentation>
              <ref name="input_choice_real"/>
            </element>
            <element name="density_air">
              <a:documentation>Density of air. 

&lt;b&gt;Note that you have to specify
this density in the same units as the 
reference_density under equation of state.&lt;/b&gt;
So with a typicial value of rho_air=1.3 kgm^-3
and rho_water=1000 kgm^-3, if you fill in the 
recommended (non-dimensional) value of 1.0 for 
reference_density, this field needs to be 1.3e-3.</a:documentation>
              <ref name="real"/>
            </element>
            <element name="wind_velocity">
              <a:documentation>Specify wind velocity</a:documentation>
              <choice>
                <ref name="input_choice_real_dim_minus_one_vector"/>
                <element name="from_netcdf">
                  <attribute name="file_name">
                    <a:documentation>The format of this file should conform to NetCDF CF 1.x
(http://cf-pcmdi.llnl.gov/)</a:documentation>
                    <data type="string"/>
                  </attribute>
                  <attribute name="east_west">
                    <data type="string"/>
                  </attribute>
                  <attribute name="north_south">
                    <data type="string"/>
                  </attribute>
                  <ref name="comment"/>
                </element>
              </choice>
            </element>
          </element>
        </choice>
      </element>
      <element name="type">
        <a:documentation>When using control_volumes under Pressure
spatial_discretisation or when using
integrate_continuity_by_parts with continuous_galerkin
Pressure and continuous_galerkin Velocity this
boundary condition type imposes a weak no normal flow
boundary condition on the surface_ids specified.</a:documentation>
        <attribute name="name">
          <value>no_normal_flow</value>
        </attribute>
        <empty/>
      </element>
      <element name="type">
        <a:documentation>Implements a penalty function for the near wall region.
Using this option coarse meshes can
be used in the near wall region.

Should be used in combination with a no_normal_flow condition. 

See Bazilevs et al. 2007</a:documentation>
        <attribute name="name">
          <value>near_wall_treatment</value>
        </attribute>
        <element name="tolerance">
          <ref name="real"/>
        </element>
      </element>
      <element name="type">
        <a:documentation>Log law of the wall

Should be used in combination with a no_normal_flow condition. </a:documentation>
        <attribute name="name">
          <value>log_law_of_wall</value>
        </attribute>
        <element name="surface_roughness">
          <ref name="real"/>
        </element>
      </element>
    </choice>
  </define>
  <!-- Output options for prognostic fields -->
  <define name="prognostic_scalar_output_options">
    <element name="output">
      <a:documentation>Specify what is written to vtu dump files</a:documentation>
      <optional>
        <element name="exclude_from_vtu">
          <a:documentation>By default each field in the options file is written to vtu.
Select this option to exclude this field.</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="include_previous_time_step">
          <a:documentation>Select this option to also write the values of this field
on the previous timestep.
(included under the name: Old&lt;field_name&gt; )</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="include_nonlinear_field">
          <a:documentation>Select this option to also write the values of this field
used in the nonlinear iteration.
(included under the name: Nonlinear&lt;field_name&gt; )</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="convergence_file">
          <a:documentation>Output a file details the convergence (or otherwise) of
this field with every advective nonlinear
iteration.
ONLY WORKS FOR PURE CONTROL VOLUME DISCRETISATIONS.</a:documentation>
          <ref name="comment"/>
        </element>
      </optional>
    </element>
  </define>
  <!-- Output options for pressure (can't have a convergence file) -->
  <define name="pressure_output_options">
    <element name="output">
      <a:documentation>Specify what is written to vtu dump files</a:documentation>
      <optional>
        <element name="exclude_from_vtu">
          <a:documentation>By default each field in the options file is written to vtu.
Select this option to exclude this field.</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="include_previous_time_step">
          <a:documentation>Select this option to also write the values of this field
on the previous timestep.
(included under the name: Old&lt;field_name&gt; )</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="include_nonlinear_field">
          <a:documentation>Select this option to also write the values of this field
used in the nonlinear iteration.
(included under the name: Nonlinear&lt;field_name&gt; )</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="debugging_vtus">
          <a:documentation>Write out some extra debugging vtu files that can be used
to analyse what goes on in the pressure projection steps.
WARNING: this may create a huge amount of vtu files, as 
multiple files are written per nonlinear iteration.</a:documentation>
          <empty/>
        </element>
      </optional>
    </element>
  </define>
  <!-- Output options for prognostic fields -->
  <define name="prognostic_vector_output_options">
    <element name="output">
      <a:documentation>Specify what is written to vtu dump files</a:documentation>
      <optional>
        <element name="exclude_from_vtu">
          <a:documentation>By default each field in the options file is written to vtu.
Select this option to exclude this field.</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="include_previous_time_step">
          <a:documentation>Select this option to also write the values of this field
on the previous timestep.
(included under the name: Old&lt;field_name&gt; )</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="include_nonlinear_field">
          <a:documentation>Select this option to also write the values of this field
used in the nonlinear iteration.
(included under the name: Nonlinear&lt;field_name&gt; )</a:documentation>
          <empty/>
        </element>
      </optional>
    </element>
  </define>
  <!-- Output options for all other fields -->
  <define name="field_output_options">
    <element name="output">
      <a:documentation>Specify what is written to vtu dump files</a:documentation>
      <optional>
        <element name="exclude_from_vtu">
          <a:documentation>By default each field in the options file is written to vtu.
Select this option to exclude this field.</a:documentation>
          <empty/>
        </element>
      </optional>
    </element>
  </define>
  <define name="diagnostic_output_options">
    <ref name="field_output_options"/>
  </define>
  <define name="prescribed_output_options">
    <ref name="field_output_options"/>
  </define>
  <!--
    Options for inclusion/exclusion of standard field statistics from the .stat
    file
  -->
  <define name="include_stat">
    <element name="include_in_stat">
      <a:documentation>Include this field in the .stat file (magnitude and components)</a:documentation>
      <ref name="comment"/>
    </element>
  </define>
  <define name="exclude_components_from_stat">
    <element name="exclude_components_from_stat">
      <a:documentation>Include just the magnitude of this field in the .stat file
(excluding the components)</a:documentation>
      <ref name="comment"/>
    </element>
  </define>
  <define name="exclude_stat">
    <element name="exclude_from_stat">
      <a:documentation>Exclude this field from the .stat file.</a:documentation>
      <ref name="comment"/>
    </element>
  </define>
  <!-- Diagnostic statistics options for prognostic scalar fields -->
  <define name="prognostic_scalar_stat_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <ref name="prognostic_scalar_stat_options.stat"/>
    </element>
  </define>
  <!-- Diagnostic statistics for all other scalar fields -->
  <define name="prognostic_scalar_stat_no_old_or_nonlinear_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <ref name="prognostic_scalar_stat_no_old_or_nonlinear_options.stat"/>
    </element>
  </define>
  <define name="diagnostic_scalar_stat_options">
    <ref name="prognostic_scalar_stat_no_old_or_nonlinear_options"/>
  </define>
  <define name="prescribed_scalar_stat_options">
    <ref name="prognostic_scalar_stat_no_old_or_nonlinear_options"/>
  </define>
  <!-- Combining of stat elements for scalar fields -->
  <define name="prognostic_scalar_stat_options.stat">
    <ref name="prognostic_scalar_stat_no_old_or_nonlinear_options.stat"/>
  </define>
  <define name="prognostic_scalar_stat_options.stat" combine="interleave">
    <optional>
      <element name="include_previous_time_step">
        <a:documentation>Enable to include the previous timestep value of this field in the .stat file.</a:documentation>
        <ref name="comment"/>
      </element>
    </optional>
    <optional>
      <element name="include_nonlinear_field">
        <a:documentation>Enable to include the values of this field in the nonlinear
iteration in the .stat file.</a:documentation>
        <ref name="comment"/>
      </element>
    </optional>
  </define>
  <define name="prognostic_scalar_stat_no_old_or_nonlinear_options.stat">
    <optional>
      <ref name="exclude_stat"/>
    </optional>
    <optional>
      <ref name="cv_stats"/>
    </optional>
    <zeroOrMore>
      <ref name="surface_integral_stats_scalar"/>
    </zeroOrMore>
    <zeroOrMore>
      <ref name="mixing_stats"/>
    </zeroOrMore>
  </define>
  <!-- Diagnostic statistics options for vector fields, with enabled by default -->
  <define name="vector_field_stat_options_enabled_default">
    <ref name="include_stat"/>
  </define>
  <define name="vector_field_stat_options_enabled_default" combine="choice">
    <ref name="exclude_components_from_stat"/>
  </define>
  <define name="vector_field_stat_options_enabled_default" combine="choice">
    <ref name="exclude_stat"/>
  </define>
  <!-- Diagnostic statistics options for vector fields, with enabled by default -->
  <define name="vector_field_stat_options_disabled_default">
    <ref name="exclude_stat"/>
  </define>
  <define name="vector_field_stat_options_disabled_default" combine="choice">
    <ref name="exclude_components_from_stat"/>
  </define>
  <define name="vector_field_stat_options_disabled_default" combine="choice">
    <ref name="include_stat"/>
  </define>
  <!-- Diagnostic statistics for prognostic vector fields -->
  <define name="prognostic_vector_stat_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <ref name="prognostic_vector_stat_options.stat"/>
    </element>
  </define>
  <!-- Diagnostic statistics for all other vector fields -->
  <define name="prognostic_vector_stat_no_old_or_nonlinear_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <ref name="prognostic_vector_stat_no_old_or_nonlinear_options.stat"/>
    </element>
  </define>
  <define name="diagnostic_vector_stat_options">
    <ref name="prognostic_vector_stat_no_old_or_nonlinear_options"/>
  </define>
  <define name="prescribed_vector_stat_options">
    <ref name="prognostic_vector_stat_no_old_or_nonlinear_options"/>
  </define>
  <!-- Combining of stat elements for vector fields -->
  <define name="prognostic_vector_stat_options.stat">
    <ref name="prognostic_vector_stat_no_old_or_nonlinear_options.stat"/>
  </define>
  <define name="prognostic_vector_stat_options.stat" combine="interleave">
    <element name="previous_time_step">
      <a:documentation>Specify how the previous timestep value of this field is added to the .stat file.</a:documentation>
      <ref name="vector_field_stat_options_disabled_default"/>
    </element>
    <element name="nonlinear_field">
      <a:documentation>Specify how the values of this field used in the nonlinear iteration are added to the .stat file.</a:documentation>
      <ref name="vector_field_stat_options_disabled_default"/>
    </element>
    <optional>
      <element name="compute_body_forces_on_surfaces">
        <a:documentation>What surface IDs do you want to do the calculation over?</a:documentation>
        <ref name="integer_vector"/>
      </element>
    </optional>
  </define>
  <define name="prognostic_vector_stat_no_old_or_nonlinear_options.stat">
    <ref name="vector_field_stat_options_enabled_default"/>
    <zeroOrMore>
      <ref name="surface_integral_stats_vector"/>
    </zeroOrMore>
  </define>
  <!-- Convergence options for prognostic scalar fields -->
  <define name="scalar_convergence_options">
    <element name="convergence">
      <a:documentation>Decide whether this field is tested for convergence
during nonlinear iterations
(if /timestepping/nonlinear_iterations and
/timestepping/nonlinear_iterations/tolerance are
enabled).
Also specifies whether the field is added to the 
convergence file (if /io/convergence_file is enabled).</a:documentation>
      <choice>
        <element name="include_in_convergence">
          <a:documentation>Include this field in convergence testing
(if /timestepping/nonlinear_iterations and
/timestepping/nonlinear_iterations/tolerance are
enabled) and file (if /io/convergence_file is enabled)</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_from_convergence">
          <a:documentation>Exclude this field from convergence testing and file </a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!-- Convergence statistics options for prognostic vector fields (velocity) -->
  <define name="vector_convergence_options">
    <element name="convergence">
      <a:documentation>Decide whether this field is tested for convergence
during nonlinear iterations
(if /timestepping/nonlinear_iterations and
/timestepping/nonlinear_iterations/tolerance are
enabled).
Also specifies whether the field is added to the 
convergence file (if /io/convergence_file is enabled).</a:documentation>
      <choice>
        <element name="include_in_convergence">
          <a:documentation>Include this field (magnitude and components)
in convergence testing
(if /timestepping/nonlinear_iterations and
/timestepping/nonlinear_iterations/tolerance are
enabled) and file (if /io/convergence_file is enabled)</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_components_from_convergence">
          <a:documentation>Include just the magnitude of this field 
in convergence testing
(if /timestepping/nonlinear_iterations and
/timestepping/nonlinear_iterations/tolerance are
enabled) and file (if /io/convergence_file is enabled)
i.e. excluding the components</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_from_convergence">
          <a:documentation>Exclude this field entirely from convergence testing and file </a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!-- Steady state options for prognostic scalar fields -->
  <define name="scalar_steady_state_options">
    <element name="steady_state">
      <a:documentation>Decide whether this field is tested for a steady state
between timesteps
(if /timestepping/steady_state is
enabled).</a:documentation>
      <choice>
        <element name="include_in_steady_state">
          <a:documentation>Include this field in steady state testing
(if /timestepping/steady_state is
enabled)</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_from_steady_state">
          <a:documentation>Exclude this field from steady state testing</a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!-- Steady state statistics options for prognostic vector fields (velocity) -->
  <define name="vector_steady_state_options">
    <element name="steady_state">
      <a:documentation>Decide whether this field is tested for a steady state
between timesteps
(if /timestepping/steady_state is
enabled).</a:documentation>
      <choice>
        <element name="include_in_steady_state">
          <a:documentation>Include this field (magnitude and components)
in steady state testing
(if /timestepping/steady_state is enabled)</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_components_from_steady_state">
          <a:documentation>Include just the magnitude of this field 
in steady state testing
(if /timestepping/steady_state is
enabled)
i.e. excluding the components</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_from_steady_state">
          <a:documentation>Exclude this field entirely from convergence testing and file </a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!-- Options for whether a field is to be included in detector output. -->
  <define name="detector_options_enabled_default">
    <element name="detectors">
      <a:documentation>Specify what is added to detector files</a:documentation>
      <choice>
        <element name="include_in_detectors">
          <a:documentation>This field is output at each detector location.</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_from_detectors">
          <a:documentation>This field is not output at detector locations.</a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!-- Options for whether a field is to be included in detector output. -->
  <define name="detector_options_disabled_default">
    <element name="detectors">
      <a:documentation>Specify what is added to detector files</a:documentation>
      <choice>
        <element name="exclude_from_detectors">
          <a:documentation>This field is not output at detector locations.</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="include_in_detectors">
          <a:documentation>This field is output at each detector location.</a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!--
    Detector output defaults on for prognostic and diagnostic fields, 
    off for prescribed.
  -->
  <define name="prognostic_detector_options">
    <ref name="detector_options_enabled_default"/>
  </define>
  <define name="diagnostic_detector_options">
    <ref name="detector_options_enabled_default"/>
  </define>
  <define name="prescribed_detector_options">
    <ref name="detector_options_disabled_default"/>
  </define>
  <define name="adaptivity_preprocessing">
    <optional>
      <element name="preprocessing">
        <a:documentation>Occasionally, it is desirable to apply operations or filters
to fields before using them for the purposes of adaptivity.</a:documentation>
        <element name="helmholtz_smoother">
          <a:documentation>Invert a helmholtz operator to smooth out the field
before using it to adapt. This can help with noisy
fields.</a:documentation>
          <element name="smoothing_length_scale">
            <ref name="real_dim_symmetric_tensor"/>
          </element>
          <element name="solver">
            <ref name="linear_solver_options_sym"/>
          </element>
        </element>
      </element>
    </optional>
  </define>
  <define name="generic_aliased_field">
    <attribute name="material_phase_name">
      <data type="string"/>
    </attribute>
    <attribute name="field_name">
      <data type="string"/>
    </attribute>
  </define>
  <!-- Most common mesh choices -->
  <define name="mesh_choice">
    <choice>
      <element name="mesh">
        <attribute name="name">
          <data type="string"/>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>CoordinateMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>VelocityMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>PressureMesh</value>
        </attribute>
      </element>
    </choice>
  </define>
  <!--
    Not really a choice, for fields that have to be on the velocity mesh
    currently that's all scalar fields, except pressure
    and of course velocity itself
    If you want to implement scalar fields on other meshes, feel free to do so
    but bare in mind you need to make sure the field stays outside RMEM.
    Currently all scalar fields are packed in RMEM with length nonods
  -->
  <define name="velocity_mesh_choice">
    <choice>
      <element name="mesh">
        <attribute name="name">
          <value>VelocityMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>PressureMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>CoordinateMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
      </element>
    </choice>
  </define>
  <define name="pressure_mesh_choice">
    <choice>
      <element name="mesh">
        <attribute name="name">
          <value>PressureMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>VelocityMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>CoordinateMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
      </element>
    </choice>
  </define>
  <!-- This is the choice of additional scalar field to be solved for -->
  <define name="scalar_field_choice">
    <!--
      The first is a generic field, which may be used for any user-defined field
      that FLUIDITY knows nothing about, or a generic diagnostic
    -->
    <choice>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <choice>
          <a:documentation>Field type</a:documentation>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="diagnostic">
            <ref name="scalar_diagnostic_algorithms"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="___Prognostic_Fields_Below___">
        <a:documentation>Prognostic scalar fields below this</a:documentation>
        <empty/>
      </element>
      <!--
        This is the long list of fields that FLUIDITY knows about
        - - First is a list of fields that are primarily prognostic,
           but can be set to prescribed, or aliased...
        - - The list is in order of most frequently used.
      -->
      <element name="scalar_field">
        <a:documentation>Salinity</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Salinity</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = 42</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Temperature</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Temperature</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -1</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Background Temperature</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>BackgroundTemperature</value>
        </attribute>
        <element name="prescribed">
          <ref name="velocity_mesh_choice"/>
          <ref name="prescribed_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Passive Tracer</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Tracer</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = 666</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Free Surface
NOTE: the prognostic FreeSurface field only works with the
legacy_continuous_galerkin code path
NOTE: if you are using the free_surface boundary condition
applied to the Velocity field (recommended), you should not 
use the prognostic FreeSurface field. In this case you may 
(optionally) add a diagnostic FreeSurface field.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>FreeSurface</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <a:documentation>Free Surface
NOTE: the prognostic FreeSurface field only works with the
legacy_continuous_galerkin code path</a:documentation>
            <element name="mesh">
              <a:documentation>Note that this is not the quadratic mesh balance pressure is
actually calculated on, but the linear mesh it is projected back
on for output purposes.</a:documentation>
              <attribute name="name">
                <value>VelocityMesh</value>
              </attribute>
            </element>
            <ref name="prognostic_free_surface_field"/>
          </element>
          <element name="diagnostic">
            <a:documentation>Free Surface
NOTE: the diagnostic FreeSurface field only works in combination
with the free_surface boundary condition applied to the Velocity
field. It gives you a 3D field (constant over the vertical)
of the free surface elevation.</a:documentation>
            <ref name="internal_algorithm"/>
            <!--
              this is hard-coded on the PressureMesh as long as the Pressure is
              if this is no longer true, it should be option-checked to be on the
              same mesh as Pressure
            -->
            <element name="mesh">
              <a:documentation>Must be on the same mesh as Pressure</a:documentation>
              <attribute name="name">
                <value>PressureMesh</value>
              </attribute>
            </element>
            <ref name="diagnostic_scalar_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Second Fluid</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>SecondFluid</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = 56</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Diffuse Interface</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>DiffuseInterface</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = 57</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>If enabled, decomposes Pressure by solving for the balanced part of 
Pressure using a "geopressure" solver:

  f = - grad p_gp + g

By choosing an appropriate mesh (typically velocity mesh order + 1)
for the balanced part of pressure, physical balance can be
represented to a higher degree of accuracy.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>GeostrophicPressure</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -2003</value>
        </attribute>
        <element name="prognostic">
          <element name="mesh">
            <a:documentation>The GeostrophicPressure mesh

&lt;b&gt;WARNING: It is usual for this to be a higher degree
mesh than the velocity mesh&lt;/b&gt;</a:documentation>
            <attribute name="name">
              <data type="string"/>
            </attribute>
            <ref name="comment"/>
          </element>
          <ref name="prognostic_geostrophic_pressure_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>VerticalBalancePressure</value>
        </attribute>
        <element name="prognostic">
          <ref name="mesh_choice">
            <a:documentation>This needs to be a quadratic DG mesh</a:documentation>
          </ref>
          <ref name="prognostic_vertical_balance_pressure_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>MaterialVolumeFraction field:

Volume fraction of this material.
Required in multimaterial simulations.
 - if prognostic solves for the volume fraction
 - if prescribed uses a specified volume fraction
 - if diagnostic solves for the final material volume fraction
Only 1 diagnostic MaterialVolumeFraction field allowed per
simulation or solves for all the volume fractions based on
the SumMaterialVolumeFractions field.

A diagnostic MaterialVolumeFraction field is currently required for
compressible multimaterial simulations (even if only 1 material).
Generally also requires a MaterialDensity field.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MaterialVolumeFraction</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
            <optional>
              <ref name="cap_option"/>
            </optional>
            <optional>
              <ref name="surface_tension_option"/>
            </optional>
          </element>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
            <optional>
              <ref name="cap_option"/>
            </optional>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
            <optional>
              <ref name="cap_option"/>
            </optional>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>MaterialDensity field:

Field for the density of this material.
Required in multimaterial simulations.
 - prescribed if an incompressible simulation
 - diagnostic if using a linear equation of state
 - prognostic if a compressible simulation
(note that if you set a multimaterial
equation of state and this field is
prognostic then its initial condition
will be overwritten by the density that
satisfies the initial pressure and
the equation of state)</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MaterialDensity</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>MaterialInternalEnergy field:

Field for the internal energy of this material.
Required in multimaterial compressible simulations
with full miegrunneisen (perfect gas) eos.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MaterialInternalEnergy</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>SumMaterialVolumeFractions field:

Sums the prognostic MaterialVolumeFraction fields.
- diagnostic: sums all the volume fractions in the other
  material phases</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>SumMaterialVolumeFractions</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>CopiedField - This field copies the previous timesteps
values from another (specified) field at every iteration
and then solves the field using different (again, specified)
scheme and solution options.
For instance, this field can be used to create a diffused
field to adapt to.
Unless someone requests otherwise this is only currently possible
for fields within the same material_phase.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>CopiedField</value>
        </attribute>
        <element name="prognostic">
          <ref name="velocity_mesh_choice"/>
          <attribute name="copy_from_field">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <ref name="prognostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Calculate the stream function of 2D incompressible flow. Note 
that this *only* makes sense for proper 2D (not pseudo-2D) simulations.
Requires a continuous mesh.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>StreamFunction</value>
        </attribute>
        <element name="prognostic">
          <ref name="mesh_choice"/>
          <ref name="prognostic_stream_function_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Phytoplankton</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Phytoplankton</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Zooplankton</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Zooplankton</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Nutrient</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Nutrient</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Detritus</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Detritus</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>PhaseVolumeFraction:
Required in porous_media problem type</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>PhaseVolumeFraction</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Electrical Potential:
Required in electrokinetic, electrothermal
and electrochemical problems
(sub-option of porous_media problem type)</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ElectricalPotential</value>
        </attribute>
        <element name="prognostic">
          <ref name="velocity_mesh_choice"/>
          <ref name="prognostic_scalar_field"/>
        </element>
      </element>
      <!--
        Insert new prognostic scalar fields here using the template:
               element scalar_field {
                   attribute rank { "0" },
                   attribute name { "NewFieldName" },
                   (
                      element prognostic {
                         velocity_mesh_choice,
                         prognostic_scalar_field
                      }|
                      element prescribed {
                         velocity_mesh_choice,
                         prescribed_scalar_field
                      }|
                      element aliased {
                         generic_aliased_field
                      }
                   )
               }
      -->
      <!--
        - - Second is a list of fields that are primarily prescribed,
           but can be aliased. An example is wind velocity.
        - - The list is in order of most frequently used.
      -->
      <element name="___Prescribed_fields_below___">
        <a:documentation>Prescribed scalar fields below this</a:documentation>
        <empty/>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>DistanceToSideBoundaries</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -144</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>MaterialFrictionAngle for multimaterial
plasticity problems

Requires a diagnostic bulk FrictionAngle field
- not tested yet</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MaterialFrictionAngle</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>MaterialCohesion for multimaterial
plasticity problems

Requires a diagnostic bulk Cohesion field
- not tested yet</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MaterialCohesion</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <!--
        
        Insert new prescribed scalar fields here using the template:
               element scalar_field {
                   attribute rank { "0" },
                   attribute name { "NewFieldName" },
                   (
                      element prescribed {
                         velocity_mesh_choice,
                         prescribed_scalar_field
                      }|
                      element aliased {
                         generic_aliased_field
                      }
                   )
               }
        
        - - Last is a list of fields that are primarily diagnostic,
           but can be aliased. An example is Tidal Range.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Diagnostic_Fields_Below___">
        <a:documentation>Diagnostic scalar fields below this</a:documentation>
        <empty/>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>PerturbationDensity</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -143</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>ControlVolumeDivergence:

div field

Divergence of the velocity field where
the divergence operator is defined using
the control volume C^T matrix.
This assumes that the test space is discontinuous
control volumes.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ControlVolumeDivergence</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_cv_divergence_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Diffusive dissipation</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>DiffusiveDissipation</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Viscous dissipation</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ViscousDissipation</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Richardson Number:

 Ri = \frac{N^2}{(\frac{\partial u}{\partial z})^2 + (\frac{\partial u}{\partial z})^2}
with 
 N^2 = -\frac{g}{\rho_0}\frac{\partial \rho}{\partial z}

Limitations:
 - Gravity must be constant.
 - Assumes gravity is in -ve final coordinate direction.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>RichardsonNumber</value>
        </attribute>
        <attribute name="depends">
          <value>Velocity,PerturbationDensity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_richardson_number_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>CFLNumber

See http://amcg.ese.ic.ac.uk/index.php?title=Local:Diagnostics#CFL_Number

Adapting to this field is not recommended</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>CFLNumber</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -601</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>ControlVolumeCFLNumber

Courant Number as defined on a control volume mesh

Adapting to this field is not recommended</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ControlVolumeCFLNumber</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>DG_CourantNumber

Courant Number as defined on a DG mesh

Adapting to this field is not recommended</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>DG_CourantNumber</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>CVMaterialDensityCFLNumber

Courant Number as defined on a control volume mesh and
incorporating the MaterialDensity.
Requires a MaterialDensity field!

Adapting to this field is not recommended</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>CVMaterialDensityCFLNumber</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>SolidConcentration</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>This scalar field is meant to replace DENTRAF.
Basically, if you use new options, DENTRAF is no longer needed
No repointing is done from this field to DENTRAF.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>CopyofDensity</value>
        </attribute>
        <attribute name="replaces">
          <value>DENTRAF</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Add field to be used by Solid_configuration to 
Visualize the solids and MaterialVolumeFraction together</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>VisualizeSolidFluid</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Add field to be used by Solid_configuration to 
Visualize the solid_Concentration</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>VisualizeSolid</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Add field to be used by Solid_configuration to 
map  the solid_Concentration from particle mesh to 
the fluid mesh.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ParticleScalar</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Add field to be used by Explicit_ALE to 
visualize functional values before iterations start.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>FunctionalBegin</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Add field to be used by Explicit_ALE to 
visualize functional values at each iteration.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>FunctionalIter</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>add a MaterialVolume scalar_field to calculate the spatially varying 
volume of a material (requires a MaterialVolumeFraction)</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MaterialVolume</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>add a MaterialMass scalar_field to calculate the spatially varying 
mass of a material (requires a MaterialVolumeFraction and a MaterialDensity)</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MaterialMass</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Calculates the MaterialDensity based on the bulk Pressure
(and MaterialInternalEnergy if appropriate) for the equation
of state of this material.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MaterialEOSDensity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Calculates the MaterialPressure based on the MaterialDensity
(and MaterialInternalEnergy if appropriate) for the equation
of state of this material.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MaterialPressure</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Calculates the BulkMaterialPressure based on the MaterialDensity
and MaterialVolumeFraction (and MaterialInternalEnergy if appropriate) 
for the equation of state of all materials.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>BulkMaterialPressure</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Grid Reynolds number</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>GridReynoldsNumber</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <element name="mesh">
              <attribute name="name">
                <value>VelocityMesh</value>
              </attribute>
            </element>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>GridPecletNumber

Peclet Number Pe = U*dx/2*diffusivity

Also see the test case 'grid_peclet_number'
if you wish to see the effect of changing the 
diffusivity on a 1D, cg-discretised tracer-field

Adapting to this field is not recommended</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>GridPecletNumber</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="mesh_choice">
              <a:documentation>Mesh on which to calculate dx</a:documentation>
            </ref>
            <element name="field_name">
              <a:documentation>This is the name of the scalar field
to calculate the Peclet number for
Note this field needs to have a diffusivity</a:documentation>
              <data type="string" datatypeLibrary=""/>
            </element>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Horizontal velocity divergence:

div_H velocity

Uses the gravity field direction to determine the horizontal plane.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HorizontalVelocityDivergence</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Velocity divergence:

div velocity
</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>VelocityDivergence</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Vorticity for a 2D field:

 du   dv
 -- - --
 dy   dx</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Vorticity2D</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Kinetic energy density:

 1/2 rho_0*|u|^2

where rho_0 is the (reference) density 

Limitations:
 - The Density, PerturbationDensity, KineticEnergyDensity and Velocity fields must be on the same mesh.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>KineticEnergyDensity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Gravitational potential energy density:

rho_0*(1.0 + rho')*(g dot (r - r_0))

where rho_0 is the (reference) density, rho' is the perturbation density and r_0 is the potential energy zero point.

Limitations:
 - Requires a constant gravity direction.
 - The Density, PerturbationDensity and GravitationalPotentialEnergyDensity fields must be on the same mesh.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>GravitationalPotentialEnergyDensity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
            <element name="zero_point">
              <a:documentation>Coordinate of a point with a potential energy of zero.</a:documentation>
              <ref name="real_dim_vector"/>
            </element>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Isopycnal coordinate

 z_star(x,t) = 1/A int_V' H(rho(x',t)-rho(x,t)) dV'

where rho is the density, A is the width/area of the domain

Limitations:
 - You need to specify a (fine) mesh to redistribute the PerturbationDensity onto
 - Requires a constant gravity direction.
 - The Density, PerturbationDensity and GravitationalPotentialEnergyDensity fields must be on the same mesh.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>IsopycnalCoordinate</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <element name="fine_mesh">
              <a:documentation>This is the mesh onto which we redistribute the PerturbationDensity</a:documentation>
              <attribute name="name">
                <data type="string" datatypeLibrary=""/>
              </attribute>
            </element>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Background potential energy density:

PE_b = rho*z_star

where rho is the density, z_star is the isopycnal coordinate

Limitations:
 - Requires a constant gravity direction.
 - The Density, PerturbationDensity and
 GravitationalPotentialEnergyDensity fields must be on the
 same mesh.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>BackgroundPotentialEnergyDensity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Ertel potential vorticity:

 (f + curl u) dot grad rho'

Limitations:
 - Requires a geometry dimension of 3.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>PotentialVorticity</value>
        </attribute>
        <attribute name="depends">
          <value>Velocity,PerturbationDensity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Relative potential vorticity:

  curl u dot grad rho'</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>RelativePotentialVorticity</value>
        </attribute>
        <attribute name="depends">
          <value>Velocity,PerturbationDensity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Local average mesh edge lengths</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MeshEdgeLengths</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <element name="mesh">
              <attribute name="name">
                <value>CoordinateMesh</value>
              </attribute>
            </element>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Calculate the horizontal stream function psi where:
  \partial_x \psi = -v
  \partial_y \psi = u
where u and v are perpendicular to the gravity direction. Applies a
strong Dirichlet boundary condition of 0 on all boundaries.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HorizontalStreamFunction</value>
        </attribute>
        <attribute name="depends">
          <value>Velocity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <element name="solver">
              <a:documentation>Solver</a:documentation>
              <ref name="linear_solver_options_sym"/>
            </element>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Speed:

 |u|

Limitations:
 - The Speed and Velocity fields must be on the same mesh.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Speed</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Volume of the vehicles

used in Traffic Modelling</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>SolidPhase</value>
        </attribute>
        <attribute name="raplaces">
          <value>IDENT = -42</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Absolute Difference between two scalar fields.

Both fields must be in this material_phase.
Assumes both fields are on the same mesh as the AbsoluteDifference field.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>AbsoluteDifference</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name_a">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <attribute name="field_name_b">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
            <optional>
              <element name="relative_to_average">
                <a:documentation>Evaluate the absolute difference once the average difference has been removed?</a:documentation>
                <empty/>
              </element>
            </optional>
            <optional>
              <element name="ignore_boundaries">
                <a:documentation>Ignore boundary nodes (i.e. zero them when calculating the difference)</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Absolute Difference between two scalar fields.

Both fields must be in this material_phase.
Assumes both fields are on the same mesh as the AbsoluteDifference field.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ScalarAbsoluteDifference</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name_a">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <attribute name="field_name_b">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
            <optional>
              <element name="relative_to_average">
                <a:documentation>Evaluate the absolute difference once the average difference has been removed?</a:documentation>
                <empty/>
              </element>
            </optional>
            <optional>
              <element name="ignore_boundaries">
                <a:documentation>Ignore boundary nodes (i.e. zero them when calculating the difference)</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Galerkin projection of one field onto another mesh.

The field must be in this material_phase.

NOTE: you need the solver options if the mesh
of this field is continuous.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>GalerkinProjection</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <element name="source_field_name">
              <data type="string" datatypeLibrary=""/>
            </element>
            <ref name="mesh_choice"/>
            <optional>
              <element name="lump_mass">
                <a:documentation>Lump the mass matrix of the galerkin projection
less accurate but faster and might give smoother result.                  </a:documentation>
                <empty/>
              </element>
            </optional>
            <optional>
              <element name="solver">
                <ref name="linear_solver_options_sym"/>
              </element>
            </optional>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Primary production of Phytoplankton. This is calculated by
the ocean biology module and will not be calculated unless
ocean biology is being simulated.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>PrimaryProduction</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Grazing of Phytoplankton by Zooplankton. This is calculated by
the ocean biology module and will not be calculated unless
ocean biology is being simulated.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>PhytoplanktonGrazing</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>TidalRange</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -32</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field_tidal_range"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MaxFreeSurface</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -33</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MinFreeSurface</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -34</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicAmplitudeM2</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicPhaseM2</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicAmplitudeS2</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicPhaseS2</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicAmplitudeN2</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicPhaseN2</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicAmplitudeK2</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicPhaseK2</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicAmplitudeK1</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicPhaseK1</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicAmplitudeO1</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicPhaseO1</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicAmplitudeP1</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicPhaseP1</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicAmplitudeQ1</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicPhaseQ1</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicAmplitudeMf</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicPhaseMf</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicAmplitudeMm</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicPhaseMm</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicAmplitudeSSa</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Output the universal numbering of the mesh on which this field is based.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>UniversalNumber</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Output the processors which own the nodes of the mesh on which this field is based.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>NodeOwner</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Output the processors which own the elements of the mesh on which this field is based.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ElementOwner</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Primary production of Phytoplankton. This is calculated by
the ocean biology module and will not be calculated unless
ocean biology is being simulated.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicPhaseSSa</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
    </choice>
    <!--
      Insert new diagnostic scalar fields here using the template:
             element scalar_field {
                 attribute rank { "0" },
                 attribute name { "NewFieldName" },
                 (
                    element diagnostic {
                       internal_algorithm,
                       velocity_mesh_choice,
                       diagnostic_scalar_field
                    }|
                    element aliased {
                       generic_aliased_field
                    }
                 )
             }
    -->
  </define>
  <!-- This is the choice of additional vector field to be solved for -->
  <define name="vector_field_choice">
    <!--
      The first is a generic field, which may be used for any user-defined field
      that FLUIDITY knows nothing about, or a generic diagnostic
      Prognostic vector fields are not possible (other than velocity and those known fields below).
    -->
    <choice>
      <element name="vector_field">
        <a:documentation>Generic field variable (vector)</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <choice>
          <a:documentation>Field type</a:documentation>
          <element name="prescribed">
            <ref name="mesh_choice"/>
            <ref name="prescribed_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
          <element name="diagnostic">
            <ref name="vector_diagnostic_algorithms"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
        </choice>
      </element>
      <!--
        
        - - List of fields that are primarily prognostic,
           but can be aliased.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Prognostic_fields_below___">
        <a:documentation>Prescribed vector fields below this</a:documentation>
        <empty/>
      </element>
      <!--
        
        - - List of fields that are primarily prescribed,
           but can be aliased. An example is Maximum bed shear stress.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Prescribed_fields_below___">
        <a:documentation>Prescribed vector fields below this</a:documentation>
        <empty/>
      </element>
      <!--
        
        Insert new prescribed vector fields here using the template:
               element vector_field {
                   attribute rank { "1" },
                   attribute name { "NewFieldName" },
                   (
                      element prescribed {
                         mesh_choice,
                         prescribed_vector_field
                      }|
                      element aliased {
                         generic_aliased_field
                      }
                   )
               }
        
        - - Last is a list of fields that are primarily diagnostic,
           but can be aliased. An example is Tidal Range.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Diagnostic_Fields_Below___">
        <a:documentation>Diagnostic vector fields below this</a:documentation>
        <empty/>
      </element>
      <element name="vector_field">
        <a:documentation>Temperature gradient</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>TemperatureGradient</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Gradient of a scalar field.
Field must be in this material_phase.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>Gradient</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Gradient of a scalar field evaluated using the C gradient
matrix constructed using finite elements.
Field must be in this material_phase.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>FiniteElementGradient</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="mesh_choice"/>
            <optional>
              <element name="integrate_gradient_by_parts">
                <empty/>
              </element>
            </optional>
            <ref name="diagnostic_gradient_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Gradient of a scalar field evaluated using the transpose
of the C^T divergence matrix constructed using finite
elements.
Field must be in this material_phase.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>FiniteElementDivergenceTransposed</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="mesh_choice"/>
            <optional>
              <element name="integrate_divergence_by_parts">
                <empty/>
              </element>
            </optional>
            <ref name="diagnostic_gradient_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Relative vorticity field - curl of the velocity field</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>Vorticity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <!--
              element algorithm {
                attribute name { "curl" },
                attribute material_phase_support { "single" },
                attribute source_field_name { "Velocity" }
              },
            -->
            <element name="mesh">
              <a:documentation>Relative vorticity</a:documentation>
              <attribute name="name">
                <value>VelocityMesh</value>
              </attribute>
            </element>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Planetary vorticity

Limitations:
 - Requires geometry dimension of 3.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>PlanetaryVorticity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Absolute vorticity:

  f + curl u

Limitations:
 - Requires a geometry dimension of 3.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>AbsoluteVorticity</value>
        </attribute>
        <attribute name="depends">
          <value>Velocity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Gradient of a scalar field evaluated using the transpose
of the C^T matrix constructed using control volumes.
Field must be in this material_phase.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>ControlVolumeDivergenceTransposed</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_cv_gradient_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Full velocity in an
inner element SGS treatment of momentum

Limitations:
 - Requires a geometry dimension of 3.
 - Requires inner element active for momentum</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>InnerElementFullVelocity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <element name="mesh">
              <attribute name="name">
                <value>InnerElementMesh</value>
              </attribute>
            </element>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Vorticity of the full velocity in an
inner element SGS treatment of momentum

Limitations:
 - Requires a geometry dimension of 3.
 - Requires inner element active for momentum</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>InnerElementFullVorticity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <element name="mesh">
              <attribute name="name">
                <value>InnerElementMesh</value>
              </attribute>
            </element>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Vorticity of the SGS velocity in an
inner element SGS treatment of momentum

Limitations:
 - Requires a geometry dimension of 3.
 - Requires inner element active for momentum</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>InnerElementVorticity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <element name="mesh">
              <attribute name="name">
                <value>InnerElementMesh</value>
              </attribute>
            </element>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>The continuous solution mapped to a discontinuous mesh

Limitations:
 - Requires a geometry dimension of 3.
 - Requires inner element active for momentum</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>DgMappedVelocity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <element name="mesh">
              <attribute name="name">
                <value>InnerElementMesh</value>
              </attribute>
            </element>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Vorticity of the DG mapped Velocity
Note vorticity is actually calculated over a DG field

Limitations:
 - Requires a geometry dimension of 3.
 - Requires inner element active for momentum</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>DgMappedVorticity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <element name="mesh">
              <attribute name="name">
                <value>InnerElementMesh</value>
              </attribute>
            </element>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Solid Velocity field.  Used to generate the momentum source </a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="replaces">
          <value>UTRAF,VTRAF,WTRAF</value>
        </attribute>
        <attribute name="name">
          <value>SolidVelocity</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="mesh_choice"/>
          <ref name="diagnostic_vector_field"/>
        </element>
      </element>
      <element name="vector_field">
        <a:documentation>Same as Solid Velocity field but it is on the Particle mesh.
It is used to map the velocities coming from an external program like
FEMDEM or DEM to the fluid mesh. </a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>ParticleVector</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="mesh_choice"/>
          <ref name="diagnostic_vector_field"/>
        </element>
      </element>
      <element name="vector_field">
        <a:documentation>Same as Solid Velocity field but it is on the Particle mesh.
It is used to map the velocities coming from an external program like
FEMDEM or DEM to the fluid mesh. </a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>ParticleForce</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="mesh_choice"/>
          <ref name="diagnostic_vector_field"/>
        </element>
      </element>
      <element name="vector_field">
        <a:documentation>Same as Solid Velocity field but it is on the Particle mesh.
It is used to map the velocities coming from an external program like
FEMDEM or DEM to the fluid mesh. </a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>SolidForce</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_vector_field"/>
        </element>
      </element>
      <element name="vector_field">
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>VelocityPlotForSolids</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_vector_field"/>
        </element>
      </element>
      <element name="vector_field">
        <a:documentation>Same as Solid Velocity field but it is on the Particle mesh.
It is used to map the velocities coming from an external program like
FEMDEM or DEM to the fluid mesh. </a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>FunctionalGradient</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_vector_field"/>
        </element>
      </element>
      <element name="vector_field">
        <a:documentation>LinearMomentum field.
 p = \rho*u 
(where p is the linear momentum, \rho the density and u the velocity)</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>LinearMomentum</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Calculate the control volume auxiliary gradient for a particular field.
The related field must be a scalar field in this material_phase.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ControlVolumeAuxiliaryGradient</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <attribute name="gradient_of_field">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Calculate the dg (Bassi Rebay) auxiliary gradient for a particular field.
The related field must be a scalar field in this material_phase.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>DGAuxiliaryGradient</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <attribute name="gradient_of_field">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Experimental geostrophic source field to be used in combination with
a free surface. Does not solve a vertical balance yet.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>GeostrophicSource</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="mesh_choice"/>
          <ref name="diagnostic_vector_field"/>
        </element>
      </element>
      <element name="vector_field">
        <a:documentation>Absolute Difference between two vector fields.

Both fields must be in this material_phase.
Assumes both fields are on the same mesh as the AbsoluteDifference field.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>AbsoluteDifference</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name_a">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <attribute name="field_name_b">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Absolute Difference between two vector fields.

Both fields must be in this material_phase.
Assumes both fields are on the same mesh as the AbsoluteDifference field.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>VectorAbsoluteDifference</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name_a">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <attribute name="field_name_b">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Bed Shear Stress = density*drag_coeff*|u|*u

at the moment this assumes the density and drag coefficients are constants.
This diagnostic vector field is only calculated over surface elements/nodes, 
interior nodes will have zero value.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>BedShearStress</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_vector_field_bed_shear_stress"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Max Bed Shear Stress.

Note that you need BedShearStress turned on for this to work.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>MaxBedShearStress</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <group>
              <ref name="internal_algorithm"/>
              <ref name="velocity_mesh_choice"/>
            </group>
            <!-- diagnostic_vector_field_max_bed_shear_stress -->
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
        <element name="spin_up_time">
          <a:documentation>This is the time after which the max operator is
applied to the bed shear stress.</a:documentation>
          <ref name="real"/>
        </element>
      </element>
      <element name="vector_field">
        <a:documentation>Displacement</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>Displacement</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Galerkin projection of one field onto another mesh.

The field must be in this material_phase.

NOTE: you need the solver options if the mesh
of this field is continuous.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>GalerkinProjection</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <element name="source_field_name">
              <data type="string" datatypeLibrary=""/>
            </element>
            <ref name="mesh_choice"/>
            <optional>
              <element name="lump_mass">
                <a:documentation>Lump the mass matrix of the galerkin projection
less accurate but faster and might give smoother result.                  </a:documentation>
                <empty/>
              </element>
            </optional>
            <optional>
              <element name="solver">
                <ref name="linear_solver_options_sym"/>
              </element>
            </optional>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Projects the Coriolis term onto the mesh of this diagnostic field.
Note that multiple projection methods are available (under the
algorithm option).</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>Coriolis</value>
        </attribute>
        <element name="diagnostic">
          <ref name="coriolis_algorithm"/>
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_vector_field"/>
        </element>
      </element>
    </choice>
    <!--
      Insert new diagnostic vector field here using the template:
             element vector_field {
                 attribute rank { "1" },
                 attribute name { "NewFieldName" },
                 (
                    element diagnostic {
                       internal_algorithm,
                       mesh_choice,
                       diagnostic_vector_field
                    }|
                    element aliased {
                       generic_aliased_field
                    }
                 )
             }
    -->
  </define>
  <!-- This is the choice of additional tensor fields -->
  <define name="tensor_field_choice">
    <!--
      The first is a generic field, which may be used for any user-defined field
      that FLUIDITY knows nothing about, or a generic diagnostic
      Prognostic tensor fields are not possible.
    -->
    <choice>
      <element name="tensor_field">
        <a:documentation>Generic field variable (tensor)</a:documentation>
        <attribute name="rank">
          <value>2</value>
        </attribute>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <choice>
          <a:documentation>Field type</a:documentation>
          <element name="prescribed">
            <ref name="mesh_choice"/>
            <ref name="prescribed_tensor_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
          <element name="diagnostic">
            <ref name="tensor_diagnostic_algorithms"/>
            <ref name="velocity_mesh_choice"/>
            <optional>
              <ref name="python_diagnostic_field_code"/>
            </optional>
            <ref name="diagnostic_tensor_field"/>
          </element>
        </choice>
      </element>
      <!--
        
        - - Second is a list of tensor fields that are primarily prescribed,
           but can be aliased.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Prescribed_fields_below___">
        <a:documentation>Prescribed scalar fields below this</a:documentation>
        <empty/>
      </element>
      <element name="tensor_field">
        <a:documentation>MaterialViscosity field:

Field for the viscosity of this material.
Required if using a diagnostic bulk viscosity
in a multimaterial simulation.</a:documentation>
        <attribute name="rank">
          <value>2</value>
        </attribute>
        <attribute name="name">
          <value>MaterialViscosity</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="mesh_choice"/>
            <ref name="prescribed_tensor_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="tensor_field">
        <attribute name="rank">
          <value>2</value>
        </attribute>
        <attribute name="name">
          <value>MaterialElasticity</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="mesh_choice"/>
            <ref name="prescribed_tensor_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <!--
        
        Insert new prescribed tensor fields here using the template:
               element tensor_field {
                   attribute rank { "2" },
                   attribute name { "NewFieldName" },
                   (
                      element prescribed {
                         mesh_choice,
                         prescribed_tensor_field
                      }|
                      element aliased {
                         generic_aliased_field
                      }
                   )
               }|
        
        - - Last is a list of fields that are primarily diagnostic,
           but can be aliased.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Diagnostic_Fields_Below___">
        <a:documentation>Diagnostic tensor fields below this</a:documentation>
        <empty/>
      </element>
      <element name="tensor_field">
        <a:documentation>From a field on a mesh, diagnose the anisotropic
interpolation weight that would give the mesh back.
It is computed as:
\Eps = M^-1 |H|</a:documentation>
        <attribute name="rank">
          <value>2</value>
        </attribute>
        <attribute name="name">
          <value>FieldTolerance</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <element name="source_field_name">
              <data type="string" datatypeLibrary=""/>
            </element>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_tensor_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
    </choice>
    <!--
      Insert new diagnostic tensor field here using the template:
             element tensor_field {
                 attribute name { "NewFieldName" },
                 (
                    element diagnostic {
                       internal_algorithm,
                       mesh_choice,
                       diagnostic_tensor_field
                    }|
                    element aliased {
                       generic_aliased_field
                    }
                 )
             }
    -->
  </define>
  <define name="mesh_info">
    <choice>
      <element name="from_file">
        <a:documentation>Read mesh from file.</a:documentation>
        <choice>
          <element name="format">
            <a:documentation>Triangle mesh format.

Enter the base name without the .edge .ele, .face or
.node extensions, and without process numbers.</a:documentation>
            <attribute name="name">
              <value>triangle</value>
            </attribute>
            <ref name="comment"/>
          </element>
          <element name="format">
            <a:documentation>Read the mesh from a vtu. Note that the mesh will have no surface
or region IDs.</a:documentation>
            <attribute name="name">
              <value>vtu</value>
            </attribute>
            <ref name="comment"/>
          </element>
          <element name="format">
            <a:documentation>CGNS mesh format (not yet implemented)</a:documentation>
            <attribute name="name">
              <value>cgns</value>
            </attribute>
            <ref name="comment"/>
          </element>
        </choice>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
        <ref name="from_file_mesh_stat_options"/>
        <ref name="comment"/>
      </element>
      <element name="from_mesh">
        <a:documentation>Make mesh from existing mesh. The existing mesh cannot itself
be made from an existing mesh (i.e. it must be read from a
file).</a:documentation>
        <ref name="mesh_choice"/>
        <optional>
          <element name="mesh_shape">
            <element name="polynomial_degree">
              <ref name="integer"/>
            </element>
          </element>
        </optional>
        <optional>
          <element name="mesh_continuity">
            <element name="string_value">
              <choice>
                <value>continuous</value>
                <value>discontinuous</value>
              </choice>
            </element>
          </element>
        </optional>
        <zeroOrMore>
          <element name="periodic_boundary_conditions">
            <a:documentation>Make mesh periodic</a:documentation>
            <attribute name="name">
              <data type="string"/>
            </attribute>
            <element name="physical_boundary_ids">
              <a:documentation>List of boundary ids that are aliased to</a:documentation>
              <ref name="integer_vector"/>
            </element>
            <element name="aliased_boundary_ids">
              <a:documentation>List of boundary ids that are aliased</a:documentation>
              <ref name="integer_vector"/>
            </element>
            <element name="coordinate_map">
              <a:documentation>Python code which takes coordinate of an aliased
boundary node and returns the coordinate of a physical
boundary node</a:documentation>
              <ref name="python_code"/>
            </element>
          </element>
        </zeroOrMore>
        <optional>
          <element name="extrude">
            <a:documentation>Extrude a horizontal (1D or 2D) mesh in the vertical</a:documentation>
            <element name="bottom_depth">
              <a:documentation>Depth over which to extrude
top will be at z=0
bottom will be at z=-bottom_depth</a:documentation>
              <ref name="real"/>
            </element>
            <element name="sizing_function">
              <a:documentation>Constant or function to specify the depth of the
layers. The function is a function of all coordinates
(so in 2+1D: x,y and z) to specify a layer depth that
varies both in the horizontal as in the vertical.</a:documentation>
              <ref name="input_choice_real"/>
            </element>
            <optional>
              <element name="top_surface_id">
                <a:documentation>surface_id to assign to the top of the extruded mesh</a:documentation>
                <ref name="integer"/>
              </element>
            </optional>
            <optional>
              <element name="bottom_surface_id">
                <a:documentation>surface_id to assign to the bottom of the extruded mesh</a:documentation>
                <ref name="integer"/>
              </element>
            </optional>
          </element>
        </optional>
        <ref name="derived_mesh_stat_options"/>
        <ref name="comment"/>
      </element>
    </choice>
  </define>
  <!-- Options for inclusion/exclusion of mesh statistics from the .stat file -->
  <define name="include_mesh_in_stat">
    <element name="include_in_stat">
      <a:documentation>Include this mesh in the .stat file</a:documentation>
      <ref name="comment"/>
    </element>
  </define>
  <define name="exclude_mesh_from_stat">
    <element name="exclude_from_stat">
      <a:documentation>Exclude this mesh from the .stat file</a:documentation>
      <ref name="comment"/>
    </element>
  </define>
  <!-- Diagnostic statistics options for meshed, with enabled by default -->
  <define name="mesh_stat_options_enabled_default">
    <ref name="include_mesh_in_stat"/>
  </define>
  <define name="mesh_stat_options_enabled_default" combine="choice">
    <ref name="exclude_mesh_from_stat"/>
  </define>
  <!-- Diagnostic statistics options for meshed, with disabled by default -->
  <define name="mesh_stat_options_disabled_default">
    <ref name="exclude_mesh_from_stat"/>
  </define>
  <define name="mesh_stat_options_disabled_default" combine="choice">
    <ref name="include_mesh_in_stat"/>
  </define>
  <define name="from_file_mesh_stat_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <ref name="mesh_stat_options_enabled_default"/>
    </element>
  </define>
  <define name="derived_mesh_stat_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <ref name="mesh_stat_options_disabled_default"/>
    </element>
  </define>
  <define name="input_choice_tensor_field">
    <choice>
      <element name="isotropic">
        <a:documentation>An isotropic tensor, i.e.
one with no directional variation.
Can be represented as a scalar real.</a:documentation>
        <ref name="input_choice_real"/>
      </element>
      <element name="anisotropic_symmetric">
        <a:documentation>A symmetric tensor, i.e.
A^T = A</a:documentation>
        <ref name="input_choice_real_dim_symmetric_tensor"/>
      </element>
      <element name="anisotropic_asymmetric">
        <a:documentation>A general asymmetric tensor.</a:documentation>
        <ref name="input_choice_real_dim_tensor"/>
      </element>
    </choice>
  </define>
  <define name="constitutive_laws">
    <choice>
      <element name="constitutive_law">
        <a:documentation>Constitutive laws for fluids</a:documentation>
        <attribute name="name">
          <value>fluid</value>
        </attribute>
      </element>
      <element name="constitutive_law">
        <a:documentation>Constitutive laws for solids</a:documentation>
        <attribute name="name">
          <value>solid</value>
        </attribute>
      </element>
    </choice>
  </define>
  <define name="region_ids">
    <optional>
      <element name="region_ids">
        <a:documentation>Optional region ids to associate different values
to different regions of the mesh.
Leave unselected if you`re not using multiple regions or
region_ids.
Currently only works with triangle files created by gmsh2triangle.</a:documentation>
        <ref name="integer_vector"/>
      </element>
    </optional>
  </define>
  <define name="temporal_control_volume_options">
    <element name="control_volumes">
      <a:documentation>Temporal discretisation options that are only relevant if a control volume or mixed control volume - continuous galerkin spatial discretisation is selected for this field.</a:documentation>
      <optional>
        <element name="number_advection_iterations">
          <a:documentation>Number of iterations within an advection solve.
This increases the accuracy of the face values and ensures that
the pivoted solution is cancelled out.
Defaults to 1 if unselected.</a:documentation>
          <attribute name="replaces">
            <value>INT(ABS(NDISOT)/10)</value>
          </attribute>
          <ref name="integer"/>
          <optional>
            <element name="tolerance">
              <a:documentation>Cut short advection_iterations if the specified tolerance
is reached.
This only works for pure control volume discretisations.</a:documentation>
              <ref name="real"/>
              <choice>
                <element name="infinity_norm">
                  <a:documentation>Select the norm with which you want the tolerance to be tested.

The infinity norm.</a:documentation>
                  <empty/>
                </element>
                <element name="l2_norm">
                  <a:documentation>Select the norm with which you want the tolerance to be tested.

The l2 norm.</a:documentation>
                  <empty/>
                </element>
                <element name="cv_l2_norm">
                  <a:documentation>Select the norm with which you want the tolerance to be tested.

The l2 norm evaluated on a control volume mesh.</a:documentation>
                  <empty/>
                </element>
              </choice>
            </element>
          </optional>
        </element>
      </optional>
      <optional>
        <choice>
          <element name="maximum_courant_number_per_subcycle">
            <a:documentation>Use timestep subcycling to solve this equation.
Specify the maximum courant number per subcycle.
This only works for pure control volume discretisations.</a:documentation>
            <ref name="real"/>
            <ref name="field_based_cfl_number_options"/>
          </element>
          <element name="number_advection_subcycles">
            <a:documentation>Use timestep subcycling to solve this equation.
Specify the number of subcycles.
This only works for pure control volume discretisations.</a:documentation>
            <ref name="integer"/>
          </element>
        </choice>
      </optional>
      <optional>
        <element name="limit_theta">
          <a:documentation>Only works if a control volume or mixed control volume -
continuous galerkin spatial discretisation is selected.
If not active then the theta specified above will be used.
Otherwise use variable limited theta on individual faces.</a:documentation>
          <attribute name="replaces">
            <value>MOD(INT(ABS(NDISOT)/1),10) = 1,3,5,7,9 (odd)</value>
          </attribute>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="pivot_theta">
          <a:documentation>Only works if a control volume or mixed control volume -
continuous galerkin spatial discretisation is selected.
Time discretisation of upwind discretisation off which the
higher order solution is pivotted.
 - pivot_theta = 1 - implicit pivot (default if not set and 
                     best choice if not intentionally modifying
                     scheme to be explicit)
 - pivot_theta = 0 - explicit pivot</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="temporal_discontinuous_galerkin_options">
    <element name="discontinuous_galerkin">
      <a:documentation>This enables DG-specific timestepping options, such as
explicit advection subcycling. </a:documentation>
      <optional>
        <choice>
          <element name="maximum_courant_number_per_subcycle">
            <a:documentation>Use timestep subcycling to solve this equation.
Specify the maximum courant number per subcycle.</a:documentation>
            <ref name="real"/>
          </element>
          <element name="number_advection_subcycles">
            <a:documentation>Use timestep subcycling to solve this equation.
Specify the number of subcycles.</a:documentation>
            <ref name="integer"/>
          </element>
        </choice>
      </optional>
    </element>
  </define>
  <define name="pure_cv_options">
    <element name="control_volumes">
      <a:documentation>Use a pure control volume discretisations.
Follows a new control volume code path.</a:documentation>
      <ref name="spatial_control_volume_options"/>
      <choice>
        <element name="diffusion_scheme">
          <a:documentation>Use the gradient of the field constructed using the
basis functions of the parent finite element mesh to
form the divergence.

DOES NOT CURRENTLY WORK WITH ROBIN OR WEAK DIRICHLET BOUNDARY CONDITIONS!

Based on schemes in Handbook of Numerical Analysis,
P.G. Ciarlet, J.L. Lions eds, vol 7, pp 713-1020</a:documentation>
          <attribute name="name">
            <value>ElementGradient</value>
          </attribute>
        </element>
        <element name="diffusion_scheme">
          <a:documentation>Use an auxiliary gradient equation to find the gradient of the field.

DOES NOT CURRENTLY WORK WITH ROBIN BOUNDARY CONDITIONS!

Based on scheme proposed in Bassi, F. &amp; Rebay, S., A
high-order accurate discontinuous finite element method
for the numerical solution of the compressible
Navier-Stokes equations, Journal Of Computational
Physics, 1997, 131, 267-279</a:documentation>
          <attribute name="name">
            <value>BassiRebay</value>
          </attribute>
        </element>
      </choice>
    </element>
  </define>
  <define name="spatial_control_volume_options">
    <ref name="standard_control_volume_options"/>
  </define>
  <define name="spatial_control_volume_options" combine="choice">
    <ref name="compressive_control_volume_options"/>
  </define>
  <define name="standard_control_volume_options">
    <choice>
      <element name="face_value">
        <a:documentation>First Order Upwind face value discretisation
 face_value = donor_value, 
where
 donor_value = income*val_1 + (1.-income)*val_2, 
where val_i is the value on the ith node neighbouring the face and
income = [0, 1] depending on whether the flow is coming from node 1 or 2
First order upwinding is monotonic so no limiting is ever required</a:documentation>
        <attribute name="name">
          <value>FirstOrderUpwind</value>
        </attribute>
        <attribute name="replaces">
          <value>MOD(INT(ABS(NDISOT)/1),10) = 0,1</value>
        </attribute>
        <empty/>
      </element>
      <element name="face_value">
        <a:documentation>Trapezoidal face value discretisation
 face_value = 0.5*(val_1 + val_2), 
where
 val_i is the value on the ith node neighbouring the face

Trapezoidal discretisation is unbounded so limiting is compulsory</a:documentation>
        <attribute name="name">
          <value>Trapezoidal</value>
        </attribute>
        <attribute name="replaces">
          <value>MOD(INT(ABS(NDISOT)/1),10) = 2,3</value>
        </attribute>
        <ref name="limiter_options"/>
      </element>
      <element name="face_value">
        <a:documentation>Finite Element face value discretisation
 face_value = finite element interpolation from surrounding nodes

Finite element discretisation may become unbounded so limiting is often necessary.</a:documentation>
        <attribute name="name">
          <value>FiniteElement</value>
        </attribute>
        <attribute name="replaces">
          <value>MOD(INT(ABS(NDISOT)/1),10) = 4,5,6,7</value>
        </attribute>
        <optional>
          <ref name="limiter_options"/>
        </optional>
      </element>
    </choice>
  </define>
  <define name="coupled_spatial_control_volume_options">
    <ref name="coupled_control_volume_options"/>
  </define>
  <define name="coupled_spatial_control_volume_options" combine="choice">
    <ref name="compressive_control_volume_options"/>
  </define>
  <!--
    coupled control volume options are the same as the standard ones (annoyingly copied and pasted)
    except that firstorderupwind gets limiter options
  -->
  <define name="coupled_control_volume_options">
    <choice>
      <element name="face_value">
        <a:documentation>First Order Upwind face value discretisation
 face_value = donor_value, 
where
 donor_value = income*val_1 + (1.-income)*val_2, 
where val_i is the value on the ith node neighbouring the face and
income = [0, 1] depending on whether the flow is coming from node 1 or 2
First order upwinding is monotonic so no limiting is ever required</a:documentation>
        <attribute name="name">
          <value>FirstOrderUpwind</value>
        </attribute>
        <attribute name="replaces">
          <value>MOD(INT(ABS(NDISOT)/1),10) = 0,1</value>
        </attribute>
        <optional>
          <ref name="limiter_options"/>
        </optional>
      </element>
      <element name="face_value">
        <a:documentation>Trapezoidal face value discretisation
 face_value = 0.5*(val_1 + val_2), 
where
 val_i is the value on the ith node neighbouring the face

Trapezoidal discretisation is unbounded so limiting is compulsory</a:documentation>
        <attribute name="name">
          <value>Trapezoidal</value>
        </attribute>
        <attribute name="replaces">
          <value>MOD(INT(ABS(NDISOT)/1),10) = 2,3</value>
        </attribute>
        <ref name="limiter_options"/>
      </element>
      <element name="face_value">
        <a:documentation>Finite Element face value discretisation
 face_value = finite element interpolation from surrounding nodes

Finite element discretisation may become unbounded so limiting is often necessary.</a:documentation>
        <attribute name="name">
          <value>FiniteElement</value>
        </attribute>
        <attribute name="replaces">
          <value>MOD(INT(ABS(NDISOT)/1),10) = 4,5,6,7</value>
        </attribute>
        <optional>
          <ref name="limiter_options"/>
        </optional>
      </element>
    </choice>
  </define>
  <define name="compressive_control_volume_options">
    <choice>
      <element name="face_value">
        <a:documentation>HyperC face value discretisation

face_value calculated from upper bound of explicit TVD zone of NVD diagram
Normally used for MaterialVolumeFraction fields</a:documentation>
        <attribute name="name">
          <value>HyperC</value>
        </attribute>
        <attribute name="replaces">
          <value>MOD(INT(ABS(NDISOT)/1),10) = 8,9</value>
        </attribute>
        <optional>
          <ref name="upwind_value_options"/>
        </optional>
        <ref name="cv_face_cfl_number_options"/>
      </element>
      <element name="face_value">
        <a:documentation>UltraC face value discretisation

face_value calculated from extended upper bound of
explicit TVD zone of NVD diagram assuming
values bounded by target_maximum and target_minimum.</a:documentation>
        <attribute name="name">
          <value>UltraC</value>
        </attribute>
        <attribute name="replaces">
          <value>MOD(INT(ABS(NDISOT)/1),10) = 8,9, with ULTRAC = TRUE from solidity_options.inp</value>
        </attribute>
        <element name="target_maximum">
          <a:documentation>Specifiy the upper bound which UltraC will use to
calculate the maximum flux.</a:documentation>
          <ref name="real"/>
        </element>
        <element name="target_minimum">
          <a:documentation>Specifiy the lower bound which UltraC will use to
calculate the minimum flux.</a:documentation>
          <ref name="real"/>
        </element>
        <optional>
          <ref name="upwind_value_options"/>
        </optional>
        <ref name="cv_face_cfl_number_options"/>
      </element>
      <element name="face_value">
        <a:documentation>**UNDER TESTING**

PotentialUltraC face value discretisation

face_value calculated from extended upper bound of
explicit TVD zone of NVD diagram if potential
value of field is sufficient (as specified by
target_maximum) to ensure the correct front advection
velocity.

If not then either switch to HyperC or use a modified flux
based on the potential function.</a:documentation>
        <attribute name="name">
          <value>PotentialUltraC</value>
        </attribute>
        <element name="target_maximum">
          <a:documentation>Specifiy the upper bound which PotentialUltraC will use
to calculate the maximum flux if the potential function
value is sufficient to maintain the correct front
advection velocity.</a:documentation>
          <ref name="real"/>
        </element>
        <element name="target_minimum">
          <a:documentation>Specifiy the lower bound which PotentialUltraC will use to calculate the minimum flux.</a:documentation>
          <ref name="real"/>
        </element>
        <choice>
          <element name="switch_to_hyperc">
            <a:documentation>Select what PotentialUltraC should do if the
potential function value does not reach the required
value specified by the target_maximum.

Switch to using HyperC face values.  This ensures
that the advection velocity is correct however may
create isolated regions beneath the target_maximum.</a:documentation>
            <empty/>
          </element>
          <element name="use_potential_flux">
            <a:documentation>Select what PotentialUltraC should do if the
potential function value does not reach the required
value specified by the target_maximum.

Modify the maximum nodal values (both downwind and
upwind) so that the fluxes are at their maximum
possible without affecting the front advection
velocity.</a:documentation>
            <empty/>
          </element>
        </choice>
        <optional>
          <ref name="upwind_value_options"/>
        </optional>
        <ref name="cv_face_cfl_number_options"/>
      </element>
    </choice>
  </define>
  <!--
    Select the type of dynamic control to be used
    Note: DEM and FEMDEM require the respective libraries
    to be compiled.
  -->
  <define name="input_solid_dynamics_choice">
    <choice>
      <element name="dynamic_type">
        <a:documentation>Obtain values from point and radius file.

First line of file is free to use (for comments)
Second line must contain the number of particles
Third and fourth line are again for comments. 
Following lines include 10 columns, corresponding to 
the particle's x, y, and z positions, followed by the radius, then
velocities in x, y, and z directions, followed by angular velocities
in the x, y, and z directions.</a:documentation>
        <attribute name="name">
          <value>from_input_file</value>
        </attribute>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
      </element>
      <element name="dynamic_type">
        <a:documentation>Two python scripts must be provided. The script is cycled over each particle.
One script for particle position (output is tuple of position coords)
Second script is for particle radius (output is tuple of position coords)
Third script is for particle translational velocity.
Fourth script is for particle angular velocity. (Note: particles 
have a no slip boundary condition at the surface, so this angular velocity
WILL matter to the flow.)
Python functions should be of the form:
 def val(X, t):
   Function code
   return # Return value
where X is a tuple of length geometry dimension.
   X[0] contains the number of the particle (in real format)</a:documentation>
        <attribute name="name">
          <value>python_script</value>
        </attribute>
      </element>
      <element name="dynamic_type">
        <attribute name="name">
          <value>use_simple_dynamics</value>
        </attribute>
        <element name="set_bottom">
          <ref name="real"/>
        </element>
        <element name="set_xmin">
          <ref name="real"/>
        </element>
        <element name="set_ymin">
          <ref name="real"/>
        </element>
        <element name="set_zmin">
          <ref name="real"/>
        </element>
        <element name="set_xmax">
          <ref name="real"/>
        </element>
        <element name="set_ymax">
          <ref name="real"/>
        </element>
        <element name="set_zmax">
          <ref name="real"/>
        </element>
      </element>
      <element name="dynamic_type">
        <a:documentation>Using y3D to model dynamics. Filename of input file for y3D must
be specified.</a:documentation>
        <attribute name="name">
          <value>use_y3D</value>
        </attribute>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
      </element>
      <element name="dynamic_type">
        <a:documentation>Using femdem 2D to model dynamics. Filename of input file must
be specified.</a:documentation>
        <attribute name="name">
          <value>use_2Dfemdem</value>
        </attribute>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
      </element>
      <element name="dynamic_type">
        <a:documentation>Using femdem 3D to model dynamics. Filename of input file must
be specified.</a:documentation>
        <attribute name="name">
          <value>use_3Dfemdem</value>
        </attribute>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
        <element name="quad2lin">
          <attribute name="file_name">
            <data type="string"/>
          </attribute>
        </element>
      </element>
    </choice>
  </define>
  <define name="cap_option">
    <element name="cap_values">
      <a:documentation>Cap the min and max values of this field when using
it as a volume fraction to work out bulk material
properties.
No capping used if not selected.</a:documentation>
      <optional>
        <element name="upper_cap">
          <a:documentation>Set the upper bound on the field.
Defaults to huge(0.0)*epsilon(0.0) if not set.</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
      <optional>
        <element name="lower_cap">
          <a:documentation>Set the lower bound on the field.
Defaults to -huge(0.0)*epsilon(0.0) if not set.</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="surface_tension_option">
    <element name="surface_tension">
      <element name="surface_tension_coefficient">
        <a:documentation>Surface tension coefficient</a:documentation>
        <ref name="real"/>
      </element>
      <optional>
        <element name="equilibrium_contact_angle">
          <a:documentation>The equilibrium contact angle (in radians) with the boundaries identified by the surface ids</a:documentation>
          <ref name="real"/>
          <element name="surface_ids">
            <a:documentation>Surface ids:</a:documentation>
            <ref name="integer_vector"/>
          </element>
        </element>
      </optional>
    </element>
  </define>
  <define name="limiter_options">
    <element name="limit_face_value">
      <a:documentation>Limit the face value to satisfy a boundedness criterion.</a:documentation>
      <choice>
        <ref name="sweby_limiter"/>
        <ref name="ultimate_limiter"/>
      </choice>
    </element>
  </define>
  <define name="sweby_limiter">
    <element name="limiter">
      <a:documentation>See "High-Resolution Schemes Using Flux Limiters for
Hyperblic Conservation-Laws", P. K. Sweby, 1984, Siam
Journal on Numerical Analysis, 21, 995-1011</a:documentation>
      <attribute name="replaces">
        <value>MOD(INT(ABS(NDISOT)/1),10) = 2,3,4,5</value>
      </attribute>
      <attribute name="name">
        <value>Sweby</value>
      </attribute>
      <optional>
        <ref name="slope_options"/>
      </optional>
      <optional>
        <ref name="upwind_value_options"/>
      </optional>
    </element>
  </define>
  <define name="ultimate_limiter">
    <element name="limiter">
      <a:documentation>See "The Ultimate Conservative Difference Scheme Applied
to Unsteady One-Dimensional Advection", B. P. Leonard,
1991, Computer Methods in Applied Mechanics and
Engineering, 88, 17-74</a:documentation>
      <attribute name="name">
        <value>Ultimate</value>
      </attribute>
      <ref name="field_based_cfl_number_options"/>
      <optional>
        <ref name="upwind_value_options"/>
      </optional>
    </element>
  </define>
  <define name="slope_options">
    <element name="slopes">
      <a:documentation>Control the upper and lower slopes of the NVD limiter</a:documentation>
      <optional>
        <element name="lower">
          <a:documentation>Defaults to Sweby, 1984 limiter (= 1.0) if unselected</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
      <optional>
        <element name="upper">
          <a:documentation>Defaults to Sweby, 1984 limiter (= 2.0) if unselected</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="upwind_value_options">
    <choice>
      <element name="project_upwind_value_from_point">
        <a:documentation>Select the method to be used for calculating the upwind value.
If not selected will default to project_upwind_value_from_point for
simplex element meshes and to a locally_bound_upwind_value for cube
element meshes.

This method projects the upwind value from a point in the element just
upwind of the node pair straddling the face.  It is otherwise known as 
anisotropic limiting.
This is only available on simplex meshes as it involes a search around
the donor node to find the upwind element.</a:documentation>
        <attribute name="replaces">
          <value>NDISOT &gt; 0 on simplex meshes</value>
        </attribute>
        <optional>
          <element name="reflect_off_domain_boundaries">
            <a:documentation>When the donor node is on a domain boundary reflect the projection
back into the mesh.</a:documentation>
            <empty/>
          </element>
        </optional>
        <optional>
          <element name="bound_projected_value_locally">
            <a:documentation>Constrain the projected value to be between the min and max of the
element values which it was found from.</a:documentation>
            <empty/>
          </element>
        </optional>
        <optional>
          <element name="store_upwind_elements">
            <a:documentation>Store the locations of the elements where the upwind values
are projected from for each node pair.
This inserts an integer csr matrix into state so is memory expensive but
saves a significant amount of time (searching around the neighbouring elements).
This is unsafe for moving meshes but should be ok for adaptive meshes.</a:documentation>
            <attribute name="replaces">
              <value>ABS(NDISOT) &gt;= 1000</value>
            </attribute>
            <optional>
              <element name="store_upwind_quadrature">
                <a:documentation>Store the quadrature locations within the elements
where the upwind values
are projected from for each node pair.
This inserts a real block csr matrix into state so is even more memory
expensive than just storing the upwind elements and
only saves a comparitively
marginal amount of time (as actually searching the
neighbouring elements is the
slowest bit, finding the quadrature is relatively easy).</a:documentation>
                <attribute name="replaces">
                  <value>ABS(NDISOT) &gt;= 1000</value>
                </attribute>
                <empty/>
              </element>
            </optional>
          </element>
        </optional>
      </element>
      <element name="project_upwind_value_from_gradient">
        <a:documentation>Select the method to be used for calculating the upwind value.
If not selected will default to project_upwind_value_from_point for
simplex element meshes and to a locally_bound_upwind_value for cube
element meshes.

Projects the value of the advected variable from the downwind or donor node
using the interpolated gradient at the donor node in the
direction of the vector
connecting the node pair straddling the face.
This is available on all meshes (except if bounding the values).</a:documentation>
        <choice>
          <element name="project_from_downwind_value">
            <a:documentation>Select which node to project from:
Project from the downwind node (Jasak et al., 1999) so that:
upwind_value = downwind_value - 2*gradient.vector</a:documentation>
            <ref name="comment"/>
          </element>
          <element name="project_from_donor_value">
            <a:documentation>Select which node to project from:
Project from the donor node so that:
upwind_value = donor_value - gradient.vector</a:documentation>
            <ref name="comment"/>
          </element>
        </choice>
        <optional>
          <element name="reflect_off_domain_boundaries">
            <a:documentation>When the donor node is on a domain boundary reflect the projection
back into the mesh.</a:documentation>
            <empty/>
          </element>
        </optional>
        <optional>
          <element name="bound_projected_value_locally">
            <a:documentation>Constrain the projected value to be between the min and max of the
element values which surround it.
This is only available on simplex meshes as it involes a search around
the donor node to find the upwind element.</a:documentation>
            <optional>
              <element name="store_upwind_elements">
                <a:documentation>Store the locations of the elements closest to the project value.
This inserts an integer csr matrix into state so is
memory expensive but
saves a significant amount of time (searching around
the neighbouring elements).
This is unsafe for moving meshes but should be ok for adaptive meshes.</a:documentation>
                <ref name="comment"/>
              </element>
            </optional>
          </element>
        </optional>
      </element>
      <element name="locally_bound_upwind_value">
        <a:documentation>Select the method to be used for calculating the upwind value.
If not selected will default to project_upwind_value_from_point for
simplex element meshes and to a locally_bound_upwind_value for cube
element meshes.

Chooses an upwind value by selecting the maximum or minimum of the neighbouring
nodes depending on the local slope of the donor and downwind values.
Otherwise known as isotropic limiting.
This is available on all meshes.</a:documentation>
        <attribute name="replaces">
          <value>all cube elements, NDISOT &lt; 0 on simplex elements</value>
        </attribute>
        <empty/>
      </element>
      <element name="pseudo_structured_upwind_value">
        <a:documentation>Select the method to be used for calculating the upwind value.
If not selected will default to project_upwind_value_from_point for
simplex element meshes and to a locally_bound_upwind_value for cube
element meshes.

Chooses an upwind value by selecting the value at the node most directy
upwind from the vector connecting the donor and downwind nodes.
This is available on all meshes.</a:documentation>
        <empty/>
      </element>
    </choice>
  </define>
  <define name="field_based_cfl_number_options">
    <choice>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used.

This uses the control volume definition of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>ControlVolumeCFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>***UNDER TESTING***

Select the Courant Number definition to be used.

This uses the control volume definition of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>CVMaterialDensityCFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used.

This uses the finite element approximation of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>CFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used.</a:documentation>
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
        <empty/>
      </element>
    </choice>
  </define>
  <define name="cv_face_cfl_number_options">
    <choice>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used in the slope of
the NVD diagram upper bound.
This uses the finite difference definition of the CFL Number
consistent with the 1D version of HyperC (Leonard, 1981).
This is the default that reproduces old behaviour.
All others are under testing or construction.</a:documentation>
        <attribute name="name">
          <value>FiniteDifferenceCFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used in the slope of
the NVD diagram upper bound.
This uses the control volume definition of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>ControlVolumeCFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>***UNDER TESTING***

Select the Courant Number definition to be used in the slope of
the NVD diagram upper bound.
This uses a control volume definition of the CFL Number
that incorporates the MaterialDensity.
Requires a MaterialDensity field in this material_phase!</a:documentation>
        <attribute name="name">
          <value>CVMaterialDensityCFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>***UNDER TESTING***

Select the Courant Number definition to be used in the slope of
the NVD diagram upper bound.
This uses the finite element approximation of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>CFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>***UNDER TESTING***

Select the Courant Number definition to be used in the slope of
the NVD diagram upper bound.</a:documentation>
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
        <empty/>
      </element>
    </choice>
  </define>
  <define name="timestep_cfl_number_options">
    <choice>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used for adaptive timestepping.
This uses the finite element approximation of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>CFLNumber</value>
        </attribute>
        <ref name="velocity_mesh_choice">
          <a:documentation>Select the mesh on which you wish to evaluate the CFLNumber.</a:documentation>
        </ref>
      </element>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used for adaptive timestepping.
This uses the control volume definition of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>ControlVolumeCFLNumber</value>
        </attribute>
        <ref name="velocity_mesh_choice">
          <a:documentation>Select the mesh on which you wish to evaluate the ControlVolumeCFLNumber.</a:documentation>
        </ref>
      </element>
    </choice>
  </define>
  <define name="mixing_stats">
    <element name="include_mixing_stats">
      <a:documentation>Enable to include in the .stat file the fractions of the
scalar field contained in
bins specified by the user. This allows mixing of the field to be quantified.
Replaces and expands upon the old heaviside.dat file</a:documentation>
      <attribute name="name">
        <data type="string"/>
      </attribute>
      <attribute name="replaces">
        <value>heaviside.dat file</value>
      </attribute>
      <choice>
        <element name="continuous_galerkin">
          <a:documentation>Select whether to evaluate the volume fraction over the finite element
(continuous galerkin) or within the control volume (control_volumes).

NOTE: continuous_galerkin only works with linear tets

NOTE: continuous_galerkin is not fully validated yet</a:documentation>
          <optional>
            <element name="normalise">
              <a:documentation>if select normalise the volume fractions will be
divided by the total volume of the domain</a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
        <element name="control_volumes">
          <a:documentation>Select whether to evaluate the volume fraction over the finite element
(continuous galerkin) or within the control volume (control_volumes).</a:documentation>
          <optional>
            <element name="normalise">
              <a:documentation>if select normalise the volume fractions will be divided by the total volume of the domain  </a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
      </choice>
      <element name="mixing_bin_bounds">
        <a:documentation>The values of the bounds of the bins 
e.g. the values 0 1 2 3 will return 4 bins 
and the fraction of the field in each bin with,
0&lt;=field&lt;1, 1&lt;=field&lt;2, 2&lt;=field&lt;3, 3&lt;=field, 
will be calculated. </a:documentation>
        <ref name="real_vector"/>
      </element>
      <optional>
        <element name="tolerance">
          <a:documentation>Define the tolerance beneath the specified bins that should be included.
Defaults to zero at machine tolerance (epsilon(0.0)) if not selected.</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="cv_stats">
    <element name="include_cv_stats">
      <a:documentation>Include statistics evaluated on the control volume mesh.</a:documentation>
      <empty/>
    </element>
  </define>
  <!-- Options for inclusion of calculations of surface integrals in the .stat file   -->
  <define name="surface_integral_stats_base.surface_integral">
    <attribute name="name">
      <data type="string"/>
    </attribute>
    <optional>
      <element name="surface_ids">
        <a:documentation>Surface IDs defining the surface over which to integrate. If disabled, integrates over the whole surface.</a:documentation>
        <ref name="integer_vector"/>
      </element>
    </optional>
    <optional>
      <element name="normalise">
        <a:documentation>Enable to normalise the integral by dividing by the surface area</a:documentation>
        <ref name="comment"/>
      </element>
    </optional>
  </define>
  <define name="surface_integral_stats_scalar">
    <element name="surface_integral">
      <a:documentation>Surface integral calculations. The following integral types are available:
 value: Integrates the field
 gradient_normal: Integrates the normal component of the gradient of the field</a:documentation>
      <ref name="surface_integral_stats_scalar.surface_integral"/>
    </element>
  </define>
  <define name="surface_integral_stats_scalar.surface_integral">
    <ref name="surface_integral_stats_base.surface_integral"/>
  </define>
  <define name="surface_integral_stats_scalar.surface_integral" combine="interleave">
    <attribute name="type">
      <choice>
        <value>value</value>
        <value>gradient_normal</value>
      </choice>
    </attribute>
  </define>
  <define name="surface_integral_stats_vector">
    <element name="surface_integral">
      <a:documentation>Surface integral calculations. The following integral types are available:
 normal: Integrates the normal component of the field</a:documentation>
      <ref name="surface_integral_stats_vector.surface_integral"/>
    </element>
  </define>
  <define name="surface_integral_stats_vector.surface_integral">
    <ref name="surface_integral_stats_base.surface_integral"/>
  </define>
  <define name="surface_integral_stats_vector.surface_integral" combine="interleave">
    <attribute name="type">
      <value>normal</value>
    </attribute>
  </define>
  <define name="velocity_equation_choice">
    <element name="equation">
      <a:documentation>Select the equation used to solve for velocity.</a:documentation>
      <attribute name="name">
        <value>ShallowWater</value>
      </attribute>
    </element>
  </define>
  <define name="scalar_equation_choice">
    <choice>
      <element name="equation">
        <a:documentation>Select the equation used to solve for this field.
Advection Diffusion is the norm for scalar fields.
Works for all discretisation types.</a:documentation>
        <attribute name="name">
          <value>AdvectionDiffusion</value>
        </attribute>
      </element>
      <element name="equation">
        <a:documentation>***UNDER TESTING***

Select the equation used to solve for this field.
Conservation of Mass equation - requires the selection of a Density field.
ONLY WORKS FOR CONTROL VOLUME DISCRETISATIONS WITHOUT A
DIFFUSIVITY, SOURCE OR ABSORPTION.</a:documentation>
        <attribute name="name">
          <value>ConservationOfMass</value>
        </attribute>
        <choice>
          <element name="density">
            <a:documentation>Select density to use in the Conservation of Mass Equation
Use the MaterialDensity - useful for multimaterial simulations
Clearly this requires a MaterialDensity field to be present</a:documentation>
            <attribute name="name">
              <value>MaterialDensity</value>
            </attribute>
          </element>
          <element name="density">
            <a:documentation>Select density to use in the Conservation of Mass Equation
Use the bulk Density
Clearly this requires a Density field to be present</a:documentation>
            <attribute name="name">
              <value>Density</value>
            </attribute>
          </element>
          <element name="density">
            <a:documentation>Select density to use in the Conservation of Mass Equation</a:documentation>
            <attribute name="name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
          </element>
        </choice>
      </element>
      <element name="equation">
        <a:documentation>***UNDER TESTING***

Select the equation used to solve for this field.
Reduced Conservation of Mass equation - requires the selection of a Density field.

ONLY WORKS FOR CONTROL VOLUME DISCRETISATIONS WITHOUT A
DIFFUSIVITY, SOURCE OR ABSORPTION.

This equation is very similar to a standard conservation of mass equation
except that the time discretisation uses only a single time level of density.
This enables consistency between the
MaterialVolumeFraction (ReducedConservationOfMass) and
MaterialDensity (Advection) equations in compressible multimaterial simulations.</a:documentation>
        <attribute name="name">
          <value>ReducedConservationOfMass</value>
        </attribute>
        <choice>
          <element name="density">
            <a:documentation>Select density to use in the Reduced Conservation of Mass Equation
Use the MaterialDensity - useful for multimaterial simulations
Clearly this requires a MaterialDensity field to be present</a:documentation>
            <attribute name="name">
              <value>MaterialDensity</value>
            </attribute>
          </element>
          <element name="density">
            <a:documentation>Select density to use in the Reduced Conservation of Mass Equation
Use the bulk Density
Clearly this requires a Density field to be present</a:documentation>
            <attribute name="name">
              <value>Density</value>
            </attribute>
          </element>
          <element name="density">
            <a:documentation>Select density to use in the Reduced Conservation of Mass Equation</a:documentation>
            <attribute name="name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
          </element>
        </choice>
      </element>
      <element name="equation">
        <a:documentation>***UNDER TESTING***

Select the equation used to solve for this field.
Internal Energy equation - requires the selection of a Density field.
ONLY WORKS FOR CONTROL VOLUME DISCRETISATIONS WITHOUT A
DIFFUSIVITY, SOURCE OR ABSORPTION.
Solve the internal energy equation for this field.
Requires pressure and velocity fields to be present.
Uses a nonconservative time discretisation.</a:documentation>
        <attribute name="name">
          <value>InternalEnergy</value>
        </attribute>
        <choice>
          <element name="density">
            <a:documentation>Select density to use in the Internal Energy Equation
Use the MaterialDensity - useful for multimaterial simulations
Clearly this requires a MaterialDensity field to be present
Whatever field is selected must be present.</a:documentation>
            <attribute name="name">
              <value>MaterialDensity</value>
            </attribute>
          </element>
          <element name="density">
            <a:documentation>Select density to use in the Internal Energy Equation
Use the bulk Density
Clearly this requires a Density field to be present
Whatever field is selected must be present.</a:documentation>
            <attribute name="name">
              <value>Density</value>
            </attribute>
          </element>
          <element name="density">
            <a:documentation>Select density to use in the Internal Energy Equation
Whatever field is selected must be present.</a:documentation>
            <attribute name="name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
          </element>
        </choice>
      </element>
      <element name="equation">
        <a:documentation>Option to solve for electrical potential from
electrokinetic, electrochemical or electrothermal sources </a:documentation>
        <attribute name="name">
          <value>ElectricalPotential</value>
        </attribute>
      </element>
    </choice>
  </define>
  <define name="inner_element_scalar">
    <element name="inner_element">
      <a:documentation>Inner element sub-grid scale model (Candy and Pain)
Requires continuous galerkin selected above.</a:documentation>
      <attribute name="replaces">
        <value>NSUBTLOC, NSUBNTLOC</value>
      </attribute>
      <element name="scalar_field">
        <a:documentation>Inner element solution of the scalar field.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>InnerElement</value>
        </attribute>
        <element name="prognostic">
          <element name="mesh">
            <attribute name="name">
              <value>InnerElementMesh</value>
            </attribute>
          </element>
          <ref name="prognostic_scalar_output_options"/>
          <ref name="prognostic_scalar_stat_options"/>
          <ref name="prognostic_detector_options"/>
        </element>
      </element>
    </element>
  </define>
  <define name="inner_element_velocity">
    <optional>
      <element name="inner_element">
        <a:documentation>Inner element sub-grid scale model (Candy and Pain)
Requires continuous galerkin selected above.</a:documentation>
        <attribute name="replaces">
          <value>NSUBVLOC, NSUBNVLOC</value>
        </attribute>
        <element name="vector_field">
          <a:documentation>SGS velocity in an inner element SGS treatment of momentum

Limitations:
 - Requires a geometry dimension of 3.
 - Requires inner element active for momentum</a:documentation>
          <attribute name="rank">
            <value>1</value>
          </attribute>
          <attribute name="name">
            <value>InnerElement</value>
          </attribute>
          <element name="prognostic">
            <element name="mesh">
              <attribute name="name">
                <value>InnerElementMesh</value>
              </attribute>
            </element>
            <ref name="prognostic_vector_output_options"/>
            <ref name="prognostic_vector_stat_options"/>
            <ref name="vector_convergence_options"/>
          </element>
        </element>
        <optional>
          <element name="use_filter">
            <a:documentation>A filter for the sub-grid scale equations
Add diffusion to matrix D of the Inner Element model</a:documentation>
            <element name="strength">
              <a:documentation>Strength of the diffusion term
Suggested value: 0.01</a:documentation>
              <ref name="real"/>
            </element>
            <empty/>
          </element>
        </optional>
        <optional>
          <element name="use_quadratic_pressure">
            <attribute name="replaces">
              <value>PREOPT=PREOPT+1000</value>
            </attribute>
          </element>
        </optional>
        <optional>
          <element name="apply_full_discontinuous_Galerkin">
            <attribute name="replaces">
              <value>PREOPT=PREOPT+10000</value>
            </attribute>
          </element>
        </optional>
      </element>
    </optional>
  </define>
  <define name="forcing">
    <element name="ocean_forcing">
      <a:documentation>Add forcing from ocean data
If you enable this you MUST enable the /geometry/ocean_boundaries option too</a:documentation>
      <element name="input_file">
        <a:documentation>The netCDF data file downloaded from ERA-40 reanalysis</a:documentation>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
      </element>
      <element name="mesh_choice">
        <ref name="velocity_mesh_choice"/>
      </element>
      <optional>
        <element name="surface_stress">
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="temperature_flux">
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="salinity_flux">
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="solar_radiation">
          <empty/>
        </element>
      </optional>
    </element>
  </define>
  <define name="biology">
    <element name="ocean_biology">
      <a:documentation>Model of biological processes in the ocean.</a:documentation>
      <element name="pznd">
        <a:documentation>A simple model of phytoplankton, zooplankton, general nutrient and detritus. </a:documentation>
        <choice>
          <element name="source_and_sink_algorithm">
            <a:documentation>Python code specifying the source and sink relationships 
between the biological tracers. This is usually achieved by 
importing fluidity.ocean_biology and calling a scheme from there. </a:documentation>
            <ref name="python_code"/>
          </element>
          <element name="disable_sources_and_sinks">
            <a:documentation>Do not calculate sources and sinks. 
This option is generally only useful for testing. </a:documentation>
            <empty/>
          </element>
        </choice>
        <!--
                     ## Phytoplankton
                     element scalar_field {
                        attribute rank { "0" },
                        attribute name { "Phytoplankton" },
                        (
                           element prognostic {
                              velocity_mesh_choice,
                              prognostic_scalar_field
                           }|
                           element prescribed {
                              velocity_mesh_choice,
                              prescribed_scalar_field
                           }
                        )
                     },
                     ## Zooplankton
                     element scalar_field {
                        attribute rank { "0" },
                        attribute name { "Zooplankton" },
                        (
                           element prognostic {
                              velocity_mesh_choice,
                              prognostic_scalar_field
                           }|
                           element prescribed {
                              velocity_mesh_choice,
                              prescribed_scalar_field
                           }
                        )
                     },
                     ## Nutrient
                     element scalar_field {
                        attribute rank { "0" },
                        attribute name { "Nutrient" },
                        (
                           element prognostic {
                              velocity_mesh_choice,
                              prognostic_scalar_field
                           }|
                           element prescribed {
                              velocity_mesh_choice,
                              prescribed_scalar_field
                           }
                        )
                     },
                     ## Detritus
                     element scalar_field {
                        attribute rank { "0" },
                        attribute name { "Detritus" },
                        (
                           element prognostic {
                              velocity_mesh_choice,
                              prognostic_scalar_field
                           }|
                           element prescribed {
                              velocity_mesh_choice,
                              prescribed_scalar_field
                           }
                        )
                     },
        -->
        <element name="scalar_field">
          <a:documentation>Photosynthetically Active Radiation (PAR)</a:documentation>
          <attribute name="rank">
            <value>0</value>
          </attribute>
          <attribute name="name">
            <value>PhotosyntheticRadiation</value>
          </attribute>
          <choice>
            <element name="prognostic">
              <ref name="velocity_mesh_choice"/>
              <ref name="prognostic_photosynthetic_radiation"/>
            </element>
            <element name="prescribed">
              <ref name="velocity_mesh_choice"/>
              <ref name="prescribed_scalar_field"/>
            </element>
          </choice>
        </element>
      </element>
    </element>
  </define>
  <define name="prognostic_photosynthetic_radiation">
    <element name="equation">
      <a:documentation>PAR equation.</a:documentation>
      <attribute name="name">
        <value>PhotosyntheticRadiation</value>
      </attribute>
    </element>
    <element name="spatial_discretisation">
      <a:documentation>Spatial discretisation options</a:documentation>
      <element name="discontinuous_galerkin">
        <a:documentation>Discontinuous galerkin formulation. You can also use this
formulation with a continuous field in which case a simple
galerkin formulation will result. </a:documentation>
        <empty/>
      </element>
    </element>
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options_asym"/>
    </element>
    <element name="absorption_coefficients">
      <a:documentation>Coefficients of absorption of photosynthetically active
radiation for water and phytoplankton.</a:documentation>
      <element name="water">
        <a:documentation>Photosynthetically active radiation absorption coefficient for water.</a:documentation>
        <ref name="real"/>
      </element>
      <element name="phytoplankton">
        <a:documentation>Photosynthetically active radiation absorption coefficient for water.</a:documentation>
        <ref name="real"/>
      </element>
    </element>
    <oneOrMore>
      <element name="boundary_conditions">
        <a:documentation>Boundary conditions</a:documentation>
        <attribute name="replaces">
          <value>boundary, TTPER1 TTPER2 TTPERI</value>
        </attribute>
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
        <element name="surface_ids">
          <a:documentation>Surface id:</a:documentation>
          <ref name="integer_vector"/>
        </element>
        <choice>
          <a:documentation>Type</a:documentation>
          <element name="type">
            <attribute name="name">
              <value>dirichlet</value>
            </attribute>
            <element name="apply_weakly">
              <a:documentation>Apply the dirichlet bc weakly.  Only available with
discontinuous_galerkin, control_volume and
legacy_mixed_cv_cg spatial_discretisations.

If not selected boundary conditions are applied strongly.</a:documentation>
              <empty/>
            </element>
            <ref name="input_choice_real"/>
          </element>
          <element name="type">
            <attribute name="name">
              <value>neumann</value>
            </attribute>
            <ref name="input_choice_real"/>
          </element>
          <element name="type">
            <attribute name="name">
              <value>robin</value>
            </attribute>
            <element name="order_zero_coefficient">
              <ref name="input_choice_real"/>
            </element>
            <element name="order_one_coefficient">
              <ref name="input_choice_real"/>
            </element>
          </element>
        </choice>
      </element>
    </oneOrMore>
    <ref name="prognostic_scalar_output_options"/>
    <ref name="prognostic_scalar_stat_options"/>
    <ref name="scalar_convergence_options"/>
    <ref name="prognostic_detector_options"/>
    <ref name="scalar_steady_state_options"/>
    <ref name="adaptivity_options_scalar_field"/>
    <optional>
      <element name="priority">
        <a:documentation>Set the priority of this field
This determines the order in which scalar_fields are solved for:
 - higher numbers have the highest priority
 - lower numbers (including negative) have the lowest priority
 - default if not set is 0</a:documentation>
        <ref name="integer"/>
      </element>
    </optional>
  </define>
  <define name="recalculation_options">
    <element name="do_not_recalculate">
      <a:documentation>Prevent this field from being recalculated at every timestep.
This is cheaper especially if you are enforcing discrete properties on the field.</a:documentation>
      <empty/>
    </element>
  </define>
  <define name="discrete_properties_algorithm_scalar">
    <element name="enforce_discrete_properties">
      <a:documentation>Select discrete properties to enforce on the field
either after being prescribed or interpolated</a:documentation>
      <optional>
        <element name="solenoidal_lagrange_update">
          <a:documentation>Update this field using the lagrangian multiplier
calculated in the solenoidal projection of a
scalar field.

Note this field must be specified as the update field
underneath that vector field too.

Note also this only really makes sense for coupled
fields like velocity and pressure.</a:documentation>
          <empty/>
        </element>
      </optional>
    </element>
  </define>
  <define name="discrete_properties_algorithm_vector">
    <element name="enforce_discrete_properties">
      <a:documentation>Select discrete properties to enforce on the field
either after being prescribed or interpolated</a:documentation>
      <optional>
        <ref name="solenoidal_options"/>
      </optional>
    </element>
  </define>
  <define name="solenoidal_options">
    <element name="solenoidal">
      <a:documentation>Constrained divergence-free projection.
This adds an additional constraint that ensures that the field
is solenoidal, i.e. divergence-free.
This is equivalent in cost to a pressure solve.
This is expensive, and thus best left until
needed.

Note well: this only makes sense for nondivergent
vector fields, such as incompressible velocity!</a:documentation>
      <element name="interpolated_field">
        <a:documentation>Options for the mass matrix of the field being interpolated</a:documentation>
        <choice>
          <element name="continuous">
            <element name="lump_mass_matrix">
              <a:documentation>Lump the mass matrix for the assembly of the projection matrix
(not for the initial galerkin projection)

Required when using interpolating continuous fields</a:documentation>
              <optional>
                <element name="use_submesh">
                  <a:documentation>Lump on the submesh.
This only works for simplex meshes and is only
strictly valid on 2d meshes.</a:documentation>
                  <empty/>
                </element>
              </optional>
            </element>
          </element>
          <element name="discontinuous">
            <optional>
              <element name="lump_mass_matrix">
                <a:documentation>Lump the mass matrix for the assembly of the projection matrix
(not for the initial galerkin projection)</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
        </choice>
      </element>
      <element name="lagrange_multiplier">
        <a:documentation>Options for the lagrange multiplier

Must be on a continuous mesh!</a:documentation>
        <ref name="pressure_mesh_choice"/>
        <element name="spatial_discretisation">
          <choice>
            <element name="continuous_galerkin">
              <optional>
                <element name="remove_stabilisation_term">
                  <a:documentation>Remove the stabilisation term from the projection operator.

Automatic when not using P1P1.</a:documentation>
                  <empty/>
                </element>
              </optional>
              <optional>
                <element name="integrate_divergence_by_parts">
                  <a:documentation>Integrate the divergence operator by parts.

Automatic when projecting a discontinuous field</a:documentation>
                  <empty/>
                </element>
              </optional>
            </element>
            <element name="control_volumes">
              <empty/>
            </element>
          </choice>
        </element>
        <optional>
          <element name="reference_node">
            <ref name="integer"/>
          </element>
        </optional>
        <optional>
          <choice>
            <element name="update_scalar_field">
              <a:documentation>Update a scalar field using the lagrange multiplier from
the divergence free projection of this field.  The selected
scalar field must have solenoidal selected in its interpolation
options too and it must be on the same mesh as used for the
solenoidal projection above.

Note well: this only really makes sense for scalar fields linked to nondivergent
vector fields, such as pressure to incompressible velocity!                  </a:documentation>
              <attribute name="name">
                <value>Pressure</value>
              </attribute>
              <empty/>
            </element>
            <element name="update_scalar_field">
              <a:documentation>Update a scalar field using the lagrange multiplier from
the divergence free projection of this field.  The selected
scalar field must have solenoidal selected in its interpolation
options too and it must be on the same mesh as used for the
solenoidal projection above.

Note well: this only really makes sense for scalar fields linked to nondivergent
vector fields, such as pressure to incompressible velocity!                  </a:documentation>
              <attribute name="name">
                <data type="string" datatypeLibrary=""/>
              </attribute>
              <empty/>
            </element>
          </choice>
        </optional>
        <element name="solver">
          <a:documentation>Solver options for the linear solve.
This method requires the inversion of a projection matrix.</a:documentation>
          <ref name="linear_solver_options_sym"/>
        </element>
      </element>
    </element>
  </define>
  <define name="represcribe_before_interpolation">
    <element name="represcribe_before_interpolation">
      <a:documentation>Represcribe the field before interpolation.

This means the interpolation will not be conservative from the previous mesh so be careful what you're trying to achieve!</a:documentation>
      <empty/>
    </element>
  </define>
</grammar>
