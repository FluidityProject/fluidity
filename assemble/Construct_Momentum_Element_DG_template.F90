  subroutine WRAP_NAME(construct_momentum_element_dg)(ele, big_m, rhs, &
       &X, U, U_nl, U_mesh, X_old, X_new, Source, Buoyancy, hb_density, hb_pressure, gravity, Abs, &
       &Viscosity, swe_bottom_drag, swe_u_nl, P, old_pressure, Rho, surfacetension, q_mesh, &
       &velocity_bc, velocity_bc_type, &
       &pressure_bc, pressure_bc_type, &
       &turbine_conn_mesh, depth, have_wd_abs, alpha_u_field, Abs_wd, &
       &vvr_sf, ib_min_grad, nvfrac, &
       &inverse_mass, inverse_masslump, mass, subcycle_m, subcycle_rhs, partial_stress, &
       &smagorinsky_coefficient, eddy_visc, prescribed_filter_width, distance_to_wall, &
       &y_plus_debug, les_filter_width_debug)

    !!< Construct the momentum equation for discontinuous elements in
    !!< acceleration form.
    implicit none
    !! Index of current element
    integer :: ele
    !! Main momentum matrix.
    type(petsc_csr_matrix), intent(inout) :: big_m
    !! Momentum right hand side vector for each point.
    type(vector_field), intent(inout) :: rhs
    !! Auxiliary variable mesh
    type(mesh_type), intent(in) :: q_mesh
    type(mesh_type), intent(in) :: turbine_conn_mesh
    !! 
    type(block_csr_matrix), intent(inout), optional :: subcycle_m
    type(vector_field), intent(inout), optional :: subcycle_rhs

    !! Position, velocity and source fields.
    type(scalar_field), intent(in) :: buoyancy
    type(vector_field), intent(in) :: X, U, U_nl, Source, gravity, Abs
    type(vector_field), pointer :: U_mesh, X_old, X_new
    !! Viscosity
    type(tensor_field) :: Viscosity
    type(scalar_field) :: P, Rho
    type(scalar_field), intent(in) :: hb_density, hb_pressure
    !! surfacetension
    type(tensor_field) :: surfacetension
    !! field containing the bc values of velocity
    type(vector_field), intent(in) :: velocity_bc
    !! array of the type of bc (see get_entire_boundary_condition call above)
    integer, dimension(:,:), intent(in) :: velocity_bc_type
    !! same for pressure
    type(scalar_field), intent(in) :: pressure_bc
    integer, dimension(:), intent(in) :: pressure_bc_type
    !! fields only used for swe bottom drag (otherwise unitialised)
    type(scalar_field), intent(in) :: swe_bottom_drag, old_pressure
    type(vector_field), intent(in) :: swe_u_nl
    
    !! Inverse mass matrix
    type(block_csr_matrix), intent(inout), optional :: inverse_mass
    !! Mass lumping for each point
    type(vector_field), intent(inout), optional :: inverse_masslump
    !! Optional separate mass matrix.
    type(csr_matrix), intent(inout), optional :: mass
    logical, intent(in) :: have_wd_abs !! Wetting and drying switch, if TRUE, alpha_u_field must be passed as well
    type(scalar_field), intent(in) :: alpha_u_field
    type(vector_field), intent(in) :: Abs_wd
    
    ! Bilinear forms.
    real, dimension(NLOC(U,ele), NLOC(U,ele)) :: &
         Coriolis_mat, rho_mat, rho_move_mat, mass_mat
    real, dimension(NLOC(U,ele), NLOC(U,ele)) :: &
         inverse_mass_mat
    real, dimension(NDIM(X), NLOC(U,ele), &
         NLOC(U,ele)) :: ele2grad_mat
    real, dimension(NLOC(U,ele), NLOC(U,ele)) :: &
         Advection_mat
    real, dimension(NLOC(U,ele), NLOC(source,ele)) :: &
         Source_mat
    real, dimension(NDIM(U), NLOC(U,ele), NLOC(U,ele)) :: &
         Abs_mat
    real, dimension(NDIM(U), NDIM(U), NLOC(U,ele), NLOC(U,ele)) :: &
         Abs_mat_sphere
    real, dimension(NDIM(U), NLOC(U,ele)) :: &
         Abs_lump
        real, dimension(NDIM(U), NDIM(U), NLOC(U,ele)) :: &
         Abs_lump_sphere
    real, dimension(NLOC(U,ele)) :: &
         source_lump
    real, dimension(NLOC(q_mesh,ele), NLOC(q_mesh,ele)) :: Q_inv 
    real, dimension(NDIM(U), NLOC(q_mesh,ele), EFLOC(U,ele)) ::&
         & Grad_u_mat_q, Div_u_mat_q 
    real, dimension(NDIM(U),NDIM(U),EFLOC(U,ele),EFLOC(U,ele)) ::&
         & Viscosity_mat
    real, dimension(Viscosity%dim(1), Viscosity%dim(2), &
         & ele_loc(Viscosity,ele)) :: Viscosity_ele
    real, dimension(NDIM(X), NLOC_X) :: x_val, x_val_2
    real, dimension(NDIM(U), NLOC(U,ele)) :: u_val

     ! \Int_{ele} N_i kappa N_j dV, used for CDG fluxes
    real, dimension(NDIM(X),NDIM(X), &
         & NLOC(U,ele),NLOC(U,ele)) :: kappa_mat
   
    ! Local assembly matrices.
    real, dimension(NLOC(U,ele)) :: l_MassLump, l_move_masslump

    ! Local node number map for 2nd order element.
    integer, dimension(EFLOC(U,ele)) :: local_glno

    ! Local variables.
    
    ! Neighbour element, face, neighbour face, no. internal element nodes
    integer :: ele_2, ele_2_X, face, face_2
#ifdef GENERIC
    integer :: loc
#else
    integer, parameter :: loc = NLOC(U,ele)
#endif
    ! Count variable for loops over dimension.
    integer :: dim, dim1, dim2, dim3, dim4
    ! Loops over faces.
    integer :: ni
    ! Array bounds for faces of the 2nd order element.
    integer :: start, finish
    
    ! Variable transform times quadrature weights.
    real, dimension(NGI(U,ele)) :: detwei, detwei_old, detwei_new, coefficient_detwei
    ! Transformed gradient function for velocity.
    real, dimension(NLOC(U,ele), NGI(U,ele), NDIM(X)) :: du_t
    ! Transformed gradient function for grid velocity.
    real, dimension(NLOC_X, NGI(U,ele), NDIM(X)) :: dug_t
    ! Transformed gradient function for auxiliary variable. 
    real, dimension(NLOC(q_mesh,ele), NGI(q_mesh,ele), NDIM(X)) :: dq_t
    ! Density at quadrature points.
    real, dimension(NGI(U_nl, ele)) :: Rho_q
    ! Coriolis magnitude and sign at quadrature points.
    real, dimension(NGI(U_nl, ele)) :: Coriolis_q
    ! Different velocities at quad points.
    real, dimension(NDIM(U), NGI(U,ele)) :: u_nl_q
    real, dimension(NGI(U,ele)) :: u_nl_div_q

    ! surface tension terms
    real, dimension(NDIM(U), NDIM(U), NGI(U,ele)) :: tension
    real, dimension(NDIM(U), NGI(U,ele)) :: dtensiondj

    ! Node and shape pointers.
    integer, dimension(:), pointer :: u_ele, p_ele
    type(element_type), pointer :: u_shape, p_shape, q_shape
    ! Neighbours of this element.
    integer, dimension(:), pointer :: neigh, X_neigh
    ! Whether the velocity field is continuous and if it is piecewise constant.
    logical :: dg, p0
    integer :: i
    logical :: boundary_element, turbine_face

    ! What we will be adding to the matrix and RHS - assemble these as we
    ! go, so that we only do the calculations we really need
    real, dimension(NDIM(U), EFLOC(U,ele)) :: big_m_diag_addto,&
         & rhs_addto
    ! rhs terms for subcycling coming from advection bc terms
    real, dimension(NDIM(U), NLOC(U,ele)) :: subcycle_rhs_addto
    
    real, dimension(NDIM(U), NDIM(U), EFLOC(U,ele), EFLOC(U,ele)) :: big_m_tensor_addto
    logical, dimension(NDIM(U), NDIM(U)) :: diagonal_block_mask, off_diagonal_block_mask
    ! Addto matrices for when subcycling is performed
    real, dimension(NDIM(U), NDIM(U), EFLOC(U,ele), &
         EFLOC(U,ele)) :: subcycle_m_tensor_addto

    !Switch to select if we are assembling the primal or dual form
    logical :: primal

    ! In parallel, we assemble terms on elements we own, and those in
    ! the L1 element halo
    logical :: assemble_element

    ! Absorption matrices
    real, dimension(NDIM(U), NGI(U,ele)) :: absorption_gi
    real, dimension(NDIM(U), NDIM(U), NGI(U,ele)) :: tensor_absorption_gi

    ! Add vertical velocity relaxation to the absorption if present
    real, intent(in) :: vvr_sf
    real, dimension(NDIM(U),NDIM(U),NGI(U,ele)) :: vvr_abs
    real, dimension(NDIM(U),NGI(U,ele)) :: vvr_abs_diag
    real, dimension(NGI(U,ele)) :: depth_at_quads
    type(scalar_field), intent(in) :: depth

    ! Add implicit buoyancy to the absorption if present
    real, intent(in) :: ib_min_grad
    real, dimension(NDIM(U),NDIM(U),NGI(U,ele)) :: ib_abs
    real, dimension(NDIM(U),NGI(U,ele)) :: ib_abs_diag
    real, dimension(NLOC(U,ele),NGI(U,ele),MDIM(u)) :: dt_rho
    real, dimension(NDIM(U),NGI(U,ele)) :: grav_at_quads
    real, dimension(NDIM(U),NGI(U,ele)) :: grad_rho
    real, dimension(NGI(U,ele)) :: drho_dz

    ! Non-linear approximation to the PhaseVolumeFraction field
    type(scalar_field), intent(in) :: nvfrac
    type(element_type), pointer :: nvfrac_shape
    ! Transformed gradient function for the non-linear PhaseVolumeFraction. 
    real, dimension(:, :, :), allocatable :: dnvfrac_t
    ! nvfrac at quadrature points.
    real, dimension(NGI(U,ele)) :: nvfrac_gi, u_nl_dot_grad_nvfrac_gi
    real, dimension(NDIM(U), NGI(U,ele)) :: grad_nvfrac_gi

    ! element centre and neighbour centre
    ! for IP parameters

    real, dimension(NDIM(X)) :: ele_centre, neigh_centre, &
         & face_centre, face_centre_2
    real :: turbine_fluxfac

    real, dimension(NGI(U,ele)) :: alpha_u_quad

    ! added for partial stress form (sp911)
    logical, intent(in) :: partial_stress

    ! LES - sp911
    real, intent(in) :: smagorinsky_coefficient
    type(scalar_field), pointer, intent(inout) :: eddy_visc, y_plus_debug, &
         & les_filter_width_debug
    type(scalar_field), pointer, intent(in) :: prescribed_filter_width, distance_to_wall

    dg=continuity(U)<0
    p0=(element_degree(u,ele)==0)
    
    ! In parallel, we construct terms on elements we own and those in
    ! the L1 element halo.
    ! Note that element_neighbour_owned(U, ele) may return .false. if
    ! ele is owned.  For example, if ele is the only owned element on
    ! this process.  Hence we have to check for element ownership
    ! directly as well.
    assemble_element = .not.dg.or.element_neighbour_owned(U, ele).or.element_owned(U, ele)

    primal = .not.dg
    if(viscosity_scheme == CDG) primal = .true.
    if(viscosity_scheme == IP) primal =.true.
    
    if(p0) then
      assert(dg)
    end if
#ifdef GENERIC
    if(move_mesh) then
      !// In the declarations above we've assumed these
      !// so that U_mesh doesn't always have to be
      !// present
      assert(ele_loc(U_mesh, ele)==ele_loc(X, ele))
      assert(ele_ngi(U_mesh, ele)==ele_ngi(U, ele))
      assert(mesh_dim(U_mesh)==mesh_dim(U))
    end if
#endif

    big_m_diag_addto = 0.0
    big_m_tensor_addto = 0.0
    rhs_addto = 0.0
    if(subcycle) then
       subcycle_m_tensor_addto = 0.0
       subcycle_rhs_addto = 0.0
    end if
    
    diagonal_block_mask = .false.
    do dim = 1, NDIM(U)
      diagonal_block_mask(dim, dim) = .true.
    end do
    
    off_diagonal_block_mask = .not. diagonal_block_mask
    
    !----------------------------------------------------------------------
    ! Establish local node lists
    !----------------------------------------------------------------------

    u_ele=>ele_nodes(U,ele)  ! Velocity
    p_ele=>ele_nodes(P,ele)  ! Pressure

#ifdef GENERIC
    loc =ele_loc(u,ele)
#endif

    local_glno=0
    local_glno(:loc)=u_ele ! Viscosity node list

    !----------------------------------------------------------------------
    ! Establish local shape functions
    !----------------------------------------------------------------------

    u_shape=>ele_shape(U,ele)
    p_shape=>ele_shape(P,ele)
    q_shape=>ele_shape(q_mesh, ele)

    x_val = ele_val(X,ele)

    ! Transform U derivatives and weights into physical space.
    if(.not.p0) then
      call transform_to_physical(X, ele,&
          & u_shape , dshape=du_t, detwei=detwei)
    else
      call transform_to_physical(X, ele, &
          & detwei=detwei)
      du_t = 0.0
    end if
    
    if(move_mesh) then
      call transform_to_physical(X_old, ele, &
          & detwei=detwei_old)
      call transform_to_physical(X_new, ele, &
          & detwei=detwei_new)
      if(have_advection.and..not.integrate_by_parts_once) then
        call transform_to_physical(X, ele, &
            & ele_shape(U_mesh, ele), dshape = dug_t)
      end if
    end if

    if(have_viscosity.and.(.not.(q_mesh==u%mesh))) then
      ! Transform q derivatives into physical space.
      call transform_to_physical(X, ele,&
          & q_shape , dshape=dq_t)
    else
      dq_t=du_t
    end if
        
    !----------------------------------------------------------------------
    ! Construct element-wise quantities.
    !----------------------------------------------------------------------
    
    Rho_q=ele_val_at_quad(Rho, ele)

    if(multiphase) then
      allocate(dnvfrac_t(ele_loc(nvfrac%mesh,ele), NGI(nvfrac%mesh,ele), MDIM(u)))

      ! If the Velocity and PhaseVolumeFraction meshes are different, then we need to
      ! compute the derivatives of the PhaseVolumeFraction shape functions.
      if(.not.(nvfrac%mesh == u%mesh)) then
         nvfrac_shape => ele_shape(nvfrac%mesh, ele)
         call transform_to_physical(X, ele, nvfrac_shape, dshape=dnvfrac_t)
      else
         dnvfrac_t = du_t
      end if

      nvfrac_gi = ele_val_at_quad(nvfrac, ele)
      grad_nvfrac_gi = ele_grad_at_quad(nvfrac, ele, dnvfrac_t)

      deallocate(dnvfrac_t)
    end if

    if ((have_viscosity).and.assemble_element) then
      Viscosity_ele = ele_val(Viscosity,ele)
    end if
   
    if (assemble_element) then
       u_val = ele_val(u, ele)
    end if

    !----------------------------------------------------------------------
    ! Construct bilinear forms.
    !----------------------------------------------------------------------

    ! Element density matrix.
    ! (compute for first component only at first, others are copied
    !  when necessary)
    if (move_mesh) then
      ! this rho_mat (and l_masslump) is only used in the actual mass term in big_m
      ! (and its derivative inverse_mass or inverse_mass_lump)
      ! so should be evaluated at t+dt
      rho_mat = shape_shape(u_shape, u_shape, detwei_new*Rho_q)
    else

      if(multiphase) then
         rho_mat = shape_shape(u_shape, u_shape, detwei*Rho_q*nvfrac_gi)
      else
         rho_mat = shape_shape(u_shape, u_shape, detwei*Rho_q)
      end if

    end if
    l_masslump= sum(rho_mat,2)
    
    if(present(mass)) then
       !// Return mass separately.
       !// NOTE: this doesn't deal with mesh movement
       call addto(mass, u_ele, u_ele, Rho_mat)
    else
      if(have_mass.and.assemble_element) then
        if(lump_mass) then        
          do dim = 1, NDIM(U)
            big_m_diag_addto(dim, :loc) = big_m_diag_addto(dim, :loc) + l_masslump
          end do
        else
          do dim = 1, NDIM(U)
            big_m_tensor_addto(dim, dim, :loc, :loc) = big_m_tensor_addto(dim, dim, :loc, :loc) + rho_mat
          end do
        end if
      end if
      if (move_mesh.and.assemble_element) then
        ! In the unaccelerated form we solve:
        !  /
        !  |  N^{n+1} u^{n+1}/dt - N^{n} u^n/dt + ... = f
        !  /
        ! so in accelerated form:
        !  /
        !  |  N^{n+1} du + (N^{n+1}- N^{n}) u^n/dt + ... = f
        !  /
        ! where du=(u^{n+1}-u^{n})/dt is the acceleration.
        ! Put the (N^{n+1}-N^{n}) u^n term on the rhs
        rho_move_mat = shape_shape(u_shape, u_shape, (detwei_new-detwei_old)*Rho_q)
        if(lump_mass) then
          l_move_masslump= sum(rho_move_mat,2)
          do dim = 1, NDIM(U)
            rhs_addto(dim,:loc) = rhs_addto(dim,:loc) - l_move_masslump*u_val(dim,:)/dt
          end do
        else
          do dim = 1, NDIM(U)
            rhs_addto(dim,:loc) = rhs_addto(dim,:loc) - matmul(rho_move_mat, u_val(dim,:))/dt
          end do
        end if
      end if
    end if
    
    if(have_coriolis.and.(rhs%dim>1).and.assemble_element) then
      Coriolis_q=coriolis(ele_val_at_quad(X,ele))
    
      ! Element Coriolis parameter matrix.
      Coriolis_mat = shape_shape(u_shape, u_shape, Rho_q*Coriolis_q*detwei)

      ! cross terms in U_ and V_ for coriolis
      big_m_tensor_addto(U_, V_, :loc, :loc) = big_m_tensor_addto(U_, V_, :loc, :loc) - dt*theta*coriolis_mat
      big_m_tensor_addto(V_, U_, :loc, :loc) = big_m_tensor_addto(V_, U_, :loc, :loc) + dt*theta*coriolis_mat

      rhs_addto(U_, :loc) = rhs_addto(U_, :loc) + matmul(coriolis_mat, u_val(V_,:))
      rhs_addto(V_, :loc) = rhs_addto(V_, :loc) - matmul(coriolis_mat, u_val(U_,:))
    end if

    if(have_advection.and.(.not.p0).and.assemble_element) then
      ! Advecting velocity at quadrature points.
      U_nl_q=ele_val_at_quad(U_nl,ele)

      if(integrate_conservation_term_by_parts) then
      
        if(multiphase) then
           ! Element advection matrix
           !         /                                                /
           !  - beta | (grad T dot U_nl) T Rho vfrac dV + (1. - beta) | T (vfrac U_nl dot grad T) Rho dV
           !         /                                                /
           Advection_mat = -beta*dshape_dot_vector_shape(du_t, U_nl_q, u_shape, detwei*Rho_q*nvfrac_gi) &
               + (1.-beta)*shape_vector_dot_dshape(u_shape, U_nl_q, du_t, detwei*Rho_q*nvfrac_gi)
        else
           ! Element advection matrix
           !         /                                          /
           !  - beta | (grad T dot U_nl) T Rho dV + (1. - beta) | T (U_nl dot grad T) Rho dV
           !         /                                          /
           Advection_mat = -beta*dshape_dot_vector_shape(du_t, U_nl_q, u_shape, detwei*Rho_q) &
               + (1.-beta)*shape_vector_dot_dshape(u_shape, U_nl_q, du_t, detwei*Rho_q)
        end if
        
        if(move_mesh) then
          if(integrate_by_parts_once) then
            Advection_mat = Advection_mat &
                            + dshape_dot_vector_shape(du_t, ele_val_at_quad(U_mesh,ele), u_shape, detwei * Rho_q)
          else
            Advection_mat = Advection_mat &
                            - shape_vector_dot_dshape(u_shape, ele_val_at_quad(U_mesh,ele), du_t, detwei * Rho_q) &
                            - shape_shape(u_shape, u_shape, ele_div_at_quad(U_mesh, ele, dug_t) * detwei * Rho_q)
          end if
        end if
      else
        ! Introduce grid velocities
        if (move_mesh) then
          ! NOTE: this modifies the velocities stored at the gauss pts.
          U_nl_q = U_nl_q - ele_val_at_quad(U_mesh, ele)
        end if
        U_nl_div_q=ele_div_at_quad(U_nl, ele, du_t)

        if(integrate_by_parts_once) then
        
          if(multiphase) then
             ! Element advection matrix
             !    /                                                /
             !  - | (grad T dot U_nl vfrac) T Rho dV - (1. - beta) | T ( div(U_nl vfrac) ) T Rho dV
             !    /                                                /
            
             ! We need to compute \int{T div(u_nl vfrac) T},
             ! so split up the div using the product rule and compute
             ! \int{T vfrac div(u_nl) T} + \int{T u_nl grad(vfrac) T}
             do i = 1, NGI(u, ele)
                u_nl_dot_grad_nvfrac_gi(i) = dot_product(U_nl_q(:,i), grad_nvfrac_gi(:,i))
             end do
             Advection_mat = -dshape_dot_vector_shape(du_t, U_nl_q, u_shape, detwei*Rho_q*nvfrac_gi) &
                 - (1.-beta) * (shape_shape(u_shape, u_shape, U_nl_div_q*detwei*Rho_q*nvfrac_gi) + &
                 shape_shape(u_shape, u_shape, detwei*Rho_q*u_nl_dot_grad_nvfrac_gi))
          else
             ! Element advection matrix
             !    /                                          /
             !  - | (grad T dot U_nl) T Rho dV - (1. - beta) | T ( div U_nl ) T Rho dV
             !    /                                          /
             Advection_mat = - dshape_dot_vector_shape(du_t, U_nl_q, u_shape, detwei*Rho_q) &
                 - (1.-beta) * shape_shape(u_shape, u_shape, U_nl_div_q*detwei*Rho_q)
          end if
          
        else
       
          if(multiphase) then
             ! Element advection matrix
             !  /                                         /
             !  | T (vfrac U_nl dot grad T) Rho dV + beta | T ( div (vfrac U_nl) ) T Rho dV
             !  /                                         /
             
             ! We need to compute \int{T div(vfrac u_nl) T},
             ! so split up the div using the product rule and compute
             ! \int{T vfrac div(u_nl) T} + \int{T u_nl grad(vfrac) T}
             do i = 1, NGI(u, ele)
                u_nl_dot_grad_nvfrac_gi(i) = dot_product(U_nl_q(:,i), grad_nvfrac_gi(:,i))
             end do
             Advection_mat = shape_vector_dot_dshape(u_shape, U_nl_q, du_t, detwei*Rho_q*nvfrac_gi) &
                 + beta * (shape_shape(u_shape, u_shape, U_nl_div_q*detwei*Rho_q*nvfrac_gi) + &
                 shape_shape(u_shape, u_shape, detwei*Rho_q*u_nl_dot_grad_nvfrac_gi))
          else
             ! Element advection matrix
             !  /                                   /
             !  | T (U_nl dot grad T) Rho dV + beta | T ( div U_nl ) T Rho dV
             !  /                                   /
             Advection_mat = shape_vector_dot_dshape(u_shape, U_nl_q, du_t, detwei*Rho_q) &
                 + beta * shape_shape(u_shape, u_shape, U_nl_div_q * detwei*Rho_q)
          end if 
          
          if(move_mesh) then
            Advection_mat = Advection_mat &
                  - shape_shape(u_shape, u_shape, ele_div_at_quad(U_mesh, ele, dug_t) * detwei * Rho_q)
          end if
        end if
      end if
      
      do dim = 1, NDIM(U)
         if(subcycle) then
            subcycle_m_tensor_addto(dim, dim, :loc, :loc) &
                 &= subcycle_m_tensor_addto(dim, dim, :loc, :loc) &
                 &+ advection_mat
         else
            big_m_tensor_addto(dim, dim, :loc, :loc) &
                 &= big_m_tensor_addto(dim, dim, :loc, :loc) &
                 &+ dt*theta*advection_mat
            rhs_addto(dim, :loc) = rhs_addto(dim, :loc) &
                 &- matmul(advection_mat, u_val(dim,:))
         end if
      end do

    end if

    if(have_source .and. assemble_element) then
      ! Momentum source matrix.
      Source_mat = shape_shape(U_shape, ele_shape(Source,ele), detwei*Rho_q)
      if(lump_source) then
        source_lump = sum(source_mat, 2)
        do dim = 1, NDIM(U)
          ! lumped source
          rhs_addto(dim, :loc) = rhs_addto(dim, :loc) + source_lump*(ele_val(source, dim, ele))
        end do
      else
        do dim = 1, NDIM(U)
          ! nonlumped source
          rhs_addto(dim, :loc) = rhs_addto(dim, :loc) + matmul(source_mat, ele_val(source, dim, ele))
        end do
      end if
    end if

    if(have_gravity .and. assemble_element) then
      ! buoyancy
      if(subtract_out_reference_profile) then
         coefficient_detwei = detwei*gravity_magnitude*(ele_val_at_quad(buoyancy, ele)-ele_val_at_quad(hb_density, ele))
      else
         coefficient_detwei = detwei*gravity_magnitude*ele_val_at_quad(buoyancy, ele)
      end if

      if (radial_gravity) then
      !// If we're using a radial gravity, evaluate the direction of the gravity vector
      !// exactly at quadrature points.
        rhs_addto(:, :loc) = rhs_addto(:, :loc) + shape_vector_rhs(u_shape, &
                                    radial_inward_normal_at_quad_ele(X, ele), &
                                    coefficient_detwei)
      else
      
        if(multiphase) then
          rhs_addto(:, :loc) = rhs_addto(:, :loc) + shape_vector_rhs(u_shape, &
                                    ele_val_at_quad(gravity, ele), &
                                    coefficient_detwei*nvfrac_gi)
        else
          rhs_addto(:, :loc) = rhs_addto(:, :loc) + shape_vector_rhs(u_shape, &
                                    ele_val_at_quad(gravity, ele), &
                                    coefficient_detwei)
        end if
        
      end if
    end if

    if((have_absorption.or.have_vertical_stabilization.or.have_wd_abs .or. have_swe_bottom_drag) .and. &
         (assemble_element .or. pressure_corrected_absorption)) then

      absorption_gi=0.0
      tensor_absorption_gi=0.0
      absorption_gi = ele_val_at_quad(Abs, ele)
      if (on_sphere.and.have_absorption) then ! Rotate the absorption
        tensor_absorption_gi=rotate_diagonal_to_sphere_gi(X, ele, absorption_gi)
      end if

      vvr_abs_diag=0.0
      vvr_abs=0.0
      ib_abs=0.0
      ib_abs_diag=0.0

      if (have_vertical_velocity_relaxation) then
                
        ! Form the vertical velocity relaxation absorption term
        if (.not.on_sphere) then
          grav_at_quads=ele_val_at_quad(gravity, ele)
        end if
        depth_at_quads=ele_val_at_quad(depth, ele)

        if (on_sphere) then
          do i=1,NGI(U,ele)
            vvr_abs_diag(3,i)=-vvr_sf*gravity_magnitude*dt*rho_q(i)/depth_at_quads(i)
          end do
          vvr_abs=rotate_diagonal_to_sphere_gi(X, ele, vvr_abs_diag)
        else
          do i=1,NGI(u,ele)
            vvr_abs_diag(:,i)=vvr_sf*gravity_magnitude*dt*grav_at_quads(:,i)*rho_q(i)/depth_at_quads(i)
          end do
        end if

      end if

      if (have_implicit_buoyancy) then

        call transform_to_physical(X, ele, ele_shape(buoyancy,ele), dshape=dt_rho)
        grad_rho=ele_grad_at_quad(buoyancy, ele, dt_rho)

        ! Calculate the gradient in the direction of gravity
        if (on_sphere) then
          grav_at_quads=radial_inward_normal_at_quad_ele(X, ele)
        else
          grav_at_quads=ele_val_at_quad(gravity, ele)
        end if

        do i=1,NGI(U,ele)
          drho_dz(i)=dot_product(grad_rho(:,i),grav_at_quads(:,i)) ! Divide this by rho_0 for non-Boussinesq?
          if (drho_dz(i) < ib_min_grad) drho_dz(i)=ib_min_grad ! Default ib_min_grad=0.0
        end do

        ! Form the implicit buoyancy absorption terms
        if (on_sphere) then
          do i=1,NGI(U,ele)
            ib_abs_diag(3,i)=-theta*dt*gravity_magnitude*drho_dz(i)
          end do
          ib_abs=rotate_diagonal_to_sphere_gi(X, ele, ib_abs_diag)
        else
          do i=1,NGI(U,ele)
              ib_abs_diag(:,i)=theta*dt*gravity_magnitude*drho_dz(i)*grav_at_quads(:,i)
          end do
        end if
     
      end if

      ! Add any vertical stabilization to the absorption term
      if (on_sphere) then
        tensor_absorption_gi=tensor_absorption_gi-vvr_abs-ib_abs
        absorption_gi=absorption_gi-vvr_abs_diag-ib_abs_diag
      else
        absorption_gi=absorption_gi-vvr_abs_diag-ib_abs_diag
      end if

      if (have_swe_bottom_drag) then
        ! first compute total water depth H
        depth_at_quads = ele_val_at_quad(depth, ele) + (theta_nl*ele_val_at_quad(p, ele) + (1.0-theta_nl)*ele_val_at_quad(old_pressure, ele))/gravity_magnitude
        ! now reuse depth_at_quads to be the absorption coefficient: C_D*|u|/H
        depth_at_quads = (ele_val_at_quad(swe_bottom_drag, ele)*sqrt(sum(ele_val_at_quad(swe_u_nl, ele)**2, dim=1)))/depth_at_quads
        do i=1, NDIM(U)
          absorption_gi(i,:) = absorption_gi(i,:) + depth_at_quads
        end do
      
      end if

      ! If on the sphere then use 'tensor' absorption. Note that using tensor absorption means that, currently,
      ! the absorption cannot be used in the pressure correction. 
      if (on_sphere) then

        Abs_mat_sphere = shape_shape_tensor(U_shape, U_shape, detwei*rho_q, tensor_absorption_gi)
        Abs_mat = shape_shape_vector(U_shape, U_shape, detwei*rho_q, absorption_gi)
        if (have_wd_abs) then
               FLExit("Wetting and drying absorption does currently not work on the sphere.")
        end if

        if(lump_abs) then

          Abs_lump_sphere = sum(Abs_mat_sphere, 4)
          if (assemble_element) then
            do dim = 1, NDIM(U)
              do dim2 = 1, NDIM(U)
                do i = 1, NLOC(U,ele)
                  big_m_tensor_addto(dim, dim2, i, i) = big_m_tensor_addto(dim, dim2, i, i) + &
                    & dt*theta*Abs_lump_sphere(dim,dim2,i)
                end do
              end do
              rhs_addto(dim, :loc) = rhs_addto(dim, :loc) - Abs_lump_sphere(dim,dim,:)*u_val(dim,:)
              ! off block diagonal absorption terms
              do dim2 = 1, NDIM(U)
                if (dim==dim2) cycle ! The dim=dim2 terms were done above
                rhs_addto(dim, :loc) = rhs_addto(dim, :loc) - Abs_lump_sphere(dim,dim2,:)*u_val(dim2,:)
              end do
            end do
          end if
          if (present(inverse_masslump) .and. pressure_corrected_absorption) then
            assert(lump_mass)
            abs_lump = sum(Abs_mat, 3)
            do dim = 1, NDIM(U)             
              if(have_mass) then
                call set( inverse_masslump, dim, u_ele, &
                  1.0/(l_masslump+dt*theta*abs_lump(dim,:)) )
              else
                call set( inverse_masslump, dim, u_ele, &
                  1.0/(dt*theta*abs_lump(dim,:)) )            
              end if
            end do          
          end if    

        else

          if (assemble_element) then
            do dim = 1, NDIM(U)
              do dim2 = 1, NDIM(U)
                big_m_tensor_addto(dim, dim2, :loc, :loc) = big_m_tensor_addto(dim, dim2, :loc, :loc) + &
                  & dt*theta*Abs_mat_sphere(dim,dim2,:,:)
              end do
              rhs_addto(dim, :loc) = rhs_addto(dim, :loc) - matmul(Abs_mat_sphere(dim,dim,:,:), u_val(dim,:))
              ! off block diagonal absorption terms
              do dim2 = 1, NDIM(U)
                if (dim==dim2) cycle ! The dim=dim2 terms were done above
                rhs_addto(dim, :loc) = rhs_addto(dim, :loc) - matmul(Abs_mat_sphere(dim,dim2,:,:), u_val(dim2,:))
              end do
            end do
          end if
          Abs_lump_sphere = 0.0
          if (present(inverse_mass) .and. pressure_corrected_absorption) then
            assert(.not. lump_mass)
            do dim = 1, NDIM(U)              
              if(have_mass) then
                call set(inverse_mass, dim, dim, u_ele, u_ele, &
                  inverse(rho_mat + dt*theta*Abs_mat(dim,:,:)))
              else
                call set(inverse_mass, dim, dim, u_ele, u_ele, &
                  inverse(dt*theta*Abs_mat(dim,:,:)))            
              end if
            end do
          end if     

        end if

      else

        Abs_mat = shape_shape_vector(U_shape, U_shape, detwei*rho_q, absorption_gi)

        if (have_wd_abs) then
          alpha_u_quad=ele_val_at_quad(alpha_u_field, ele)  !! Wetting and drying absorption becomes active when water level reaches d_0
          Abs_mat = Abs_mat + shape_shape_vector(U_shape, U_shape, alpha_u_quad*detwei*rho_q, &
            &                                 ele_val_at_quad(Abs_wd,ele))
        end if

        if(lump_abs) then        
          abs_lump = sum(Abs_mat, 3)
          do dim = 1, NDIM(U)
            if (assemble_element) then
              big_m_diag_addto(dim, :loc) = big_m_diag_addto(dim, :loc) + dt*theta*abs_lump(dim,:)
              rhs_addto(dim, :loc) = rhs_addto(dim, :loc) - abs_lump(dim,:)*u_val(dim,:)
            end if
            if (present(inverse_masslump) .and. pressure_corrected_absorption) then
              assert(lump_mass)
              if(have_mass) then
                call set( inverse_masslump, dim, u_ele, &
                  1.0/(l_masslump+dt*theta*abs_lump(dim,:)) )
              else
                call set( inverse_masslump, dim, u_ele, &
                  1.0/(dt*theta*abs_lump(dim,:)) )            
              end if
            end if          
          end do

        else
      
          do dim = 1, NDIM(U)
            if (assemble_element) then
              big_m_tensor_addto(dim, dim, :loc, :loc) = big_m_tensor_addto(dim, dim, :loc, :loc) + &
                & dt*theta*Abs_mat(dim,:,:)
              rhs_addto(dim, :loc) = rhs_addto(dim, :loc) - matmul(Abs_mat(dim,:,:), u_val(dim,:))
            end if
            if (present(inverse_mass) .and. pressure_corrected_absorption) then
              assert(.not. lump_mass)
              if(have_mass) then
                call set(inverse_mass, dim, dim, u_ele, u_ele, &
                  inverse(rho_mat + dt*theta*Abs_mat(dim,:,:)))
              else
                call set(inverse_mass, dim, dim, u_ele, u_ele, &
                  inverse(dt*theta*Abs_mat(dim,:,:)))            
              end if
            end if
          end do       

        end if

      end if

    end if
      
    if ((((.not.have_absorption).and.(.not.have_vertical_stabilization).and.(.not.have_wd_abs)) .or. (.not.pressure_corrected_absorption)).and.(have_mass)) then
      ! no absorption: all mass matrix components are the same
      if (present(inverse_mass) .and. .not. lump_mass) then
        inverse_mass_mat=inverse(rho_mat)
        call set(inverse_mass, 1, 1, u_ele, u_ele, inverse_mass_mat)
        if (.not. inverse_mass%equal_diagonal_blocks) then
          ! after the strong dirichlet bcs have been applied, the diagonal 
          ! blocks will be different. So for now we just copy:
          do dim = 2, NDIM(U)
            call set(inverse_mass, dim, dim, u_ele, u_ele, inverse_mass_mat)
          end do
        end if
      end if
      if (present(inverse_masslump) .and. lump_mass) then
        do dim = 1, NDIM(U)
          call set(inverse_masslump, dim, u_ele, 1.0/l_masslump)
        end do
      end if
      
    end if
    
    ! Viscosity.
    Viscosity_mat=0
    if(have_viscosity.and.assemble_element) then
       if (primal) then
          do dim = 1, NDIM(U)
             if(multiphase) then
               ! Viscosity matrix is \int{grad(N_A)*viscosity*vfrac*grad(N_B)} for multiphase.
               Viscosity_mat(dim,dim,:loc,:loc) = &
                    dshape_tensor_dshape(du_t, ele_val_at_quad(Viscosity,ele), &
                    &                    du_t, detwei*nvfrac_gi)
             else
               Viscosity_mat(dim,dim,:loc,:loc) = &
                    dshape_tensor_dshape(du_t, ele_val_at_quad(Viscosity,ele), &
                    &                    du_t, detwei)
             end if
          end do

          if((viscosity_scheme==CDG).or.(viscosity_scheme==IP)) then
             !Compute a matrix which maps ele vals to ele grad vals
             !This works since the gradient of the shape function
             !lives in the original polynomial space -- cjc
             Mass_mat = shape_shape(u_shape, u_shape, detwei)
             inverse_mass_mat = mass_mat
             call invert(inverse_mass_mat)
             ele2grad_mat = shape_dshape(u_shape,du_t,detwei)
             do i = 1, MDIM(U)
                ele2grad_mat(i,:,:) = matmul(inverse_mass_mat, &
                     ele2grad_mat(i,:,:))
             end do

          end if

         ! Get kappa mat for CDG
          if(viscosity_scheme==CDG) then
             if(multiphase) then
               ! kappa = mu*vfrac for multiphase
               kappa_mat = shape_shape_tensor(u_shape,u_shape,detwei*nvfrac_gi, &
                     & ele_val_at_quad(Viscosity,ele))
             else
               kappa_mat = shape_shape_tensor(u_shape,u_shape,detwei, &
                     & ele_val_at_quad(Viscosity,ele))
             end if
          end if

       else
          ! Tau Q = grad(u)
          if(multiphase) then
            ! We define the auxiliary variable as vfrac*q = vfrac*div(u)
            ! to obtain the correct form of the grad_u_mat_q matrix. This way,
            ! transpose(grad_u_mat_q) gives the correct form of the viscosity term.
            Q_inv= shape_shape(q_shape, q_shape, detwei*nvfrac_gi)
          else
            Q_inv= shape_shape(q_shape, q_shape, detwei)
          end if

          call invert(Q_inv)
          call cholesky_factor(Q_inv)
          
          Grad_U_mat_q=0.0
          Div_U_mat_q=0.0
          if(.not.p0) then
             
             if(multiphase) then
               ! Split up -\int{grad(N_A vfrac) N_B} using the product rule
               ! and compute -\int{grad(N_A) vfrac N_B} - \int{N_A grad(vfrac) N_B}
               Grad_U_mat_q(:, :, :loc) = -dshape_shape(dq_t, u_shape, detwei*nvfrac_gi) - &
                                          & shape_shape_vector(q_shape, u_shape, detwei, grad_nvfrac_gi)
             else
               Grad_U_mat_q(:, :, :loc) = -dshape_shape(dq_t, u_shape, detwei)
             end if
 
             if(viscosity_scheme==ARBITRARY_UPWIND) then
               Div_U_mat_q(:, :, :loc) = -shape_dshape(q_shape, du_t, detwei)
             end if

          end if
       end if
    end if

    if(have_surfacetension.and.(.not.p0).and.assemble_element) then
      if(integrate_surfacetension_by_parts) then
        tension = ele_val_at_quad(surfacetension, ele)
        
        rhs_addto(:,:loc) = rhs_addto(:,:loc) - &
             &dshape_dot_tensor_rhs(du_t, tension, detwei)
      else
        dtensiondj = ele_div_at_quad_tensor(surfacetension, ele, du_t)
        
        rhs_addto(:,:loc) = rhs_addto(:,:loc) + &
             & shape_vector_rhs(u_shape,dtensiondj,detwei)
      end if
    end if

    !-------------------------------------------------------------------
    ! Interface integrals
    !-------------------------------------------------------------------
    
    if(dg.and.(have_viscosity.or.have_advection.or.have_pressure_bc).and.assemble_element) then
      neigh=>ele_neigh(U, ele)
      ! x_neigh/=t_neigh only on periodic boundaries.
      x_neigh=>ele_neigh(X, ele)
      
      ! Local node map counter.
      start=loc+1
      ! Flag for whether this is a boundary element.
      boundary_element=.false.
      
      neighbourloop: do ni=1,size(neigh)
        
        !----------------------------------------------------------------------
        ! Find the relevant faces.
        !----------------------------------------------------------------------
        turbine_face=.false.
        ! These finding routines are outside the inner loop so as to allow
        ! for local stack variables of the right size in
        ! construct_momentum_interface_dg.
  
        ele_2=neigh(ni)
        
        ! Note that although face is calculated on field U, it is in fact
        ! applicable to any field which shares the same mesh topology.
        face=ele_face(U, ele, ele_2)
      
        if (ele_2>0) then
            ! Internal faces.
            face_2=ele_face(U, ele_2, ele)
        ! Check if face is turbine face (note: get_entire_boundary_condition only returns "applied" boundaries and we reset the apply status in each timestep)
        elseif (velocity_bc_type(1,face)==4 .or. velocity_bc_type(1,face)==5) then
           face_2=face_neigh(turbine_conn_mesh, face)
           turbine_face=.true.
        else 
           ! External face.
           face_2=face
           boundary_element=.true.
        end if

        !Compute distance between cell centre and neighbouring cell centre
        !This is for Interior Penalty Method -- cjc
        !--------------
        if(dg.and.viscosity_scheme==IP) then
           if(edge_length_option==USE_ELEMENT_CENTRES) then
              ele_2_X = x_neigh(ni)
              ele_centre = sum(X_val,2)/size(X_val,2)
              face_centre = sum(face_val(X,face),2)/size(face_val(X,face),2)
              if(face==face_2) then
                 ! Boundary case. We compute 2x the distance to the face centre
                 h0 = 2*sqrt( sum(ele_centre - face_centre)**2 )
              else if (ele_2/=x_neigh(ni)) then
                 ! Periodic boundary case. We have to cook up the coordinate by
                 ! adding vectors to the face from each side.
                 x_val_2 = ele_val(X,ele_2_X)
                 neigh_centre = sum(X_val_2,2)/size(X_val_2,2)
                 face_centre_2 = &
                      sum(face_val(X,face_2),2)/size(face_val(X,face_2),2)
                 h0 = sqrt ( sum(ele_centre - face_centre)**2 )
                 h0 = h0 + sqrt( sum(neigh_centre - face_centre_2)**2 )
              else
                 x_val_2 = ele_val(X,ele_2_X)
                 neigh_centre = sum(X_val_2,2)/size(X_val_2,2)
                 h0 = sqrt ( sum(ele_centre - neigh_centre)**2 )
              end if
           end if
        end if
        !--------------

        if (dg) then
            finish=start+FLOC(U, face_2)-1
  
            local_glno(start:finish)=face_global_nodes(U, face_2)
        end if
  
        ! Turbine face
        if (turbine_face) then
           call construct_turbine_interface(turbine_fluxfac, theta, dt, ele, face, face_2, ni, &
                    & big_m_tensor_addto, rhs_addto, X, U, velocity_bc, velocity_bc_type)
        end if

        if(primal) then
            if(.not. turbine_face .or. turbine_fluxfac>=0) then
                   call construct_momentum_interface_dg(ele, face, face_2, ni,&
                        & big_m_tensor_addto, &
                        & rhs_addto, Grad_U_mat_q, Div_U_mat_q, X,&
                        & Rho, U, U_nl, U_mesh, P, q_mesh, surfacetension, &
                        & velocity_bc, velocity_bc_type, &
                        & pressure_bc, pressure_bc_type, hb_pressure, &
                        & subcycle_m_tensor_addto, subcycle_rhs_addto, nvfrac, &
                        & ele2grad_mat=ele2grad_mat, kappa_mat=kappa_mat, &
                        & inverse_mass_mat=inverse_mass_mat, &
                        & viscosity=viscosity, viscosity_mat=viscosity_mat)
           end if
        else
            if(.not. turbine_face .or. turbine_fluxfac>=0) then
                   call construct_momentum_interface_dg(ele, face, face_2, ni,&
                        & big_m_tensor_addto, &
                        & rhs_addto, Grad_U_mat_q, Div_U_mat_q, X,&
                        & Rho, U, U_nl, U_mesh, P, q_mesh, surfacetension, &
                        & velocity_bc, velocity_bc_type, &
                        & pressure_bc, pressure_bc_type, hb_pressure, &
                        & subcycle_m_tensor_addto, subcycle_rhs_addto, nvfrac)
            end if
        end if

        if (dg) then
            start=start+face_loc(U, face_2)
        end if
  
      end do neighbourloop
    
      !----------------------------------------------------------------------
      ! Construct local diffusivity operator for DG.
      !----------------------------------------------------------------------

      if(have_viscosity) then

        select case(viscosity_scheme)
        case(ARBITRARY_UPWIND)
            call local_assembly_arbitrary_upwind
        case(BASSI_REBAY)
          if (partial_stress) then
            call local_assembly_bassi_rebay_stress_form
          else
            call local_assembly_bassi_rebay
          end if
        end select
        
        if (boundary_element) then

          ! Weak application of dirichlet conditions on viscosity term.

          weak_dirichlet_loop: do i=1,2
            ! this is done in 2 passes
            ! iteration 1: wipe the rows corresponding to weak dirichlet boundary faces
            ! iteration 2: for columns corresponding to weak dirichlet boundary faces,
            !               move this coefficient multiplied with the bc value to the rhs
            !               then wipe the column
            ! The 2 iterations are necessary for elements with more than one weak dirichlet boundary face
            ! as we should not try to move the coefficient in columns corresponding to boundary face 1
            ! in rows correspoding to face 2 to the rhs, i.e. we need to wipe *all* boundary rows first.

            do dim=1,NDIM(U)

              ! Local node map counter.
              start=loc+1

              boundary_neighbourloop: do ni=1,size(neigh)
                ele_2=neigh(ni)

                ! Note that although face is calculated on field U, it is in fact
                ! applicable to any field which shares the same mesh topology.
                if (ele_2>0) then
                  ! Interior face - we need the neighbouring face to
                  ! calculate the new start
                  face=ele_face(U, ele_2, ele)
                else   
                  ! Boundary face
                  face=ele_face(U, ele, ele_2)
                  if (velocity_bc_type(dim,face)==1) then

                    ! Dirichlet condition.

                    finish=start+FLOC(U, face)-1

                    if (i==1) then
                      !// Wipe out boundary condition's coupling to itself.
                      Viscosity_mat(:,dim,start:finish,:)=0.0
                    else
                      ! Add BC into RHS
                      !
                      do dim1=1,NDIM(U)
                        rhs_addto(dim1,:) = rhs_addto(dim1,:) &
                             & -matmul(Viscosity_mat(dim1,dim,:,start:finish), &
                             & ele_val(velocity_bc,dim,face))
                      end do
                      ! Ensure it is not used again.
                      Viscosity_mat(:,dim,:,start:finish)=0.0
                    end if
                    ! Check if face is turbine face (note: get_entire_boundary_condition only returns 
                    ! "applied" boundaries and we reset the apply status in each timestep)
                  elseif (velocity_bc_type(dim,face)==4 .or. velocity_bc_type(dim,face)==5) then  
                    face=face_neigh(turbine_conn_mesh, face)
                  end if
                end if
                start=start+FLOC(U, face)

              end do boundary_neighbourloop

            end do

          end do weak_dirichlet_loop

        end if
  
        ! Insert viscosity in matrix.
        big_m_tensor_addto = big_m_tensor_addto + Viscosity_mat*theta*dt
        
        do dim1=1,NDIM(U)
          do dim2=1, NDIM(U)
            rhs_addto(dim1, :) = rhs_addto(dim1, :) &
                 - matmul(Viscosity_mat(dim1,dim2,:,:), &
                 node_val(U, dim2, local_glno))
          end do
        end do
        
     end if !have_viscosity
    
    end if !dg.and.(have_viscosity.or.have_advection)
    
    !----------------------------------------------------------------------
    ! Perform global assembly.
    !----------------------------------------------------------------------
    
    if (assemble_element) then

       ! add lumped terms to the diagonal of the matrix
       call add_diagonal_to_tensor(big_m_diag_addto, big_m_tensor_addto)
       
       if(dg.and.(have_viscosity.or.have_advection)) then
         
          ! first the diagonal blocks, i.e. the coupling within the element
          ! and neighbouring face nodes but with the same component
          if(have_viscosity) then
            if(partial_stress) then
              call addto(big_m, local_glno, local_glno, &
                   big_m_tensor_addto)
            else
              ! add to the matrix
              call addto(big_m, local_glno, local_glno, big_m_tensor_addto, &
                   block_mask=diagonal_block_mask)
            end if
            ! add to the rhs
            call addto(rhs, local_glno, rhs_addto)
          else
             ! add to the matrix
             call addto(big_m, u_ele, local_glno, big_m_tensor_addto(:,:,:loc,:), &
                block_mask=diagonal_block_mask)
             ! add to the rhs
             call addto(rhs, u_ele, rhs_addto(:,:loc))
          end if
          if(subcycle) then
             call addto(subcycle_m, u_ele, local_glno,&
                  &subcycle_m_tensor_addto(:,:,:loc,:), &
                  &block_mask=diagonal_block_mask)
             call addto(subcycle_rhs, u_ele, subcycle_rhs_addto)
          end if
          if(.not. partial_stress .and. have_coriolis) then
            ! add in coupling between different components, but only within the element
            call addto(big_m, u_ele, u_ele, &
                 big_m_tensor_addto(:,:,:loc,:loc), block_mask&
                 &=off_diagonal_block_mask)
          end if
       else
          ! in this case we only have coupling between nodes within the element
          if (have_coriolis) then
             call addto(big_m, u_ele, u_ele, big_m_tensor_addto(:,:,:loc,:loc))
          else
            ! add to the matrix
            call addto(big_m, u_ele, u_ele, big_m_tensor_addto(:,:,:loc,:loc), &
               block_mask=diagonal_block_mask)
          end if
          ! add to the rhs
          call addto(rhs, u_ele, rhs_addto(:,:loc))
       end if
         
    end if


  contains
 
    subroutine local_assembly_arbitrary_upwind
      integer :: d3

      do dim1=1, Viscosity%dim(1)
         do dim2=1,Viscosity%dim(2)
            do d3 = 1, MDIM(U)
               ! Div U * G^U * Viscosity * G * Grad U
               ! Where G^U*G = inverse(Q_mass)
               Viscosity_mat(d3,d3,:,:)=Viscosity_mat(d3,d3,:,:)&
                    +0.5*( &
                    +matmul(matmul(transpose(grad_U_mat_q(dim1,:,:))&
                    &         ,mat_diag_mat(Q_inv, Viscosity_ele(dim1,dim2,:)))&
                    &     ,grad_U_mat_q(dim2,:,:))& 
                    +matmul(matmul(transpose(div_U_mat_q(dim1,:,:))&
                    &         ,mat_diag_mat(Q_inv, Viscosity_ele(dim1,dim2,:)))&
                    &     ,div_U_mat_q(dim2,:,:))&
                    &)
            end do
         end do
      end do
      
    end subroutine local_assembly_arbitrary_upwind
    
    subroutine local_assembly_bassi_rebay
     
      integer :: d3

      do dim1=1, Viscosity%dim(1)
         do dim2=1,Viscosity%dim(2)
            do d3 = 1, MDIM(U)

               ! Div U * G^U * Viscosity * G * Grad U
               ! Where G^U*G = inverse(Q_mass)
               Viscosity_mat(d3,d3,:,:)=Viscosity_mat(d3,d3,:,:)&
                  +matmul(matmul(transpose(grad_U_mat_q(dim1,:,:))&
                  &         ,mat_diag_mat(Q_inv, Viscosity_ele(dim1,dim2,:)))&
                  &     ,grad_U_mat_q(dim2,:,:))

            end do
         end do
      end do
      
    end subroutine local_assembly_bassi_rebay
    
    subroutine local_assembly_bassi_rebay_stress_form

      ! Instead of:
      !   M_v = G^T_m (\nu Q^{-1})_mn G_n
      ! We construct:
      !   M_v_rs = G^T_m A_rmsn Q^{-1} G_n
      ! where A is a dim x dim x dim x dim linear operator:
      !   A_rmsn = \partial ( \nu ( u_{r,m} + u_{m,r} ) ) / \partial u_{s,n}
      !   where a_{b,c} = \partial a_b / \partial x_c
      ! off diagonal terms define the coupling between the velocity components

      real, dimension(size(Q_inv,1), size(Q_inv,2)) :: Q_visc
      real, dimension(NLOC(u, ele)) :: isotropic_visc

      dim = Viscosity%dim(1)
      isotropic_visc = Viscosity_ele(1,1,:)
      if (have_les) then
        call les_viscosity(isotropic_visc)
      end if
      Q_visc = mat_diag_mat(Q_inv, isotropic_visc)

      do dim1=1,NDIM(U)
        do dim2=1,NDIM(U)
          do dim3=1,NDIM(U) 
            do dim4=1,NDIM(U)
              if (dim1==dim2 .and. dim2==dim3 .and. dim3==dim4) then
                Viscosity_mat(dim1,dim3,:,:) = Viscosity_mat(dim1,dim3,:,:) &
                     + 2.0 * matmul(matmul(transpose(grad_U_mat_q(dim2,:,:)),Q_visc),grad_U_mat_q(dim4,:,:))
              else if  ((dim1==dim3 .and. dim2==dim4) .or. (dim2==dim3 .and. dim1==dim4)) then
                Viscosity_mat(dim1,dim3,:,:) = Viscosity_mat(dim1,dim3,:,:) &
                     + matmul(matmul(transpose(grad_U_mat_q(dim2,:,:)),Q_visc),grad_U_mat_q(dim4,:,:))
              end if
            end do
          end do
        end do
      end do
      
    end subroutine local_assembly_bassi_rebay_stress_form

    subroutine add_diagonal_to_tensor(big_m_diag_addto, big_m_tensor_addto)
      real, dimension(NDIM(U), EFLOC(U,ele)), intent(in) :: big_m_diag_addto
      real, dimension(NDIM(U), NDIM(U), EFLOC(U,ele), EFLOC(U,ele)), intent(inout) :: big_m_tensor_addto
      
      integer :: dim, loc
      
      forall(dim = 1:size(big_m_diag_addto, 1), loc = 1:size(big_m_diag_addto, 2))
        big_m_tensor_addto(dim, dim, loc, loc) = big_m_tensor_addto(dim, dim, loc, loc) + big_m_diag_addto(dim, loc)
      end forall
      
    end subroutine add_diagonal_to_tensor

    subroutine les_viscosity(isotropic_visc)

      !!! Calculate LES contribution to the viscosity in the momentum equation.

      !!! This is a Smagorinsky style model

      !!! \nu_{eddy} = C_s Delta x_{grid} | S | where
      !!! S= ( \nabla u + \nabla u ^T )/2.0

      real, dimension(NLOC(U,ele)), intent(inout) :: isotropic_visc

      real, dimension(NLOC(U,ele)) :: les_filter_width
      real, dimension(MDIM(u), MDIM(u), NLOC(U,ele)) :: g_nl
      real, dimension(MDIM(u), MDIM(u)) :: s
      real, dimension(NLOC(U,ele)) :: s_mod
      real, dimension(NLOC(U,ele)) :: les_scalar_viscosity, y_wall, y_plus
      real, dimension(NLOC(U,ele), NLOC(U,ele)) :: M_inv

      ! get inverse mass
      M_inv = shape_shape(u_shape, u_shape, detwei)
      call invert(M_inv)
      
      ! Compute gradient of non-linear velocity
      do dim1=1,MDIM(u)
        do dim2=1,MDIM(u)
          ! interior contribution
          g_nl(dim1,dim2,:)=matmul(grad_U_mat_q(dim2,:,:loc), ele_val(u_nl,dim1,ele))

          !// boundary contributions (have to be done seperately as we need to apply bc's at boundaries)
          !// local node map counter.
          start=loc+1
          do ni=1,size(neigh)
            ! get neighbour ele, corresponding faces, and complete local node map
            ele_2=neigh(ni)

            if (ele_2>0) then
              ! obtain corresponding faces, and complete local node map
              face=ele_face(U, ele_2, ele)
              finish=start+FLOC(U, face)-1  
              ! for interior faces we use the face values  
              g_nl(dim1,dim2,:)=g_nl(dim1,dim2,:)+matmul(grad_U_mat_q(dim2,:,start:finish), face_val(u_nl,dim1,face))
            else
              ! obtain corresponding faces, and complete local node map
              face=ele_face(U, ele, ele_2)
              finish=start+FLOC(U, face)-1 
              ! for boundary faces the value we use depends upon if a weak bc is applied
              if (velocity_bc_type(dim1,face)==1) then
                ! weak bc! use the bc value
                g_nl(dim1,dim2,:)=g_nl(dim1,dim2,:)+matmul(grad_U_mat_q(dim2,:,start:finish), ele_val(velocity_bc,dim1,face))
              else
                ! no weak bc, use node values on internal face
                g_nl(dim1,dim2,:)=g_nl(dim1,dim2,:)+matmul(grad_U_mat_q(dim2,:,start:finish), face_val(u_nl,dim1,face))
              end if
            end if

            ! update node map counter
            start=start+face_loc(U, face)
          end do

          ! apply inverse mass
          g_nl(dim1,dim2,:)=matmul(M_inv, g_nl(dim1,dim2,:))
        end do
      end do

      ! call calculate_les_grad_u(g_nl)

      ! Compute modulus of strain rate
      do i=1,NLOC(U,ele)
        s=0.5*(g_nl(:,:,i)+transpose(g_nl(:,:,i)))
        ! Calculate modulus of strain rate
        s_mod(i)=sqrt(2*sum(s**2))
      end do

      ! Compute filter width
      if (associated(prescribed_filter_width)) then
        les_filter_width = ele_val(prescribed_filter_width, ele)
      else
        ! when using the element size to compute the filter width we assume the filter 
        ! width is twice the element size
        les_filter_width = 2*length_scale_scalar(X, ele)
      end if

      ! apply Van Driest damping functions
      if (associated(distance_to_wall)) then
        y_wall = ele_val(distance_to_wall, ele)
        do i=1,NLOC(U,ele)
          y_plus(i) = y_wall(i) * sqrt(norm2(g_nl(:,:,i)+transpose(g_nl(:,:,i))))/sqrt(isotropic_visc(i))
        end do
        les_filter_width = (1 - exp(-1.0*y_plus/25.0))*les_filter_width
        
        ! debugging fields
        if (associated(y_plus_debug)) then
          call set(y_plus_debug, ele_nodes(y_plus_debug, ele), y_plus)
        end if
      end if 

      if (associated(les_filter_width_debug)) then
        call set(les_filter_width_debug, ele_nodes(les_filter_width_debug, ele), les_filter_width)
      end if

      les_scalar_viscosity = (les_filter_width*smagorinsky_coefficient)**2 * s_mod

      ! store sgs viscosity
      if (associated(eddy_visc)) then
        call set(eddy_visc, ele_nodes(eddy_visc, ele), les_scalar_viscosity)
      end if

      ! Add to molecular viscosity
      isotropic_visc = isotropic_visc + les_scalar_viscosity
      
    end subroutine les_viscosity
    
  end subroutine WRAP_NAME(construct_momentum_element_dg)


  subroutine WRAP_NAME(construct_momentum_interface_dg)(ele, face, face_2, ni, &
       & big_m_tensor_addto, &
       & rhs_addto, Grad_U_mat, Div_U_mat, X, Rho, U,&
       & U_nl, U_mesh, P, q_mesh, surfacetension, &
       & velocity_bc, velocity_bc_type, &
       & pressure_bc, pressure_bc_type, hb_pressure, &
       & subcycle_m_tensor_addto, subcycle_rhs_addto, nvfrac, &
       & ele2grad_mat, kappa_mat, inverse_mass_mat, &
       & viscosity, viscosity_mat)
    !!< Construct the DG element boundary integrals on the ni-th face of
    !!< element ele.
    implicit none

    logical :: CDG_switch_in

    integer, intent(in) :: ele, face, face_2, ni
    real, dimension(:,:,:,:), intent(inout) :: big_m_tensor_addto
    real, dimension(:,:,:,:), intent(inout) :: subcycle_m_tensor_addto
    real, dimension(:,:), intent(inout) :: rhs_addto, subcycle_rhs_addto
    real, dimension(:,:,:), intent(inout) :: Grad_U_mat, Div_U_mat
    ! We pass these additional fields to save on state lookups.
    type(vector_field), intent(in) :: X, U, U_nl
    type(vector_field), pointer :: U_mesh
    type(scalar_field), intent(in) :: Rho, P
    type(scalar_field), intent(in) :: nvfrac
    !! Mesh of the auxiliary variable in the second order operator.
    type(mesh_type), intent(in) :: q_mesh
    !! surfacetension
    type(tensor_field), intent(in) :: surfacetension
    !! Boundary conditions associated with this interface (if any).
    type(vector_field), intent(in) :: velocity_bc
    integer, dimension(:,:), intent(in) :: velocity_bc_type
    type(scalar_field), intent(in) :: pressure_bc
    integer, dimension(:), intent(in) :: pressure_bc_type
    type(scalar_field), intent(in) :: hb_pressure

    !! Computation of primal fluxes and penalty fluxes
    real, intent(in), optional, dimension(:,:,:) :: ele2grad_mat

    !! \Int_{ele} N_i kappa N_j dV, used for CDG fluxes
    real, dimension(:,:,:,:), intent(in), optional :: kappa_mat

    !! Inverse element mass matrix.
    real, dimension(:,:), intent(in), optional :: inverse_mass_mat

    type(tensor_field), intent(in), optional :: viscosity

    !! Local viscosity matrix for assembly.
    real, intent(inout), dimension(:,:,:,:), optional :: viscosity_mat

    ! Matrix for assembling primal fluxes
    ! Note that this assumes same order polys in each element
    ! Code will need reorganising for p-refinement
    real, dimension(2,FLOC(U,face),NLOC(U,ele)) ::&
         & primal_fluxes_mat

    ! Matrix for assembling penalty fluxes
    ! Note that this assumes same order polys in each element
    ! Code will need reorganising for p-refinement
    real, dimension(2,FLOC(U,face),FLOC(U,face)) ::&
         & penalty_fluxes_mat

    ! \Int_{s_ele} N_iN_j n ds, used for CDG fluxes
    real, dimension(MDIM(U),FLOC(U,face),FLOC(U,face)) :: &
         & normal_mat

    ! \Int_{s_ele} N_iN_j kappa.n ds, used for CDG fluxes
    ! Note that this assumes same order polys in each element
    ! Code will need reorganising for p-refinement
    real, dimension(MDIM(U),FLOC(U,face),FLOC(U,face)) :: &
         & kappa_normal_mat

    ! Face objects and numberings.
    type(element_type), pointer :: u_shape, u_shape_2, p_shape, q_shape
    integer, dimension(FLOC(U,face)) :: u_face_l
    ! This has to be a pointer to work around a stupid gcc bug.
    integer, dimension(:), pointer :: q_face_l

    ! Note that both sides of the face can be assumed to have the same
    ! number of quadrature points.
    real, dimension(FNGI(U_nl,face)) :: Rho_q, nvfrac_gi
    real, dimension(NDIM(U), FNGI(U_nl,face)) :: normal, u_nl_q,&
         & u_f_q, u_f2_q, div_u_f_q
    logical, dimension(FNGI(U,face)) :: inflow
    real, dimension(FNGI(U,face)) :: u_nl_q_dotn, income
    ! Variable transform times quadrature weights.
    real, dimension(FNGI(U_nl,face)) :: detwei
    real, dimension(FNGI(U_nl,face)) :: inner_advection_integral, outer_advection_integral

    ! Bilinear forms
    real, dimension(FLOC(U,face),FLOC(U,face)) :: nnAdvection_out
    real, dimension(FLOC(U,face),FLOC(U,face_2)) :: nnAdvection_in
    real, dimension(1,MDIM(U), P_FLOC,FLOC(U,face)) :: mnCT
    
    ! Viscosity values on face (used for CDG and IP fluxes)
    real, dimension(:,:,:), allocatable :: kappa_gi

    ! surfacetension stuff
    real, dimension(NDIM(U), NDIM(U), FLOC(U,face)) :: tension_q
    
    integer :: dim, start, finish, floc
    logical :: boundary, free_surface, no_normal_flow, l_have_pressure_bc
    logical, dimension(NDIM(U)) :: dirichlet

    logical :: p0

    integer :: d1, d2

    floc = FLOC(U,face)

    start=NLOC(u,ele)+(ni-1)*FLOC(U, face_2)+1
    finish=start+FLOC(U, face_2)-1
    
#ifdef GENERIC
    p0=(element_degree(u,ele)==0)
#else
    p0 = .false.
#endif

    ! Get Density and (non-linear) PhaseVolumeFraction values 
    ! at the Gauss points on the current face.
    Rho_q=face_val_at_quad(Rho, face)

    if(multiphase) then
       nvfrac_gi = face_val_at_quad(nvfrac, face)
    end if

    if(present(viscosity)) then
       allocate( kappa_gi(Viscosity%dim(1), Viscosity%dim(2), &
            FNGI(Viscosity,face)) )

       kappa_gi = face_val_at_quad(Viscosity, face)

       if(multiphase) then
          ! Multiply the viscosity tensor by the PhaseVolumeFraction 
          ! since kappa = viscosity*vfrac for multiphase flow simulations.
          do d1=1,Viscosity%dim(1)
             do d2=1,Viscosity%dim(2)
                kappa_gi(d1,d2,:) = kappa_gi(d1,d2,:)*nvfrac_gi
             end do
          end do
       end if
       
    end if

    u_face_l=face_local_nodes(U, face)
    u_shape=>face_shape(U, face)

    u_shape_2=>face_shape(U, face_2)
    
    p_shape=>face_shape(P, face)

    q_face_l=>face_local_nodes(q_mesh, face)
    q_shape=>face_shape(q_mesh, face)

    ! Boundary nodes have both faces the same.
    boundary=(face==face_2)
    dirichlet=.false.
    free_surface=.false.
    no_normal_flow=.false.
    l_have_pressure_bc=.false.
    if (boundary) then
       do dim=1,NDIM(U)
          if (velocity_bc_type(dim,face)==1) then
             dirichlet(dim)=.true.
          end if
       end do
       ! free surface b.c. is set for the 1st (normal) component
       if (velocity_bc_type(1,face)==2) then
          free_surface=.true.
       end if
       ! no normal flow b.c. is set for the 1st (normal) component
       if (velocity_bc_type(1,face)==3) then
          ! No normal flow is implemented here by switching off the
          ! advection boundary integral.
          no_normal_flow=.true.
       end if
       l_have_pressure_bc = pressure_bc_type(face) > 0
    end if

    !----------------------------------------------------------------------
    ! Change of coordinates on face.
    !----------------------------------------------------------------------
    call transform_facet_to_physical(X, face,&
         &                          detwei_f=detwei,&
         &                          normal=normal) 
        
    !----------------------------------------------------------------------
    ! Construct bilinear forms.
    !----------------------------------------------------------------------

    if(have_advection.and..not.no_normal_flow) then
      ! Advecting velocity at quadrature points.
       u_f_q = face_val_at_quad(U_nl, face)
       u_f2_q = face_val_at_quad(U_nl, face_2)
       U_nl_q=0.5*(u_f_q+u_f2_q)

      if(p0) then
        ! in this case the surface integral of u_f_q is zero so we need
        ! to modify it to be a suitable measure of divergence
        div_u_f_q = U_nl_q
      else
        div_u_f_q = u_f_q
      end if
      
      ! Mesh velocity at quadrature points.
      if(move_mesh) then
        ! here we assume that U_mesh at face is the same as U_mesh at face_2
        ! if it isn't then you're in trouble because your mesh will tear
        ! itself apart
        u_nl_q=u_nl_q - face_val_at_quad(U_mesh, face)
        !// the velocity on the internal face isn't used again so we can
        !// modify it directly here...
        u_f_q = u_f_q - face_val_at_quad(U_mesh, face)
      end if
  
      u_nl_q_dotn = sum(U_nl_q*normal,1)

      ! Inflow is true if the flow at this gauss point is directed
      ! into this element.
      inflow= u_nl_q_dotn<0.0
      income = merge(1.0,0.0,inflow)
      
      ! Calculate outflow boundary integral.
      ! can anyone think of a way of optimising this more to avoid
      ! superfluous operations (i.e. multiplying things by 0 or 1)?

      ! first the integral around the inside of the element
      ! (this is the flux *out* of the element)
      inner_advection_integral = (1.-income)*u_nl_q_dotn
      if(.not.integrate_by_parts_once) then
        !// i.e. if we're integrating by parts twice
        inner_advection_integral = inner_advection_integral &
                                    - sum(u_f_q*normal,1)
      end if
      if(integrate_conservation_term_by_parts) then
        if(integrate_by_parts_once) then
          inner_advection_integral = inner_advection_integral &
                                      - (1.-beta)*sum(div_u_f_q*normal,1)
        else
          ! i.e. integrating by parts twice
          inner_advection_integral = inner_advection_integral &
                                      + beta*sum(div_u_f_q*normal,1)
        end if
      end if
      
      if(multiphase) then
         nnAdvection_out=shape_shape(U_shape, U_shape,  &
             &                        inner_advection_integral * detwei * Rho_q * nvfrac_gi) 
      else
         nnAdvection_out=shape_shape(U_shape, U_shape,  &
             &                        inner_advection_integral * detwei * Rho_q) 
      end if
      
      ! now the integral around the outside of the element
      ! (this is the flux *in* to the element)
      outer_advection_integral = income * u_nl_q_dotn
      if(multiphase) then
         nnAdvection_in=shape_shape(U_shape, U_shape_2, &
             &                       outer_advection_integral * detwei * Rho_q * nvfrac_gi)
      else
         nnAdvection_in=shape_shape(U_shape, U_shape_2, &
             &                       outer_advection_integral * detwei * Rho_q)
      end if

      do dim = 1, NDIM(U)
      
         ! Insert advection in matrix.
         if(subcycle) then
            subcycle_m_tensor_addto(dim, dim, u_face_l, u_face_l) = &
                 &subcycle_m_tensor_addto(dim, dim, u_face_l, u_face_l) + &
                 &nnAdvection_out
              
            if (.not.dirichlet(dim)) then
               subcycle_m_tensor_addto(dim, dim, u_face_l, start:finish) = &
                    &subcycle_m_tensor_addto(dim, dim, u_face_l, start:finish)&
                    &+nnAdvection_in
            else
               ! on a Dirichlet boundary, the incoming advection term
               ! on the lhs is replaced by the same term on the right using
               ! the boundary value - outgoing term is the same as always
               ! (meaning no dirichlet bc is applied on outgoing facets)
               subcycle_rhs_addto(dim,u_face_l) = subcycle_rhs_addto(dim,u_face_l) &
                    -matmul(nnAdvection_in,ele_val(velocity_bc,dim,face))
            end if
         else
            big_m_tensor_addto(dim, dim, u_face_l, u_face_l) = &
                 big_m_tensor_addto(dim, dim, u_face_l, u_face_l) + &
                 nnAdvection_out*dt*theta
              
            if (.not.dirichlet(dim)) then
               big_m_tensor_addto(dim, dim, u_face_l, start:finish) = &
                    big_m_tensor_addto(dim, dim, u_face_l, start:finish) + &
                    nnAdvection_in*dt*theta

               rhs_addto(dim,u_face_l) = rhs_addto(dim,u_face_l) &
                    -matmul(nnAdvection_out,face_val(U,dim,face))&
                    -matmul(nnAdvection_in,face_val(U,dim,face_2))
            else
               ! on a Dirichlet boundary, the incoming advection term
               ! on the lhs is replaced by the same term on the right using
               ! the boundary value - outgoing term is the same as always
               ! (meaning no dirichlet bc is applied on outgoing facets)
               rhs_addto(dim,u_face_l) = rhs_addto(dim,u_face_l) &
                    -matmul(nnAdvection_out,face_val(U,dim,face))&
                    -matmul(nnAdvection_in,ele_val(velocity_bc,dim,face))
            end if
         end if
      end do
        
    end if

    if (have_viscosity) then
       ! Boundary term in grad_U.
       !   /
       !   | q, u, normal dx
       !   /
       select case (viscosity_scheme)
       case (ARBITRARY_UPWIND)
          call arbitrary_upwind_viscosity
       case (BASSI_REBAY)
          call bassi_rebay_viscosity
       case (IP)
          primal_fluxes_mat = 0.0
          penalty_fluxes_mat = 0.0
          call primal_fluxes
          call interior_penalty
          call local_assembly_primal_face
          call local_assembly_ip_face
       case (CDG)
          primal_fluxes_mat = 0.0
          penalty_fluxes_mat = 0.0
          call primal_fluxes
          if(.not.remove_penalty_fluxes) call interior_penalty
          call get_normal_mat
          call local_assembly_primal_face
          call local_assembly_cdg_face
          call local_assembly_ip_face
       end select

    end if

    if(have_surfacetension.and.integrate_surfacetension_by_parts) then
      tension_q = 0.5*face_val_at_quad(surfacetension,face)+0.5*face_val_at_quad(surfacetension,face_2)
      rhs_addto(:,u_face_l) = rhs_addto(:,u_face_l) + shape_tensor_dot_vector_rhs(u_shape, tension_q, normal, detwei)
    end if
    

    !----------------------------------------------------------------------
    ! Perform global assembly.
    !----------------------------------------------------------------------

    ! Insert pressure boundary integral.
    if (l_include_pressure_bcs .and. boundary .and. l_have_pressure_bc) then
    
       if(multiphase) then
          mnCT(1,:,:,:) = shape_shape_vector(P_shape, U_shape_2, detwei*nvfrac_gi, normal)
       else
          mnCT(1,:,:,:) = shape_shape_vector(P_shape, U_shape_2, detwei, normal)
       end if
       ! for both weak and strong pressure dirichlet bcs:
       !      /
       ! add -|  N_i M_j \vec n p_j, where p_j are the prescribed bc values
       !      /
       do dim = 1, NDIM(U)
          if(subtract_out_reference_profile) then
            rhs_addto(dim,u_face_l) = rhs_addto(dim,u_face_l) - &
                 matmul( ele_val(pressure_bc, face) - face_val(hb_pressure, face), mnCT(1,dim,:,:) )
          else
            rhs_addto(dim,u_face_l) = rhs_addto(dim,u_face_l) - &
                 matmul( ele_val(pressure_bc, face), mnCT(1,dim,:,:) )
          end if
       end do
    end if


   contains

    subroutine arbitrary_upwind_viscosity

       !! Arbitrary upwinding scheme.
       do dim=1,MDIM(U)

          if (normal(dim,1)>0) then          
             ! Internal face.
             Grad_U_mat(dim, q_face_l, U_face_l)=&
                  Grad_U_mat(dim, q_face_l, U_face_l) &
                  +shape_shape(q_shape, U_shape, detwei*normal(dim,:))
             
             ! External face. Note the sign change which is caused by the
             ! divergence matrix being constructed in transpose.
             Div_U_mat(dim, q_face_l, start:finish)=&
                  -shape_shape(q_shape, U_shape_2, detwei*normal(dim,:))
             
             ! Internal face.
             Div_U_mat(dim, q_face_l, U_face_l)=&
                  Div_U_mat(dim, q_face_l, U_face_l) &
                  +shape_shape(q_shape, U_shape, detwei*normal(dim,:))
             
          else
             ! External face.
             Grad_U_mat(dim, q_face_l, start:finish)=&
                  +shape_shape(q_shape, U_shape_2, detwei*normal(dim,:))
             
          end if
       end do

    end subroutine arbitrary_upwind_viscosity

    subroutine bassi_rebay_viscosity

      real, dimension(FNGI(u_nl, face)) :: coefficient_detwei
      
      do dim=1,MDIM(U)

         coefficient_detwei = detwei*normal(dim,:)
         if(multiphase) then
            coefficient_detwei = coefficient_detwei*nvfrac_gi
         end if

         if(.not.boundary) then
            ! Internal face.
            Grad_U_mat(dim, q_face_l, U_face_l)=&
               Grad_U_mat(dim, q_face_l, U_face_l) &
               +0.5*shape_shape(q_shape, U_shape, coefficient_detwei)
            
            ! External face.
            Grad_U_mat(dim, q_face_l, start:finish)=&
               +0.5*shape_shape(q_shape, U_shape_2, coefficient_detwei) 
         else
            ! Boundary case. Put the whole integral in the external bit.

            ! External face.
            Grad_U_mat(dim, q_face_l, start:finish)=&
               +shape_shape(q_shape, U_shape_2, coefficient_detwei)
         end if
      end do

    end subroutine bassi_rebay_viscosity

    subroutine get_normal_mat
      !!< We assemble
      !!< \int_e N_i N_j n dS
      !!< where n is the normal
      !!< indices are (dim1, loc1, loc2)

      integer :: d1,d2

      normal_mat = shape_shape_vector(U_shape,U_shape,detwei,normal)
      
      !!< We assemble
      !!< \int_e N_i N_j kappa.n dS
      !!< where n is the normal
      !!< indices are (dim1, loc1, loc2)

      kappa_normal_mat = 0
      do d1 = 1, MDIM(U)
         do d2 = 1, MDIM(U)
            kappa_normal_mat(d1,:,:) = kappa_normal_mat(d1,:,:) + &
                 & shape_shape(U_shape,U_shape,detwei* &
                 & kappa_gi(d1,d2,:)*normal(d2,:))
         end do
      end do

    end subroutine get_normal_mat

     subroutine primal_fluxes

      !!< Notes for primal fluxes which are present in the interior penalty
      !!< and CDG methods (and, I believe, the LDG method when written in
      !! primal form)

      !!< We assemble 

      !!< -Int_e [u]{kappa grad v} + [v]{kappa grad u}

      !!< = -Int_e 1/2(u^+n^+ + u^-n^-).(kappa^+ grad v^+ + kappa^- grad v^-)
      !!<  -Int_e 1/2(v^+n^+ + v^-n^-).(kappa^+ grad u^+ + kappa^- grad u^-)

      !!< Where + is the ele side, and - is the ele_2 side, and e is the edge

      !!<Computing grad u (and v) requires a element transform to physical
      !!<so we only assemble the + parts here, and the minus parts of the grad
      !!<will be assembled when we visit that element 

      !!<So we assemble

      !!<  -Int_e 1/2 (u^+ - u^-)n^+.kappa^+ grad v^+
      !!< -Int_e 1/2 (v^+ - v^-)n^+.kappa^+ grad u^+

      !!<Actually we won't even do that, we'll just assemble the second
      !!<line, and apply the transpose operator

      !!<Note that grad v is obtained in element ele from ele2grad_mat

      !!<On the (Dirichlet) boundary we are assembling 

      !!< -Int_e (v n. kappa grad u + u n. kappa grad v)

      !!//< In practise we'll assemble it everywhere and only 
      !!//< add it on if we have a Dirichlet boundary

      !!< primal_fluxes_mat(1,:,:) maps from ele degrees of freedom
      !!<                                 to internal face dof
      !!< primal_fluxes_mat(2,:,:) maps from ele degrees of freedom
      !!<                                 to external face dof
      !!<                                 or face boundary conditions

      !!< For the extra CDG term, we assemble 

      !!< -Int_e (C_{12}.[u][kappa grad v] + C_{12}.[v][kappa grad u]

      !!<=-Int C_{12}.(u^+n^+ + u^-n^-)((kappa^+ grad v^+).n^+ +(kappa^- grad v^-).n^-)
      !!<=-Int C_{12}.(v^+n^+ + v^-n^-)((kappa^+ grad u^+).n^+ +(kappa^- grad u^-).n^-)
      !!< Where + is the ele side, and - is the ele_2 side, and e is the
      !! edge

      !!< C_{12} = either (1/2)n^+ or (1/2)n^-
      !!< Take (1/2)n^+ if switch_g . n^+>

      !!<Computing grad u (and v) requires a element transform to physical
      !!<so we only assemble the + parts here, and the minus parts of the grad
      !!<will be assembled when we visit that element 

      !!<So we assemble

      !!< - or + Int_e 1/2 (u^+ - u^-) (kappa^+ grad v^+).n^+
      !!< - or + Int_e 1/2 (v^+ - v^-) (kappa^+ grad u^+).n^+

      !! Compare with the primal flux term

      !!<  -Int_e 1/2 (u^+ - u^-)n^+.kappa^+ grad v^+
      !!< -Int_e 1/2 (v^+ - v^-)n^+.kappa^+ grad u^+

      !!< where we take the minus if switch_g.n^+>0 and plus otherwise

      !!< Note that this means that it cancels the primal term if 
      !!<switch_g.n^+<0 and doubles it otherwise

      integer :: d1, d2
      real :: flux_factor

      if(viscosity_scheme==CDG) then
         flux_factor = 0.0
         CDG_switch_in = (sum(switch_g(1:MDIM(U))*sum(normal,2)/size(normal,2))>0)
         if(CDG_switch_in) flux_factor = 1.0
      else
         flux_factor = 0.5
         CDG_switch_in = .true.
      end if

      do d1 = 1, MDIM(U)
         do d2 = 1, MDIM(U)
            !  -Int_e 1/2 (u^+ - u^-)n^+.kappa^+ grad v^+
            if(.not.boundary) then
               ! Internal face.
               if(CDG_switch_in) then
                  primal_fluxes_mat(1,:,:) =&
                       primal_fluxes_mat(1,:,:)&
                       -flux_factor*matmul( &
                       shape_shape(U_shape,U_shape, &
                       & detwei * normal(d1,:) * kappa_gi(d1,d2,:)), &
                       ele2grad_mat(d2,U_face_l,:))
                  
                  ! External face.
                  primal_fluxes_mat(2,:,:) =&
                       primal_fluxes_mat(2,:,:)&
                       +flux_factor*matmul( &
                       shape_shape(U_shape,U_shape, &
                       & detwei * normal(d1,:) * kappa_gi(d1,d2,:)), &
                       ele2grad_mat(d2,U_face_l,:))
               end if
            else
               !If a Dirichlet boundary, we add these terms, otherwise not.
                     
               !we do the entire integral on the inside face
               primal_fluxes_mat(1,:,:) =&
                    primal_fluxes_mat(1,:,:)&
                    -matmul( &
                    shape_shape(U_shape,U_shape, &
                    & detwei * normal(d1,:) * kappa_gi(d1,d2,:)), &
                    ele2grad_mat(d2,U_face_l,:))
               
               !There is also a corresponding boundary condition integral
               !on the RHS
               primal_fluxes_mat(2,:,:) =&
                    primal_fluxes_mat(2,:,:)&
                    +matmul( &
                    shape_shape(U_shape,U_shape, &
                    & detwei * normal(d1,:) * kappa_gi(d1,d2,:)), &
                    ele2grad_mat(d2,U_face_l,:))
            end if
         end do
      end do

    end subroutine primal_fluxes  

    subroutine interior_penalty

      !! Ripped from Advection_Diffusion_DG.F90 == cjc

      !! We assemble 

      !! Int_e [u][v]

      !! = Int_e C(u^+n^+ + u^-n^-).(v^+n^+ + v^-n^-)

      !! Where + is the ele side, and - is the ele_2 side, and e is the edge
      !! and C is the penalty parameter

      !! We are only storing trial functions from this element, so
      !! will assemble the u^+ parts only, the u^- parts will be done 
      !! from the other side

      !!So we assemble

      !!  Int_e C u^+ (v^+ - v^-)

      !!On the (Dirichlet) boundary we are assembling 

      !! Int_e C uv

      !!// In practise we'll assemble it everywhere and only 
      !!// add it on if we have a Dirichlet boundary

      !! penalty_fluxes_mat(1,:,:) maps from internal face dof
      !!                                 to internal face dof
      !! penalty_fluxes_mat(2,:,:) maps from internal face dof
      !!                                 to external face dof
      !!                                 or face boundary conditions

      ! Penalty parameter is C_0/h where h is the distance between the 
      ! cell centre and the neighbours cell centre

      real :: C_h
      integer :: nf, d1, d2

      real, dimension(size(kappa_gi,3)) :: kappa_n
      nf = face_loc(U,face)

      kappa_n = 0.0
      do d1 = 1, MDIM(U)
         do d2 = 1, MDIM(U)
            kappa_n = kappa_n + &
                 normal(d1,:)*kappa_gi(d1,d2,:)*normal(d2,:)
         end do
      end do

      if(EDGE_LENGTH_OPTION==USE_FACE_INTEGRALS) then
         h0 = sum(detwei)
         if(MDIM(U)==3) h0 = sqrt(h0) 
      end if

      if(cdg_penalty) then
         C_h = Interior_Penalty_Parameter
      else
         C_h = Interior_Penalty_Parameter*(h0**edge_length_power)
      end if
 
      !If a dirichlet boundary then we add these terms, otherwise not

      penalty_fluxes_mat(1,:,:) =&
           penalty_fluxes_mat(1,:,:)+&
      !     C_h*shape_shape(U_shape,U_shape,detwei)
           C_h*shape_shape(U_shape,U_shape,detwei*kappa_n)
      
      penalty_fluxes_mat(2,:,:) =&
           penalty_fluxes_mat(2,:,:)-&
           !C_h*shape_shape(U_shape,U_shape,detwei)
      C_h*shape_shape(U_shape,U_shape,detwei*kappa_n)

    end subroutine interior_penalty

    subroutine local_assembly_ip_face
      implicit none

      integer :: d
      integer :: nfele, nele
      integer, dimension(FLOC(U,face)) :: U_face_loc

      nfele = FLOC(U,face)
      nele = NLOC(U,ele)
      u_face_loc=face_local_nodes(U, face)


      if (boundary) then
         do d=1,NDIM(U)
            if(dirichlet(d)) then
               !!These terms are not included on Neumann integrals

               !! Internal Degrees of Freedom
               
               !penalty flux
               
               Viscosity_mat(d,d,u_face_loc,u_face_loc) = &
                    Viscosity_mat(d,d,u_face_loc,u_face_loc) + &
                    penalty_fluxes_mat(1,:,:)

               !! External Degrees of Frfeedom
               
               !!penalty fluxes

               Viscosity_mat(d,d,u_face_loc,start:finish) = &
                    Viscosity_mat(d,d,u_face_loc,start:finish) + &
                    penalty_fluxes_mat(2,:,:)
               
            end if
         end do
      else
         do d=1,NDIM(U)
            !! Internal Degrees of Freedom
            
            !penalty flux
            
            Viscosity_mat(d,d,u_face_loc,u_face_loc) = &
                 Viscosity_mat(d,d,u_face_loc,u_face_loc) + &
                 penalty_fluxes_mat(1,:,:)
            
            !! External Degrees of Freedom
            
            !!penalty fluxes
            
            Viscosity_mat(d,d,u_face_loc,start:finish) = &
                 Viscosity_mat(d,d,u_face_loc,start:finish) + &
                 penalty_fluxes_mat(2,:,:)

         end do
      end if

    end subroutine local_assembly_ip_face

    subroutine local_assembly_primal_face
      implicit none

      integer :: j,d
      integer :: nele
      integer, dimension(FLOC(U,face)) :: U_face_loc

      nele = NLOC(U,ele)
      u_face_loc=face_local_nodes(U, face)


      if (boundary) then
         do d=1,NDIM(U)
            if(dirichlet(d)) then
               !!These terms are not included on Neumann integrals
               
               !! Internal Degrees of Freedom
               
               !primal fluxes
               
               Viscosity_mat(d,d,u_face_loc,1:nele) = &
                    Viscosity_mat(d,d,u_face_loc,1:nele) + &
                    primal_fluxes_mat(1,:,:)
               
               do j = 1, size(u_face_loc)
                  Viscosity_mat(d,d,1:nele,u_face_loc(j)) = &
                       Viscosity_mat(d,d,1:nele,u_face_loc(j)) + &
                       primal_fluxes_mat(1,j,:) 
               end do

               !primal fluxes

               Viscosity_mat(d,d,1:nele,start:finish) = &
                    Viscosity_mat(d,d,1:nele,start:finish) + &
                    transpose(primal_fluxes_mat(2,:,:)) 
               
            end if
         end do
      else
         do d=1,NDIM(U)
            !! Internal Degrees of Freedom
            
            !primal fluxes
            
            Viscosity_mat(d,d,u_face_loc,1:nele) = &
                 Viscosity_mat(d,d,u_face_loc,1:nele) + &
                 primal_fluxes_mat(1,:,:)
            
            do j = 1, size(u_face_loc)
               Viscosity_mat(d,d,1:nele,u_face_loc(j)) = &
                    Viscosity_mat(d,d,1:nele,u_face_loc(j)) + &
                    primal_fluxes_mat(1,j,:) 
            end do
            
            !! External Degrees of Freedom
            
            !primal fluxes
            
            Viscosity_mat(d,d,start:finish,1:nele) = &
              Viscosity_mat(d,d,start:finish,1:nele) + &
              primal_fluxes_mat(2,:,:)
            
            Viscosity_mat(d,d,1:nele,start:finish) = &
                 Viscosity_mat(d,d,1:nele,start:finish) + &
                 transpose(primal_fluxes_mat(2,:,:))
            
         end do
      end if
      
    end subroutine local_assembly_primal_face

    subroutine local_assembly_cdg_face
      implicit none
      !!< This code assembles the cdg fluxes involving the r_e and l_e lifting
      !!< operators.

      !!< We assemble the operator
      !!< \int (r^e([v]) + l^e(C_{12}.[v]) + r^e_D(v).\kappa.
      !!< (r^e([u]) + l^e(C_{12}.[u]) + r^e_D(u))dV (*)
      !!< This is done by forming the operator R:
      !!< \int v R(u)dV  = \int v (r^e([u]) + l^e(C_{12}.[u]) + r^e_D(u)) dV
      !!< and then constructing
      !!< \int R(v).\kappa.R(u) dV

      !!< The lifting operator r^e is defined by
      !!< \int_E \tau . r^e([u]) dV = - \int_e {\tau}.[u] dS
      !!< = -\frac{1}{2} \int_e {\tau^+ + \tau^-}.(u^+n^+ + u^-n^-) dS
      !!< = -\frac{1}{2} \int_e {\tau^+ + \tau^-}.n^+(u^+ - u^-) dS

      !!< Where + is the ele side, and - is the ele_2 side, and e is the edge

      !!< The lifting operator l^e is defined by
      !!< \int_E \tau . l^e(C_{12}.[u])dV = - \int_e C_{12}.[u][\tau] dS
      !!< = -\int C_{12}.(u^+n^+ + u^-n^-)(\tau^+.n^+ +\tau^-n^-) dS

      !!< C_{12} = either (1/2)n^+ or (1/2)n^-
      !!< Take (1/2)n^+ if switch_g . n^+> 0

      !!becomes
      !!< = \int_e (- or +)(u^+ - u^-)n^+.(\tau^+ - \tau^-) dS
      !!< with minus sign if switch_g  n^+ > 0

      !!< So adding r^e and l^e gives

      !!< = -\frac{1}{2} \int_e {\tau^+ + \tau^-}.n^+(u^+ - u^-) dS
      !!<     + \int_e (- or +)(u^+ - u^-)n^+.(\tau^+ - \tau^-) dS

      !!< = -\int_e \tau^+.n^+(u^+ - u^-) dS if switch_g n^+ > 0
      !!< = -\int_e \tau^-.n^+(u^+ - u^-) dS otherwise

      !!< so definition of r^e+l^e operator is
      !!< \int_E \tau.R(u) dV = -\int_e \tau^+.n^+(u^+ - u^-) dS if switch > 0
      !!< \int_E \tau.R(u) dV = -\int_e \tau^-.n^+(u^+ - u^-) dS if switch < 0

      !!< we are doing DG so the basis functions which are non-zero in E are
      !!< zero outside E, so \tau^- vanishes in this formula, so we get
      !!< \int_E \tau.R(u) dV = -\int_e \tau.n^+(u^+ - u^-) dS if switch > 0
      !!< and R(u) = 0 otherwise.

      !!< finally the boundary lifting operator r^e_D
      !!< \int_E \tau.r^e_D(u) dV =  -\int_e u\tau.n dS

      !!< We assemble the binary form (*) locally with
      !!< B(u,v) = p^TR^T.K.Rq, where p is the vector of coefficients of u in
      !!< element E plus the coefficients of u on the face e on the other side
      !!< K is the matrix obtained from the bilinear form
      !!< \int_E N_i \kappa N_j dV where \kappa is the viscosity tensor and
      !! N_i are the basis functions with support in element E

      !!< The matrix R maps from the coefficients of a scalar field  on both sides of face e
      !!< to the coefficients of a vector field with inside element E
      !!< i.e. size (dim x loc(E),2 x loc(e))
      !!< because of symmetry we just store (dim x loc(E), loc(e)) values
      !!< The matrix K maps from vector fields inside element E to vector
      !!< fields inside element E
      !!< i.e. size (dim x loc(E), dim x loc(E))
      !!< Hence, R^TKR maps from the coefficients of a scalar field on both
      !!< sides of face e to themselves
      !!< i.e. size (2 x loc(E), 2 x 
      !!< It can be thus interpreted as a fancy penalty term for
      !!< discontinuities, a useful one because it is scale invariant

      !!< The matrix R can be formed by constructing the bilinear form matrix
      !!< for r^e, l^e and r^e_D, and then dividing by the elemental mass
      !!<  matrix on E

      !!< we place R^TKR into Viscosity_mat which maps from u
      !!< coefficients in element E plus those on the other side of face e
      !!< to themselves, hence it has size (loc(E) + loc(e), loc(E) + loc(e))

      !!< R^TKR is stored in add_mat which has size(2 x loc(e), 2 x loc(e))

      !!< we are using a few other pre-assembled local matrices
      !!< normal_mat is \int_e \tau.(un) dS (has size (dim x loc(e),loc(e))
      !!< normal_kappa_mat is \int_e \tau.\kappa.(un) dS
      !!< has size (dim x loc(e), loc(e))
      !!< inverse_mass_mat is the inverse mass in E

      integer :: i,j,d1,d2,nele,face1,face2,d
      integer, dimension(FLOC(U,face)) :: U_face_loc    
      real, dimension(MDIM(U),NLOC(U,ele),FLOC(U,face)) :: R_mat
      real, dimension(2,2,FLOC(U,face),FLOC(U,face)) :: add_mat

      nele = NLOC(U,ele)
      u_face_loc=face_local_nodes(U, face)

      R_mat = 0.
      do d1 = 1, MDIM(U)
         do i = 1, NLOC(U,ele)
            do j = 1, FLOC(U,face)
               R_mat(d1,i,j) = &
                    &sum(inverse_mass_mat(i,u_face_loc)*normal_mat(d1,:,j))
            end do
         end do
      end do

      do d=1,NDIM(U)

         add_mat = 0.0
         if(boundary) then
            if (dirichlet(d)) then
               !Boundary case
               ! R(/tau,u) = -\int_e \tau.n u  dS
               !do d1 = 1, MDIM(U)
               !   do d2 = 1, MDIM(U)
               !      add_mat(1,1,:,:) = add_mat(1,1,:,:) + &
               !           matmul(transpose(R_mat(d1,:,:)), &
               !           &matmul(kappa_mat(d1,d2,:,:),R_mat(d2,:,:)))
               !      add_mat(2,2,:,:) = add_mat(2,2,:,:) + &
               !           matmul(transpose(R_mat(d1,:,:)), &
               !           &matmul(kappa_mat(d1,d2,:,:),R_mat(d2,:,:)))
               !   end do
               !end do
               
               do face1 = 1, 2
                  do face2 = 1, 2
                     do d1 = 1, MDIM(U)
                        do d2 = 1, MDIM(U)
                           add_mat(face1,face2,:,:) = add_mat(face1,face2,:,:) + &
                                &(-1.)**(face1+face2)*matmul(transpose(R_mat(d1,:,:)), &
                                &matmul(kappa_mat(d1,d2,:,:),R_mat(d2,:,:)))
                        end do
                     end do
                  end do
               end do
               
            end if
         else if(CDG_switch_in) then
            ! interior case
            ! R(\tau,u) = -\int_e \tau.n^+(u^+ - u^-) dS
            do face1 = 1, 2
               do face2 = 1, 2
                  do d1 = 1, MDIM(U)
                     do d2 = 1, MDIM(U)
                        add_mat(face1,face2,:,:) = add_mat(face1,face2,:,:) + &
                             &(-1.)**(face1+face2)*matmul(transpose(R_mat(d1,:,:)), &
                             &matmul(kappa_mat(d1,d2,:,:),R_mat(d2,:,:)))
                     end do
                  end do
               end do
            end do
         end if

         !face1 = 1, face2 = 1
         
         Viscosity_mat(d,d,u_face_loc,u_face_loc) = &
              &Viscosity_mat(d,d,u_face_loc,u_face_loc) + &
              &add_mat(1,1,:,:)
         
         !face1 = 1, face2 = 2
         
         Viscosity_mat(d,d,u_face_loc,start:finish) = &
              &Viscosity_mat(d,d,u_face_loc,start:finish) + &
              &add_mat(1,2,:,:)
         
         !face1 = 2, face2 = 1
         
         Viscosity_mat(d,d,start:finish,u_face_loc) = &
              Viscosity_mat(d,d,start:finish,u_face_loc) + &
              &add_mat(2,1,:,:)
         
         !face1 = 2, face2 = 2
         
         Viscosity_mat(d,d,start:finish,start:finish) = &
              &Viscosity_mat(d,d,start:finish,start:finish) + &
              &add_mat(2,2,:,:)
      end do

    end subroutine local_assembly_cdg_face

  end subroutine WRAP_NAME(construct_momentum_interface_dg)

